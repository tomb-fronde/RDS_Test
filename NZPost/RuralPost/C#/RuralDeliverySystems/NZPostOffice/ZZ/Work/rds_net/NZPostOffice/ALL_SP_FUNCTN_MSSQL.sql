SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_MailCategory : 
--

CREATE procedure [rd].[sp_DDDW_MailCategory](@in_Business char(1),@in_Residential char(1),@in_Farmer char(1))
as
begin
  select mail_category.mc_key,
    mail_category.mc_description,
    mail_category.mc_mail_category from
    mail_category where
    mail_category.mc_mail_category in(@in_Business,@in_Residential,@in_Farmer)
end

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for stored procedure OD_DWS_OwnerDriver_Search_Region_v2 : 
--

CREATE procedure  [odps].[OD_DWS_OwnerDriver_Search_Region_v2](@inOwnerDriver varchar(40),@inRegion int,@sdate datetime,@edate datetime,@inContractNo int,@inCtKey int)
-- TJB SR4639  3-Dec-2004
-- Added inContractNo and inCtKey parameters.
as -- Add contract number and type to search criteria.
begin
  -- insert into temporary table
 create table #con_temp(
    con_no int null,
    supply int null,
    detail char(100) null,
    ) 
  insert into #con_temp(con_no,
    supply,
    detail)
    select 0,
      0,odcontracts='<All Contractors/Contracts>'  
  insert into #con_temp(con_no,
    supply,
    detail)
    select contract.contract_no,
      contractor.contractor_supplier_no,
      c_surname_company+(case when len(c_first_names) > 0 then ','+c_first_names else ''
      end) from rd.contract,
      rd.contract_renewals,
      rd.contractor,
      rd.contractor_renewals,
      rd.outlet,
      rd.types_for_contract where
      contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no and
      contractor_renewals.contract_no = contract_renewals.contract_no and
      contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number and
      --Commented out 8/11/00, this stops the previous contract holder from being retrieved    
      --and(contract.con_active_sequence=contract_renewals.contract_seq_number)
      contract.contract_no = contract_renewals.contract_no and
      -- TJB SR4639 3/12/04 - Add contract number and type as potential selection criteria
      (@inContractNo is null or @inContractNo = 0 or(@inContractNo <> 0 and contract.contract_no = @inContractNo)) and
      (@inCtKey is null or @inCtKey = 0 or(@inCtKey <> 0 and types_for_contract.ct_key = @inCtKey)) and
      types_for_contract.contract_no = contract.contract_no and
      -- (end TJB added conditions)
      contractor.c_surname_company like @inOwnerDriver+'%' and
      con_base_office = outlet_id and
      -- SR#4478 PBY 18/01/03 Also testing for NULL
      -- and((region_id=inRegion and inRegion<>0) or (inRegion=0))
      ((region_id = @inRegion and @inRegion <> 0) or @inRegion is null or @inRegion = 0) and
      exists(select 1 from payment where
        payment.contract_no = contract.contract_no and
        invoice_date = @edate and
        payment.contractor_supplier_no = contractor.contractor_supplier_no)
  select distinct con_no,supply,detail from
    #con_temp order by
    con_no asc
end




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_RB_MailCategory : 
--

CREATE procedure [rd].[sp_DDDW_RB_MailCategory]
as
begin select mail_category.mc_key,mail_category.mc_description from mail_category union select-1,'<All>'  order by 2 asc end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure OD_DWS_OwnerDriver_Search_Region : 
--

CREATE procedure [odps].[OD_DWS_OwnerDriver_Search_Region](@inOwnerDriver varchar(40),@inRegion int,@sdate datetime,@edate datetime)
as
begin
  -- insert into temporary table
  create table #con_temp(
    con_no int null,
    supply int null,
    detail char(100) null,
    ) 
  insert into #con_temp(con_no,
    supply,detail)
    select 0,0,odcontracts='<All Contractors/Contracts>'
  insert into #con_temp(con_no,
    supply,detail)
    select contract.contract_no,
      contractor.contractor_supplier_no,
      c_surname_company + ISNULL(case when len(c_first_names) > 0 then ',' + c_first_names
      end,'') from rd.contract,
      rd.contract_renewals,
      rd.contractor,
      rd.contractor_renewals,
      rd.outlet where
      (contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no) and
      (contractor_renewals.contract_no = contract_renewals.contract_no) and
      (contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number) and
      --Commented out 8/11/00, this stops the previous contract holder from being retrieved    
      --and(contract.con_active_sequence=contract_renewals.contract_seq_number)
      (contract.contract_no = contract_renewals.contract_no) and
      (contractor.c_surname_company like @inOwnerDriver + '%') and
      (con_base_office = outlet_id) and
      -- SR#4478 PBY 18/01/03 Also testing for NULL
      -- and((region_id=inRegion and inRegion<>0) or(inRegion=0))
      ((region_id = @inRegion and @inRegion <> 0) or @inRegion is null or @inRegion = 0) and
      exists(select 1 from odps.payment  where payment.contract_no = contract.contract_no and invoice_date = @edate and
        payment.contractor_supplier_no = contractor.contractor_supplier_no)
  select distinct con_no,supply,detail from
    #con_temp order by
    con_no asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_rbcust : 
--

CREATE procedure [rd].[sp_DDDW_rbcust](@c int)
as
begin
  select cust_id from customer where cust_id in(@c)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_MiscF_GetFinYear : 
--

CREATE function [odps].[OD_MiscF_GetFinYear](@indate datetime,@intype char(1))
returns datetime
as
begin
  declare @v_fsdate datetime,
  @v_esdate datetime
  if month(@indate) > 3
    begin
      select @v_fsdate=convert(datetime,(convert(char,year(@indate))+'/04/01'))
      select @v_esdate=convert(datetime,(convert(char,year(@indate)+1)+'/03/31'))
    end
  else
    begin
      select @v_fsdate=convert(datetime,(convert(char,year(@indate)-1)+'/04/01'))
      select @v_esdate=convert(datetime,(convert(char,year(@indate))+'/03/31'))
    end
  if @intype = 'S'
    return(@v_fsdate)
  else
    return(@v_esdate)
 return (-1)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_rb_custlist](@region int,@outlet int,@mailcat int,@contract int,@d_monday char(1),@d_tuesday char(1),@d_wednesday char(1),@d_thursday char(1),@d_friday char(1),@d_saturday char(1),@d_sunday char(1),@d_freq int,@dirlist char(1),@newcust datetime,@transcust datetime,@leftcust datetime,@printrecipient char(1))
as
begin select distinct 
customer.contract_no,
customer.cust_title,
customer.cust_surname_company,
customer.cust_initials,
customer.cust_rd_number,
customer.cust_mailing_address_no,
customer.cust_mailing_address_road,
customer.cust_mailing_address_locality,
customer.cust_mail_town,
customer.cust_nad_reference,
customer.cust_phone_day,
customer.cust_phone_night,
customer.cust_dir_listing_text,
customer.cust_delivery_frequency,
customer.cust_delivery_days,
customer.cust_business,
customer.cust_rural_resident,
customer.cust_rural_farmer,
customer.cust_date_first_loaded,
customer.cust_date_last_transfered,
customer.cust_date_left,
customer.cust_id 
from contract,
customer,
customer_mail_category,
outlet 
where

(customer.cust_id = customer_mail_category.cust_id) 
and(@contract.contract_no = customer.contract_no) 
and(@outlet.outlet_id = @contract.con_base_office) 
and((@outlet.region_id = @REGION and @REGION <> -1) or(@REGION = -1)) 

and((@outlet.outlet_id = @OUTLET and @OUTLET <> -1) or(@OUTLET = -1)) 
and((customer_mail_category.mc_key = @MAILCAT and @MAILCAT <> -1) or(@MAILCAT = -1)) 
and((@contract.contract_no = @CONTRACT and @CONTRACT <> -1) or(@CONTRACT = -1)) 
and((LEFT(customer.cust_delivery_days,1) = @D_MONDAY or substring(customer.cust_delivery_days,2,1) = @D_TUESDAY or substring(customer.cust_delivery_days,3,1) = @D_WEDNESDAY or substring(customer.cust_delivery_days,4,1) = @D_THURSDAY or substring(customer.cust_delivery_days,5,1) = @D_FRIDAY or substring(customer.cust_delivery_days,6,1) = @D_SATURDAY or substring(customer.cust_delivery_days,7,1) = @D_SUNDAY or customer.cust_delivery_days is null)) 
and((customer.cust_dir_listing_ind = @DIRLIST)) 
and((customer.cust_delivery_frequency = @d_freq and @d_freq <> -1) or(@d_freq = -1)) and((customer.cust_date_first_loaded between @NEWCUST and rd.Today() and @NEWCUST is not null) or(@NEWCUST is null)) and((customer.cust_date_last_transfered between @TRANSCUST and rd.TODAY() and @TRANSCUST is not null) or(@TRANSCUST is null)) and((customer.cust_date_left between @LEFTCUST and rd.TODAY() and @LEFTCUST is not null) or(@LEFTCUST is null)) order by 3 asc end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for user-defined function OD_MiscF_Get_Invoicenumber : 
--

CREATE function [odps].[OD_MiscF_Get_Invoicenumber](@in_invnumber int,@inPayPeriod_End datetime)
returns char(30)
as
begin
  declare @v_cinvoicenumber char(30)
  select @v_cinvoicenumber = right(convert(varchar,year(@inPayPeriod_End)),2) + 
left(DATENAME ( month, @inPayPeriod_End),3) + 
right(REPLICATE ('0',10-len(convert(varchar,@in_invnumber))) + 
    convert(varchar,@in_invnumber),4) 
    
  return(@v_cinvoicenumber)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_rb_custlist_count : 
--

CREATE procedure [rd].[sp_rb_custlist_count](@region int,@outlet int,@mailcat int,@contract int,@d_monday char(1),@d_tuesday char(1),@d_wednesday char(1),@d_thursday char(1),@d_friday char(1),@d_saturday char(1),@d_sunday char(1),@d_freq int,@dirlist char(1),@newcust datetime,@transcust datetime,@leftcust datetime,@printrecipient char(1))
as
begin
  select count(distinct customer.cust_id) from
    contract,
    customer,
    customer_mail_category,
    outlet 
where(customer.cust_id = customer_mail_category.cust_id) 
and(@contract.contract_no = customer.contract_no) 
and(@outlet.outlet_id = @contract.con_base_office) 
and((@outlet.region_id = @REGION and @REGION <> -1) or(@REGION = -1)) 
and((@outlet.outlet_id = @OUTLET and @OUTLET <> -1) or(@OUTLET = -1)) 
and((customer_mail_category.mc_key = @MAILCAT and @MAILCAT <> -1) or(@MAILCAT = -1)) 
and((@contract.contract_no = @CONTRACT and @CONTRACT <> -1) or(@CONTRACT = -1)) 
and((LEFT(customer.cust_delivery_days,1) = @D_MONDAY or substring(customer.cust_delivery_days,2,1) = @D_TUESDAY or substring(customer.cust_delivery_days,3,1) = @D_WEDNESDAY or substring(customer.cust_delivery_days,4,1) = @D_THURSDAY or substring(customer.cust_delivery_days,5,1) = @D_FRIDAY or substring(customer.cust_delivery_days,6,1) = @D_SATURDAY or substring(customer.cust_delivery_days,7,1) = @D_SUNDAY or customer.cust_delivery_days is null)) and((customer.cust_dir_listing_ind = @DIRLIST) or(@dirlist is null)) and((customer.cust_delivery_frequency = @d_freq and @d_freq <> -1) or(@d_freq = -1)) and((customer.cust_date_first_loaded between @NEWCUST and rd.today() and @NEWCUST is not null) or(@NEWCUST is null)) and((customer.cust_date_last_transfered between @TRANSCUST and rd.today() and @TRANSCUST is not null) or(@TRANSCUST is null)) and((customer.cust_date_left between @LEFTCUST and rd.today() and @LEFTCUST is not null) or(@LEFTCUST is null)) end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for user-defined function OD_MiscF_GetFirstDayofMonth : 
--

CREATE function [odps].[OD_MiscF_GetFirstDayofMonth](@indate datetime)
returns datetime
as
begin
  declare @p_firstdayofmonth datetime
  select @p_firstdayofmonth = dateadd (day,1 - day(@indate),@indate) 
 
  return(@p_firstdayofmonth)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_DDLB_DeliveryDays : 
--

CREATE procedure [rd].[sp_DDLB_DeliveryDays]
as
begin select-1,'<All>' union select 0,'<None>' 
union select 1,'Once a week' 
union select 2,'Twice a week' 
union select 3,'Thrice a week' 
union select 4,'Four times a week' 
union select 5,'Five times a week' 
union select 6,'Six times a week' 
union select 7,'Seven times a week' 
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for user-defined function OD_MiscF_GetLastDayofMonth : 
--

CREATE function [odps].[OD_MiscF_GetLastDayofMonth](@indate datetime)
returns datetime
as
begin
  declare @p_temp datetime,
  @p_temp2 datetime
  select @p_temp = dateadd (day,28 - day(@indate),@indate)
 
  select @p_temp2 = DATEADD (day,1,@p_temp)
 
  if month(@p_temp) <> month(@p_temp2)
    return(dateadd(day, -1,@p_temp2))
  select @p_temp2 = dateadd(day,2,@p_temp) 
 
  if month(@p_temp) <> month(@p_temp2)
    return(dateadd(day,-1,@p_temp2))
  select @p_temp2 = dateadd(day,3,@p_temp) 
 
  if month(@p_temp) <> month(@p_temp2)
    return(dateadd(day,-1,@p_temp2))
  return(dateadd (day,31 - day(@indate),@indate))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_rb_custlist_count2 : 
--

CREATE procedure [rd].[sp_rb_custlist_count2](@region int,@outlet int,@mailcat int,@contract int,@dirlist char(1))
as
begin select count(distinct customer.cust_id) from contract,customer,customer_mail_category,mail_category,outlet where(customer.cust_id = customer_mail_category.cust_id) and(@contract.contract_no = customer.contract_no) and(mail_category.mc_key = customer_mail_category.mc_key) and(@outlet.outlet_id = @contract.con_base_office) and((@outlet.region_id = @REGION and @REGION <> -1) or(@REGION = -1)) and((@outlet.outlet_id = @OUTLET and @OUTLET <> -1) or(@OUTLET = -1)) and((mail_category.mc_key = @MAILCAT and @MAILCAT <> -1) or(@MAILCAT = -1)) and((@contract.contract_no = @CONTRACT and @CONTRACT <> -1) or(@CONTRACT = -1)) and((customer.cust_dir_listing_ind = @DIRLIST)) end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_rb_custlist_mailcat : 
--

CREATE procedure [rd].[sp_rb_custlist_mailcat](@cust int)
as
begin select mail_category.mc_description from customer_mail_category,mail_category where(mail_category.mc_key = customer_mail_category.mc_key) and((customer_mail_category.cust_id = @cust)) order by 1 asc end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_rb_randcustlist_to_randtable : 
--

CREATE procedure [rd].[sp_rb_randcustlist_to_randtable](@rowno int) as
begin insert into t_rand_customer select distinct custid from t_customer where rownum = @rowno end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_rb_randcustlist : 
--

CREATE procedure [rd].[sp_rb_randcustlist](@region int,@outlet int,@mailcat int,@contract int,@dirlist char(1)) as
begin insert into t_customer 
select row_number() over (order by customer.cust_id asc),customer.cust_id 
from contract,customer,customer_mail_category,mail_category,outlet 
where(customer.cust_id = customer_mail_category.cust_id) and(@contract.contract_no = customer.contract_no) and(mail_category.mc_key = customer_mail_category.mc_key) and(@outlet.outlet_id = @contract.con_base_office) and((@outlet.region_id = @REGION and @REGION <> -1) or(@REGION = -1)) and((@outlet.outlet_id = @OUTLET and @OUTLET <> -1) or(@OUTLET = -1)) and((mail_category.mc_key = @MAILCAT and @MAILCAT <> -1) or(@MAILCAT = -1)) and((@contract.contract_no = @CONTRACT and @CONTRACT <> -1) or(@CONTRACT = -1)) and((customer.cust_dir_listing_ind = @DIRLIST)) 
group by customer.cust_id 

end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_rb_recipients : 
--

CREATE procedure [rd].[sp_rb_recipients](@cust int,@printrecipient char(1))
as
begin
  select rd.trim(recipient.rc_surname_company) + ' ' + rd.trim(recipient.rc_first_names) from
    recipient where
    (recipient.cust_id = @cust) and
    (@printrecipient = 'Y') order by 1 asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContCustomers : 
--

--
-- Definition for stored procedure sp_GetContCustomers : 
--

CREATE procedure [rd].[sp_GetContCustomers](@in_Contract int)
as
begin
  select cust_id,
    cust_name=left(cust_surname_company + case when cust_initials is null then '' else ', ' + cust_initials end,63),
    customer_address=left(isnull(cust_mailing_address_no,'') +case when cust_mailing_address_road is null then '' else ' ' + cust_mailing_address_road end,55) from
    customer where
    contract_no = @in_Contract order by
    cust_name asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContCustomersv2 : 
--

--
-- Definition for stored procedure sp_GetContCustomersv2 : 
--

CREATE procedure [rd].[sp_GetContCustomersv2](@in_Contract int)
as
begin
  select cust_id,
    cust_name=left(cust_surname_company +case when cust_initials is null then '' else ', ' + cust_initials end,63),
    cust_property_identification,
    cust_mailing_address_no,
    cust_mailing_address_road from
    customer where
    contract_no = @in_Contract order by
    cust_name asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_CTS_AccountCodes : 
--

CREATE procedure [odps].[od_cts_accountcodes]
as
begin
  select Account_Codes.ac_id,
    Account_Codes.ac_code,
    Account_Codes.ac_description from
    odps.account_codes order by 2 asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_GetColDef] @inTabl CHAR(128) ,@inCreator CHAR(128) 

AS
begin
   select   '        '+cname+' '+coltype+CASE WHEN length IS NULL THEN '' ELSE '('+length+(case when sysleng = 0 then '' else ','+ sysleng
end)+')'
END+',' AS coldef from
   rd.syscolumns where
   tname = @inTabl and
   creator = @inCreator
end







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_v_exp_renew] @renew_id INT 

AS
begin
  
  -- table to hold end results and allow the filtering of results
  -- first create a temporary table for unique contract_vehicle
  -- temp table for max renewals
   declare @month_6 DATETIME
   declare @count_final INT
   --THE EVALUATION VERSION TRIMS COLUMN NAMES AND VARIABLES TO 7 CHARACTERS
--
CREATE TABLE #final_temp
   (
      reg_name CHAR(40)   null,
      expiry DATETIME   null,
      con_num INT   null,
      rego CHAR(8)   null,
      vmake CHAR(20)   null,
      vmodel CHAR(20)   null,
      vyear SMALLINT   null,
      vdesc CHAR(30)   null,
      vfuel CHAR(35)   null
   ) -- temp table for contract numbers
   --THE EVALUATION VERSION TRIMS COLUMN NAMES AND VARIABLES TO 7 CHARACTERS
--
CREATE TABLE #cv_temp
   (
      v_num INT   null,
      c_num INT   null,
      start_num INT   null,
      seq_no INT   null,
      dist_renew NUMERIC(10,2)   null
   ) -- temp table for the first seq number where this vehicle showed up
   --THE EVALUATION VERSION TRIMS COLUMN NAMES AND VARIABLES TO 7 CHARACTERS
--
CREATE TABLE #cr_temp
   (
      c_num INT   null,
      cd_num NUMERIC(10,2)   null
   )
   --THE EVALUATION VERSION TRIMS COLUMN NAMES AND VARIABLES TO 7 CHARACTERS
--
CREATE TABLE #con_temp
   (
      contract_no INT   null,
      active_seq INT   null
   )
   --THE EVALUATION VERSION TRIMS COLUMN NAMES AND VARIABLES TO 7 CHARACTERS
--
CREATE TABLE #veh_min_temp
   (
      contract_no INT   null,
      veh_seq INT   null
   ) -- populate the contract table
   insert into #con_temp(contract_no,active_seq)
   select distinct(con.contract_no),con.con_active_sequence from
   rd.contract_renewals as cr, rd.contract as con, rd.types_for_contract as tfc where(@renew_id is null or @renew_id = 0 or con.rg_code = @renew_id) and
   con.con_base_cont_type = 1 and
   tfc.ct_key = 1 and
   cr.con_expiry_date > GetDate()
   insert into #veh_min_temp(contract_no,veh_seq)
   select cv.contract_no,min(contract_seq_number) from
   rd.contract_vehical as cv,#con_temp as con where
   cv.contract_no = con.contract_no and
   cv.vehicle_number = rd.f_GetLatestConVehicle(cv.contract_no)
   group by cv.contract_no
   insert into #cv_temp(v_num,c_num,start_num,dist_renew)
   select distinct(cv.vehicle_number),cv.contract_no,min(cv.start_kms),max(cr.con_distance_at_renewal) from
   rd.contract_vehical as cv,rd.contract_renewals as cr,#con_temp as con,#veh_min_temp as vmt where
   con.contract_no = vmt.contract_no and
   cv.contract_no = con.contract_no and
   cv.contract_no = cr.contract_no and
   cv.contract_seq_number = vmt.veh_seq and
   cv.vehicle_number = rd.f_GetLatestConVehicle(cv.contract_no) and
   cr.contract_seq_number = vmt.veh_seq
   group by cv.vehicle_number,cv.contract_no,cv.start_kms,cr.con_distance_at_renewal
  -- set any milages over 200000 to limit of 200000
   update #cv_temp set start_num = 200000  where
   start_num > 200000

insert into #final_temp(expiry,con_num,rego,vmake,vmodel,vyear,vdesc,vfuel,reg_name) --values(getdate(),1, 'regon', 'vmake','vmodel',2,'vdesc','vfuel','reg_name')
select distinct(case when cv.start_num > 5000 and cv.start_num is not null then CONVERT(DATETIME,CONVERT(VARCHAR(10),dateadd(day,(((200000 -cv.start_num)/cv.dist_renew)*365),v.v_purchased_date),
      110)) else CONVERT(DATETIME,CONVERT(VARCHAR(10),dateadd(day,((200000/cv.dist_renew)*365),v.v_purchased_date),110))
end) as expiry 
,con.contract_no,v.v_vehicle_registration_number,
      v.v_vehicle_make,v.v_vehicle_model,v.v_vehicle_year
,vs.vs_description,ft.ft_description,reg.rgn_name 
from rd.vehicle as v left outer join rd.fuel_type as ft on v.vs_key=ft.ft_key  ,--join
 #con_temp as con
, --join 
rd.vehicle_style as vs ,--join
#cv_temp as cv  ,--join 
      rd.[contract] as cont join rd.outlet as outl on ( cont.con_base_office = outl.outlet_id ) join rd.region as reg on outl.region_id = reg.region_id
where  -- cr.c_num = con.contract_no   
   cv.c_num = con.contract_no and
   v.vehicle_number = cv.v_num and
   v.v_purchased_date is not null and
   vs.vs_key = v.vs_key and
   v.vs_key not in(3,8,12,16,15) and
   cont.contract_no = con.contract_no 
--order by 1 expiry asc  
order by 1 asc

  -- get the date 6 months ago
   set @month_6 = dateadd(month,6,GetDate())
  -- get rid of entries where the expiry is more than 6 months in the future
   delete from #final_temp where
   expiry > @month_6
  -- get count and put in message if there are no rows
   select   @count_final = count(*) 
   from #final_temp
   if @count_final = 0
   begin
      insert into #final_temp(vmodel)
      select '0 Vehicles'
   end

   select   max(expiry) AS expiry,con_num AS con_num,rego AS rego,vmake AS vmake,vmodel AS vmodel,
   vyear AS vyear,vdesc AS vdesc,vfuel AS vfuel,reg_name AS reg_name,
   @month_6 AS month_6 from -- dateformat(month_6, 'dd/mm/yyyy')
   #final_temp
   group by reg_name,con_num,rego,vmake,vmodel,vyear,vdesc,vfuel,expiry order by
   max(expiry) asc,con_num asc,rego asc
end






SET ANSI_NULLS ON





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[test_proc]  AS
BEGIN
/*   select   count(distinct rd.customer.cust_id) 
from rd.customer join rd.contract 
left outer join rd.customer_mail_category  --join rd.contract 
join rd.outlet on rd.contract.con_base_office = rd.outlet.outlet_id 
where rd.outlet.region_id = 6 and rd.outlet.outlet_id = 1532 
and rd.daysweek(rd.customer.cust_delivery_days) = 5
*/
return
END






GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[OD_CTS_PBUCodes]
as
begin
  select PBU_Code.PBU_Code,
    PBU_Code.PBU_Description,
    PBU_Code.PBU_ID from
    odps.pbu_code order by 1 asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_CTS_PBUCodes : 
--

CREATE procedure [odps].[OD_CTS_PBUCodes]
as
begin
  select PBU_Code.PBU_Code,
    PBU_Code.PBU_Description,
    PBU_Code.PBU_ID from
    odps.pbu_code order by 1 asc 
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetCustInfo : 
--

--
-- Definition for stored procedure sp_GetCustInfo : 
--

CREATE procedure [rd].[sp_GetCustInfo](@in_Customer int)
as
begin
  select customer.cust_id,
    customer.contract_no,
    customer.cust_title,
    customer.cust_surname_company,
    customer.cust_initials,
    customer.cust_rd_number,
    customer.cust_mailing_address_no,
    customer.cust_mailing_address_road,
    customer.cust_mailing_address_locality,
    customer.cust_mail_town,
    customer.cust_nad_reference,
    customer.cust_prior_customer,
    customer.cust_phone_day,
    customer.cust_phone_night,
    customer.cust_dir_listing_ind,
    customer.cust_dir_listing_text,
    customer.cust_delivery_frequency,
    customer.cust_delivery_days,
    customer.cust_business,
    customer.cust_rural_resident,
    customer.cust_rural_farmer,
    customer.cust_old_delivery_days,
    customer.cust_adpost_quantity,
    customer.cust_date_first_loaded,
    customer.cust_date_last_transfered,
    customer.cust_date_left from
    customer where
    customer.cust_id = @in_Customer
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE function [rd].[cl_mail_category](@icust_id int)
returns char(2000)
as
begin
  declare @sret char(2000),
  @stemp char(100)
  declare mail_cat cursor for select mail_category.mc_description from
      rd.customer_mail_category,
      rd.mail_category where
      (mail_category.mc_key = customer_mail_category.mc_key) and
      (customer_mail_category.cust_id = @icust_id) union
    select 'Business' from
      rd.customer where
      customer.cust_business = 'Y' and
      (customer.cust_id = @icust_id) union
    select 'Rural Residential' from
      rd.customer where
      customer.cust_rural_resident = 'Y' and
      (customer.cust_id = @icust_id) union
    select 'Rural Farmer' from
      rd.customer where
      customer.cust_rural_farmer = 'Y' and
      (customer.cust_id = @icust_id)
  open mail_cat
  /* Watcom only
  myloop:
  */while 1=1 
    begin
      fetch next from mail_cat into @stemp
      if @@fetch_status < 0 
        break
        /* Watcom only
        myloop
        */
      if Len(@sret) > 0
        select @sret=@sret + char(10) + char(13)
      select @sret=@sret + @stemp
    end
  close mail_cat
  return(@sret)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_GetCustInterestStat : 
--

--
-- Definition for stored procedure sp_GetCustInterestStat : 
--

CREATE procedure [rd].[sp_GetCustInterestStat](@inregion int)
as
begin
  select region=region.rgn_name,
    interest=interest.interest_description,
    interestcount=(select count(customer.cust_id) from
      contract,
      customer,
      outlet,
      customer_interest where
      (customer.contract_no = contract.contract_no) and
      (contract.con_base_office = outlet.outlet_id) and
      (outlet.region_id = region.region_id) and
      (customer_interest.cust_id = customer.cust_id) and
      (customer_interest.interest_id = interest.interest_id)) from
    interest,
    region where
    (region.region_id = @inregion or @inregion is null) order by
    region.rgn_name asc,
    interest.interest_description asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE function [rd].[cl_receipients](@icust_id int)
returns char(2000)
as
begin
  declare @sret char(2000),
  @stemp1 char(100),
  @stemp2 char(100)
  declare mail_recp /*dynamic scroll mkwang_msd*/ cursor for select recipient.rc_surname_company,
      recipient.rc_first_names from
      rd.recipient where
      (recipient.cust_id = @icust_id)
 open mail_recp
  /* Watcom only
  myloop:
 while 1=1 
    begin */
      fetch next FROM mail_recp into @stemp1,@stemp2
      while @@fetch_status = 0
      begin
        /*break*/
        /* Watcom only
        myloop
        */
      if len(@sret) > 0
        select @sret=@sret + CHAR(10) + CHAR(13)
      select @sret=@sret + @stemp1 + case when isnull(@stemp2,'') = '' THEN '' ELSE ', ' END  + @stemp2   
      fetch next FROM mail_recp into @stemp1,@stemp2
    end
  close mail_recp
  return(@sret)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_GetCustMailCat](@in_Cust_Id int)
as
begin
  select customer_mail_category.cust_id,
    customer_mail_category.mc_key from
    customer_mail_category where
    customer_mail_category.cust_id = @in_cust_id
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure cust_survey : 
--

CREATE procedure [rd].[cust_survey]
as
begin
  select surname_or_company=cust_surname_company,
    first_name=cust_initials,
    title=cust_title,
    street_or_road_number=cust_mailing_address_no,
    road_name=cust_mailing_address_road,
    area_locality=cust_mailing_address_locality,RD_number='RD ' + 
    cust_rd_number,
    town_or_city=cust_mail_town,
    contact_phone_day=cust_phone_day,
    contact_phone_night=cust_phone_night,
    cust_id,
    contractor=(select c_survey_name from
      contractor,contractor_renewals,contract as c where
      contractor.contractor_supplier_no = 
      contractor_renewals.contractor_supplier_no and
      contractor_renewals.contract_no = customer.contract_no and
      contractor_renewals.contract_no = c.contract_no and
      contractor_renewals.contract_seq_number = c.con_active_sequence and
      contractor_renewals.cr_effective_date = 
      (select max(cr2.cr_effective_date) from
        contractor_renewals as cr2 where
        cr2.contract_no = contractor_renewals.contract_no and
        cr2.contract_seq_number = contractor_renewals.contract_seq_number)) from
    customer where
    contract_no > 0
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetCustomer : 
--

--
-- Definition for stored procedure sp_GetCustomer : 
--

CREATE procedure [rd].[sp_GetCustomer](@in_Customer int)
as
begin
  select customer.cust_id,
    customer.contract_no,
    customer.cust_title,
    customer.cust_surname_company,
    customer.cust_initials,
    customer.cust_rd_number,
    customer.cust_mailing_address_no,
    customer.cust_mailing_address_road,
    customer.cust_mailing_address_locality,
    customer.cust_mail_town,
    customer.cust_nad_reference,
    customer.cust_prior_customer,
    customer.cust_phone_day,
    customer.cust_phone_night,
    customer.cust_dir_listing_ind,
    customer.cust_dir_listing_text,
    customer.cust_delivery_frequency,
    customer.cust_delivery_days,
    customer.cust_business,
    customer.cust_rural_resident,
    customer.cust_rural_farmer,
    customer.cust_old_delivery_days,
    customer.cust_adpost_quantity,
    customer.cust_date_first_loaded,
    customer.cust_date_last_transfered,
    customer.cust_date_left,
    cust_date_commenced from
    customer where
    customer.cust_id = @in_Customer
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetCustOccupationStat : 
--

--
-- Definition for stored procedure sp_GetCustOccupationStat : 
--

CREATE procedure [rd].[sp_GetCustOccupationStat](@inregion int)
as
begin
  select region=region.rgn_name,
    occupation=occupation.occupation_description,
    occupationcount=(select count(customer.cust_id) from
      contract,
      customer,
      outlet,
      customer_occupation where
      (customer.contract_no = contract.contract_no) and
      (contract.con_base_office = outlet.outlet_id) and
      (outlet.region_id = region.region_id) and
      (customer_occupation.cust_id = customer.cust_id) and
      (customer_occupation.occupation_id = occupation.occupation_id)) from
    occupation,
    region where
    (region.region_id = @inregion or @inregion = 0) order by
    region.rgn_name asc,
    occupation.occupation_description asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetCustomer32 : 
--

--
-- Definition for stored procedure sp_GetCustomer32 : 
--

CREATE procedure [rd].[sp_GetCustomer32](@in_Customer int)
as
begin
  select customer.cust_id,
    customer.contract_no,
    customer.cust_title,
    customer.cust_surname_company,
    customer.cust_initials,
    customer.cust_rd_number,
    customer.cust_mailing_address_no,
    customer.cust_mailing_address_road,
    customer.cust_mailing_address_locality,
    customer.cust_mail_town,
    customer.cust_nad_reference,
    customer.cust_prior_customer,
    customer.cust_phone_day,
    customer.cust_phone_night,
    customer.cust_phone_mobile,
    customer.cust_dir_listing_ind,
    customer.cust_dir_listing_text,
    customer.cust_delivery_frequency,
    customer.cust_delivery_days,
    customer.cust_business,
    customer.cust_rural_resident,
    customer.cust_rural_farmer,
    customer.cust_old_delivery_days,
    customer.cust_adpost_quantity,
    customer.cust_date_first_loaded,
    customer.cust_date_last_transfered,
    customer.cust_date_left,
    cust_date_commenced,'','','',
    customer.cust_property_identification,
    customer.cust_post_code,
    customer.cust_category,
    post_code.post_code from
    rd.customer,rd.post_code where
    customer.cust_id = @in_Customer and
    --used to get the post code    
    post_code.post_mail_town = customer.cust_mail_town
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_GetCustomer2](@in_Customer int)
as
begin
  select customer.cust_id,
    customer.contract_no,
    customer.cust_title,
    customer.cust_surname_company,
    customer.cust_initials,
    customer.cust_rd_number,
    customer.cust_mailing_address_no,
    customer.cust_mailing_address_road,
    customer.cust_mailing_address_locality,
    customer.cust_mail_town,
    customer.cust_nad_reference,
    customer.cust_prior_customer,
    customer.cust_phone_day,
    customer.cust_phone_night,
    customer.cust_dir_listing_ind,
    customer.cust_dir_listing_text,
    customer.cust_delivery_frequency,
    customer.cust_delivery_days,
    customer.cust_business,
    customer.cust_rural_resident,
    customer.cust_rural_farmer,
    customer.cust_old_delivery_days,
    customer.cust_adpost_quantity,
    customer.cust_date_first_loaded,
    customer.cust_date_last_transfered,
    customer.cust_date_left,
    customer.cust_date_commenced from
    customer where
    customer.cust_id = @in_Customer
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function daysweek : 
--

CREATE function [rd].[daysweek](@inDelDays char(7))
returns int
as
begin
  declare @iLoop int,
  @iCount int
  select @iCount=0
  select @iLoop=1
  /* Watcom only
  CounterLoop:
  */while
  @iLoop <= 7
    begin
      if substring(@inDelDays,@iLoop,1) = 'Y'
        select @iCount=@iCount+1
      select @iLoop=@iLoop+1
    end
  return @iCount
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_GetCustomerNoCommencement](@in_Region int,@in_Days int)
as
begin
  select customer.contract_no,
    customer.cust_title,
    customer.cust_surname_company,
    customer.cust_initials,
    customer.cust_date_first_loaded,
    contractor.c_surname_company,
    contractor.c_initials,
    contractor.c_phone_day from
    customer,
    contract_renewals,
    contractor,
    contractor_renewals,
    contract,
    outlet where
    (contract.con_base_office = outlet.outlet_id) and
    ((outlet.region_id = @in_region and @in_region is not null) or(@in_region is null)) and
    (customer.contract_no = contract_renewals.contract_no) and
    (contract.contract_no = contract_renewals.contract_no) and
    (contract.con_active_sequence = contract_renewals.contract_seq_number) and
    (contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number) and
    (contractor.contractor_supplier_no = contractor_renewals.contractor_supplier_no) and
    (contract_renewals.contract_no = contractor_renewals.contract_no) and
    (contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number) and
    (contract.contract_no = contract_renewals.contract_no) and
    (contract.contract_no = customer.contract_no) and
    (contractor_renewaLs.cr_effective_date = (select max(cr_effective_date) from
      contractor_renewals as cr where
      cr.contract_no = contract.contract_no and
      cr.contract_seq_number = contract_renewals.contract_seq_number)) and
    ((customer.cust_date_commenced is null and datediff(day,customer.cust_date_first_loaded,getdate()) >= @in_days))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_custlist_count : 
--

CREATE function [rd].[f_custlist_count](@region int,@outlet int,@mailcat int,@contract int,@d_monday char(1),@d_tuesday char(1),@d_wednesday char(1),@d_thursday char(1),@d_friday char(1),@d_saturday char(1),@d_sunday char(1),@d_freq int,@dirlist char(1),@newcust datetime,@transcust datetime,@leftcust datetime)
returns int
as
begin
  declare @cnt int
  select @cnt=count(distinct customer.cust_id) 
    from contract,
    customer left outer join customer_mail_category on customer.cust_id = customer_mail_category.cust_id ,
    mail_category,
    outlet where
    (customer.cust_id = customer_mail_category.cust_id) and
    (@contract.contract_no = customer.contract_no) and
    (mail_category.mc_key = customer_mail_category.mc_key) and
    (@outlet.outlet_id = @contract.con_base_office) and
    ((@outlet.region_id = @REGION and
    @REGION <> -1) or
    (@REGION = -1)) and
    ((@outlet.outlet_id = @OUTLET and
    @OUTLET <> -1) or
    (@OUTLET = -1)) and
    ((mail_category.mc_key = @MAILCAT and
    @MAILCAT <> -1) or
    (@MAILCAT = -1)) and
    ((@contract.contract_no = @CONTRACT and
    @CONTRACT <> -1) or
    (@CONTRACT = -1)) and
    ((LEFT(customer.cust_delivery_days,1) = @D_MONDAY or
    substring(customer.cust_delivery_days,2,1) = @D_TUESDAY or
    substring(customer.cust_delivery_days,3,1) = @D_WEDNESDAY or
    substring(customer.cust_delivery_days,4,1) = @D_THURSDAY or
    substring(customer.cust_delivery_days,5,1) = @D_FRIDAY or
    substring(customer.cust_delivery_days,6,1) = @D_SATURDAY or
    substring(customer.cust_delivery_days,7,1) = @D_SUNDAY)) and
    ((customer.cust_dir_listing_ind = @DIRLIST)) and
    ((customer.cust_delivery_frequency = @d_freq and
    @d_freq <> -1) or
    (@d_freq = -1)) and
    ((customer.cust_date_first_loaded = @NEWCUST and
    @NEWCUST is not null) or
    (@NEWCUST is null)) and
    ((customer.cust_date_last_transfered = @TRANSCUST and
    @TRANSCUST is not null) or
    (@TRANSCUST is null)) and
    ((customer.cust_date_left = @LEFTCUST and
    @LEFTCUST is not null) or
    (@LEFTCUST is null))
  return @cnt
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetCustomerCountCount : 
--

CREATE function [rd].[f_GetCustomerCountCount](@in_Contract int,@in_Type char(1))
returns int
as
begin
  declare @iCount int
  select @iCount=sum(cust_adpost_quantity) 
    from customer where
    customer.contract_no = @in_Contract and
    cust_category = 'RR' and
    @in_Type = 'R'
  if @iCount > 0
    return @iCount
  select @iCount=sum(cust_adpost_quantity) 
    from customer where
    customer.contract_no = @in_Contract and
    cust_category = 'BS' and
    @in_Type = 'B'
  if @iCount > 0
    return @iCount
  select @iCount=sum(cust_adpost_quantity) 
    from customer where
    customer.contract_no = @in_Contract and
    cust_category = 'RF' and
    @in_Type = 'F'
  if @iCount > 0
    return @iCount
  select @iCount=count(cust_id) 
    from customer where
    customer.contract_no = @in_Contract and
    (cust_adpost_quantity is null or cust_adpost_quantity = 0) and
    @in_Type = 'X'
  if @iCount > 0
    return @iCount
return @iCount
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure v_expPercent : 
--

CREATE procedure [rd].[v_expPercent_delete](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
as -- TJB  SR4658  9-Apr-2005 Bug fix
begin
  declare @i_exp_num real,
  @i_total real,
  @d_percentage real,
  @month_6 datetime,
  @count_final int
  -- table to hold end results and allow the filtering of results
  create table #final_temp(
    reg_name char(40) null,
    expiry datetime null,
    con_num int null,
    rego char(8) null,
    vmake char(20) null,
    vmodel char(20) null,
    vyear smallint null,
    ) 
create table #cv_temp(
    v_num int null,
    c_num int null,
    start_num int null,
    seq_no int null,
    dist_renew numeric(10,2) null,
    ) 
create table #cr_temp(
    c_num int null,
    cd_num numeric(10,2) null,
    ) 
create table #con_temp(
    contract_no int null,
    active_seq int null,
    )
-- MRB 12/3/2007 - added in active_seq to returned list
  insert into #con_temp(contract_no,active_seq)
    select distinct(con.contract_no),con.con_active_sequence from
      towncity as tc join address as addr on tc.tc_id = addr.tc_id join contract as con on addr.contract_no = con.contract_no join contract_renewals as cr on con.contract_no = cr.contract_no where
      (@inRegion = 0 or @inRegion is null or tc.region_id = @inRegion) and
      (@inOutlet = 0 or @inOutlet is null or con.con_lodgement_office = @inOutlet) and
      (@inContractType = 0 or @inContractType is null or con.con_base_cont_type = @inContractType) and
      (@inRenGroup = 0 or @inRenGroup is null or con.rg_code = @inRenGroup) and
      cr.con_expiry_date > rd.today()
  -- populate the contract_vehicle temp with the lastest vehicles 
  -- where vehicle newer than contract start date
  insert into #cv_temp(v_num,c_num,start_num,seq_no,dist_renew)
    select distinct(cv.vehicle_number),
      cv.contract_no,
      max(cv.start_kms),
      max(cv.contract_seq_number),
      max(cr.con_distance_at_renewal) from
      contract_vehical as cv join vehicle as veh on cv.vehicle_number = veh.vehicle_number,
      #con_temp as temp,
      contract_renewals as cr where
      cv.contract_no = temp.contract_no and
      -- TJB  SR4658  9-Apr-2005
      -- Bug fix: removed following line.
      -- con_temp.active_seq is never populated so this condition is never true!
      -- MRB 12/3/2007 - added line back in as list was not returning the correct vehicle details
      -- and commented out filter for null start_kms as this was excluding valid vehicles.
      cv.contract_seq_number = temp.active_seq and
      --       and cv.start_kms is not null
      cr.contract_no = cv.contract_no and
      cr.contract_seq_number = cv.contract_seq_number and
      cr.con_distance_at_renewal is not null and
      veh.v_purchased_date >= cr.con_start_date and
      veh.v_purchased_date = (select max(veh1.v_purchased_date) from
        contract_vehical as cv2 join vehicle as veh1 on cv2.vehicle_number = veh1.vehicle_number where
        cv2.contract_no = cv.contract_no
        group by cv2.contract_no)
      group by cv.contract_no,cv.vehicle_number,cv.start_kms,cv.contract_seq_number,cr.con_distance_at_renewal
  -- populate the contract_vehicle temp with latest vehicles - where vehicles older than contract start
  insert into #cv_temp(v_num,c_num,start_num,seq_no,dist_renew)
    select distinct(cv.vehicle_number),
      cv.contract_no,
      cv.start_kms,
      cv.contract_seq_number,
      cr.con_distance_at_renewal from
      contract_vehical as cv join vehicle as veh on cv.vehicle_number = veh.vehicle_number,
      #con_temp as temp,
      contract_renewals as cr where
      cv.contract_no = temp.contract_no and
      not cv.contract_no = any(select c_num from #cv_temp) and
      not cv.vehicle_number = any(select v_num from #cv_temp) and
/*!      cv.start_kms is not null and
      cv.start_kms = (select min(cv1.start_kms) from
        contract_vehical as cv1 where
        cv1.contract_no = cv.contract_no) and  */
      --MRB 12/3/2007 - remove start_kms filters as these were excluding valid vehicles
      --       and cv.start_kms is not null
      --       and cv.start_kms = (select min(cv1.start_kms) 
      --                             from contract_vehical cv1 
      --                            where cv1.contract_no = cv.contract_no)

      cr.contract_seq_number = cv.contract_seq_number and
      cv.contract_seq_number = temp.active_seq and
      cr.contract_no = cv.contract_no and
      cr.con_distance_at_renewal is not null and
      veh.v_purchased_date < cr.con_start_date and
      veh.v_purchased_date = (select max(veh1.v_purchased_date) from
        contract_vehical as cv2 join vehicle as veh1 on cv2.vehicle_number = veh1.vehicle_number where
        cv2.contract_no = cv.contract_no
        group by cv2.contract_no)
      group by cv.contract_no,cv.vehicle_number,cv.start_kms,cv.contract_seq_number,cr.con_distance_at_renewal
  -- set any milages over 200000 to limit of 200000
  update #cv_temp set
    start_num = 200000 where
    start_num > 200000
  -- set any null mileages to 0
  update #cv_temp set
    start_num = 0 where
    start_num is null;

  insert into #final_temp(expiry,con_num,rego,vmake,vmodel,vyear)
    select distinct expiry=(case when cv.start_num > 5000 and cv.start_num is not null then
        rd.date(dateadd(day,(((200000-cv.start_num)/cv.dist_renew)*365),v.v_purchased_date))
      else rd.date(dateadd(day,((200000/cv.dist_renew)*365),v.v_purchased_date))
      end),
      con.contract_no,
      v.v_vehicle_registration_number,
      v.v_vehicle_make,
      v.v_vehicle_model,
      v.v_vehicle_year from
      vehicle as v,
      #con_temp as con,
      #cv_temp as cv where
      -- cr.c_num = con.contract_no   
      cv.c_num = con.contract_no and
      v.vehicle_number = cv.v_num and
      v.v_purchased_date is not null and
      -- exclude styles : boat, bus, minibus, motorcycle, trucks
      v.vs_key not in(3,8,12,16,15)
  -- see how many are to expire before today
  select @i_exp_num = count(*) 
    from #final_temp as ft where
    ft.expiry > rd.today()
  -- get the total
  select @i_total = count(*)
    from #final_temp
  if @i_total <> 0
    begin
      select @d_percentage=(@i_exp_num/@i_total)*100
      select @d_percentage=round(@d_percentage,2)
    end
  else
    select @d_percentage=0
  return @d_percentage
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_GetRecipient : 
--

CREATE procedure [rd].[sp_GetRecipient](
@in_cust_id int)
as
begin
  select recipient.cust_id,
    recipient.recipient_id,
    recipient.rc_surname_company,
    recipient.rc_first_names from
    recipient where
    recipient.cust_id = @in_cust_id
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure pGetNumCusts : 
--

CREATE procedure [rd].[pGetNumCusts](@inRegion decimal(12,2),@numCusts decimal(7) output) as
begin
  select @numCusts = count(*) 
    from customer as cust,
    contract as con,
    outlet as "out" where
    cust.contract_no <> 0 and
    cust.contract_no = con.contract_no and
    con.con_lodgement_office = "out".outlet_id and
    ("out".region_id = @inRegion or
    @inRegion = 0)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function Date : 
--

CREATE function [rd].[strcat] (@input1 varchar(4000),@input2 varchar(4000))

RETURNS varchar(8000)
AS
BEGIN
 declare  @return varchar(8000)
  select @return=@input1+@input2
	return @return
END








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function today : 
--

CREATE function [rd].[today] (
)
RETURNS datetime
AS
BEGIN
  declare @nowdate datetime
  declare @returndate datetime
  select @nowdate=getdate()
  select @returndate= DATEADD(hour, -1*datepart(hour,@nowdate), @nowdate)
  select @returndate= DATEADD(minute, -1*datepart(minute,@nowdate), @returndate)
  select @returndate= DATEADD(second, -1*datepart(second,@nowdate), @returndate)
	select @returndate= DATEADD(millisecond, -1*datepart(millisecond,@nowdate), @returndate)
  
  return @returndate
END










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function trim : 
--

CREATE function [rd].[trim] (@input varchar(8000)
)
RETURNS varchar(8000)
AS
BEGIN
   declare @returnvalue varchar(8000)
   select @returnvalue=ltrim(rtrim(@input))
   return @returnvalue
END










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function YMD : 
--

CREATE function [rd].[YMD] (@year int,@month int,@day int
)
RETURNS datetime
AS
BEGIN
  declare @returndate datetime
	declare @datestring varchar(100)
  select @datestring=convert(varchar,@month) + '-' + convert(varchar,@day) + '-' + convert(varchar,@year)
  select @returndate=convert(datetime,@datestring,110)
  return @returndate
END










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function Date : 
--

CREATE function [rd].[Date] (@inputDate Datetime
)
RETURNS datetime
AS
BEGIN
  declare @returndate datetime
   select @returndate= DATEADD(hour, -1*datepart(hour,@inputDate), @inputDate)
  select @returndate= DATEADD(minute, -1*datepart(minute,@returndate), @returndate)
  select @returndate= DATEADD(second, -1*datepart(second,@returndate), @returndate)
	select @returndate= DATEADD(millisecond, -1*datepart(millisecond,@returndate), @returndate)
    return @returndate
END










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[fix_address]
as
begin
  declare @v_cust int,
  @v_road char(45),
  @v_no char(45),
  @v_1char char(1),
  @v_ctr int
  declare c1 cursor for select custid from t_rand_customer
  insert into t_rand_customer
    select cust_id from rd.customer where
      (cust_mailing_address_no is null or len(cust_mailing_address_no) = 0) and
      ascii(left(cust_mailing_address_road,1)) between 48 and 57
  if @@error <> 0 /* <> was < */ RAISERROR('',10,1)
    /* Watcom only
    resignal
    */
  open c1
  /* Watcom only
  fixloop:
  */while 1=1 
    begin
      fetch next from c1 into @v_cust
      if @@fetch_status <0
        break
        /* Watcom only
        fixloop
        */
      if @@error <> 0 RAISERROR('',10,1)
        /* Watcom only
        resignal
        */
      select @v_road = cust_mailing_address_road from rd.customer where cust_id = @v_cust
      if @@error <> 0 /* <> was < */ RAISERROR('',10,1)
        /* Watcom only
        resignal
        */
      select @v_ctr=0
      select @v_no=''
      select @v_ctr=0
      while @v_ctr < 9
        begin
          select @v_ctr=@v_ctr+1
          select @v_1char=substring(@v_road,@v_ctr,1)
          if ascii(@v_1char) between 48 and 57
            select @v_no=@v_no + @v_1char else
          if ascii(@v_1char) <> 32
            begin
              select @v_no=''
              select @v_ctr=99
            end
        end
      if len(@v_no) > 0
        update rd.customer set cust_mailing_address_no = @v_no,
          cust_mailing_address_road = right(rd.cust_mailing_address_road, case when len(rd.trim(cust_mailing_address_road))-len(@v_no) >=0 then len(rd.trim(cust_mailing_address_road))-len(@v_no) else 0 end  ) where
          cust_id = @v_cust
      if @@error <> 0 /* <> was < */ RAISERROR('',10,1)
        /* Watcom only
        resignal
        */
    end
  close c1
  if @@error <> 0 /* <> was < */ RAISERROR('',10,1)
    /* Watcom only
    resignal
    */
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
		RAISERROR('',10,1)
      /* Watcom only
      resignal
      */
    end
  commit transaction
  return(0)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function func_daves : 
--

CREATE function [rd].[func_daves]()
returns int
begin
  return(1)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function rexmail_category : 
--

CREATE function [rd].[rexmail_category](@icust_id int)
returns char(2000)
as
begin
  declare @sret char(2000),
  @stemp char(100)
  declare mail_cat cursor for select mail_category.mc_description from
      rd.customer_mail_category,
      rd.mail_category where
      (mail_category.mc_key = customer_mail_category.mc_key) and
      (customer_mail_category.cust_id = @icust_id) union
    select 'Business' from
      rd.customer where
      customer.cust_business = 'Y' and
      (customer.cust_id = @icust_id) union
    select 'Rural Residential' from
      rd.customer where
      customer.cust_rural_resident = 'Y' and
      (customer.cust_id = @icust_id) union
    select 'Rural Farmer' from
      rd.customer where
      customer.cust_rural_farmer = 'Y' and
      (customer.cust_id = @icust_id)
   open mail_cat
  /* Watcom only
  myloop:
  */while 1=1 
    begin
      fetch next from mail_cat into @stemp
      if @@FETCH_STATUS <0 
        break
        /* Watcom only
        myloop
        */
      if len(@sret) > 0
        select @sret=@sret + char(10) + char(13)
      select @sret=@sret + @stemp
    end
  close mail_cat
  return(@sret)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function get_number_delivery_days : 
--

--
-- Definition for user-defined function get_number_delivery_days : 
--

CREATE function [rd].[get_number_delivery_days](@pcust_id int)
returns int 
as
begin
  declare @ccust_delivery_days char(7),
  @temp int
  select @ccust_delivery_days=customer.cust_delivery_days from customer where customer.cust_id = @pcust_id
  select @temp
    =case substring(@ccust_delivery_days,1,1) when 'y' then 1 else 0 end +
    case substring(@ccust_delivery_days,2,1) when  'y' then 1 else 0 end+
    case substring(@ccust_delivery_days,3,1) when  'y' then 1 else 0 end+
    case substring(@ccust_delivery_days,4,1) when 'y' then 1 else 0 end+
    case substring(@ccust_delivery_days,5,1) when 'y' then 1 else 0 end+
    case substring(@ccust_delivery_days,6,1) when 'y' then 1 else 0 end

  return @temp
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_GetRoads_con](@contract_id int)
-- TJB  Sept 2005  NPAD2 address schema changes
as -- Added road_suffix to relevant parts of addresses returned
begin
  create table #road_ids(
    rd_id integer null,
    )
  create table #del_counts(
    rd_id integer null,
    del_count integer null,
    ) insert into #road_ids(rd_id)
    select distinct addr.road_id from
      address as addr where
      addr.contract_no = @contract_id
  insert into #del_counts(rd_id,del_count)
    select distinct(addr.road_id),
      count(addr.adr_id) from
      address as addr,
      #road_ids as rdi where
      addr.road_id = rdi.rd_id and
      addr.contract_no = @contract_id
      group by addr.road_id
  --  select distinct(rd.Road_name + ' ' +  rt.rt_name), 
  select distinct(rd.road_name+case when rt.rt_name is null then null else ' '+rt.rt_name end + case when rs.rs_name is null then null else ' '+rs.rs_name end),
    addr.adr_rd_no,
    tc.tc_name,
    dc.del_count from
/*!
    address as addr join TownCity as tc on addr.tc_id=tc.tc_id,
    address as addr2 join road as rd on addr2.road_id=rd.road_id,
    road as rd2 left outer join road_type as rt on rd2.rt_id=rt.rt_id,
    road as rd3 left outer join road_suffix as rs on rd3.rs_id=rs.rs_id,
*/
    address as addr join TownCity as tc on addr.tc_id=tc.tc_id
	 join road as rd on addr.road_id=rd.road_id
	left outer join road_type as rt on rd.rt_id=rt.rt_id
	 left outer join road_suffix as rs on rd.rs_id=rs.rs_id,
    #del_counts as dc where
    addr.contract_no = @contract_id and
    --and addr.road_id = rd.road_id
    addr.road_id = dc.rd_id
    group by(rd.road_name+case when rt.rt_name is null then null else ' '+rt.rt_name end+ case when rs.rs_name is null then null else ' '+rs.rs_name end),    addr.adr_rd_no,
    tc.tc_name,
    dc.del_count order by
    (rd.road_name+case when  rt.rt_name is null then null else ' '+rt.rt_name end+ case when rs.rs_name is null then null else ' '+rs.rs_name end) asc
end




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_MiscF_ParseIRDNo : 
--

CREATE function [odps].[OD_MiscF_ParseIRDNo](@inIRD char(20))
returns char(10)
as
begin
  declare @v_IRDNo varchar(10),
  @vt_IRDNo varchar(8)
  select @vt_IRDNo=left(@inIRD,8)
  if len(@vt_IRDNo) < 4
    return(@vt_IRDNo)
  select @v_IRDNo=left(@vt_IRDNo,3) + '-'
  select @vt_IRDNo=right(@vt_IRDNo,len(@vt_IRDNo)-3)
  if len(@vt_IRDNo) < 4
    return(@v_IRDNo + @vt_IRDNo)
  select @v_IRDNo=@v_IRDNo + left(@vt_IRDNo,3) + '-' + right(@vt_IRDNo,len(@vt_IRDNo)-3)
  return(@v_IRDNo)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




--
-- Definition for stored procedure get_redundant : 
--

CREATE procedure -- This is a temporary procedure to find redundant town_road rows
[rd].[get_redundant]
as
begin
  create table #distinct_entry(
    tc_id integer null,
    rd_id integer null,
    )
create table #dist_string(
    pairing char(40) null,
    ) 
create table #tc_rd_string(
    pairing char(40) null,
    )
  -- get the distinct town and road pairings
  insert into #distinct_entry(tc_id,
    rd_id)
    select distinct tc_id,road_id from
      address
  -- build distinct strings
  insert into #dist_string(pairing)
    select convert(varchar,tc_id)+' '+convert(varchar,rd_id) from
      #distinct_entry
  -- put entries from town_road into temp table
  insert into #tc_rd_string(pairing)
    select convert(varchar,tc_id)+' '+convert(varchar,road_id) from
      town_road
  select pairing from
    #tc_rd_string where
    not pairing = any(select pairing from #dist_string)
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_Invoice_message : 
--

CREATE procedure [odps].[OD_RPS_Invoice_message](@in_message char(1000))
as
begin
  select out_message=@in_message
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
 

--
-- Definition for stored procedure sp_GetRoads_town : 
--
 
CREATE procedure [rd].[sp_GetRoads_town](@town_id int)
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added road_suffix to relevant parts of addresses returned
-- TJB  OCT 2005
as -- Added RD no to temp tables so count is by road+rd_no
begin
 create table #road_ids(
    rd_id integer null,
    rd_no integer null,
    )
create table #del_counts(
    rd_id integer null,
    rd_no integer null,
    del_count integer null,
    ) 
insert into #road_ids(rd_id,rd_no)
    select distinct road_id,adr_rd_no from
      address where
      tc_id = @town_id
  insert into #del_counts(rd_id,rd_no,del_count)
    select distinct(addr.road_id),
      addr.adr_rd_no,
      count(addr.adr_id) from
      address as addr,
      #road_ids as rdi where
      addr.road_id = rdi.rd_id and
      addr.adr_rd_no = rdi.rd_no and
      addr.tc_id = @town_id
      group by addr.road_id,addr.adr_rd_no
  --  select distinct(rd.Road_name + ' ' +  rt.rt_name), 
  select road_name=rd.road_name+
    case when rt.rt_name is null then null else ' '+rt.rt_name end+
    case when rs.rs_name is null then null else ' '+rs.rs_name end,
    dc.rd_no,
    tc.tc_name,
    dc.del_count from
    #del_counts as dc,
    road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
    road_suffix as rs on rd.rs_id=rs.rs_id,
    towncity as tc where
    rd.road_id = dc.rd_id and
    tc.tc_id = @town_id
    --and addr.road_id = rd.road_id
    -- NOTE: the 'road_name' here is the alias for the road_name+road_type+road_suffix in the select part
    --       Also: this "group by" is probably redundant.
    group by road_name,
    dc.rd_no,
    tc.tc_name,
    dc.del_count,
 rt.rt_name,
 rs.rs_name
 order by
    road_name asc,dc.rd_no asc
end
 





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRoads_intranet : 
--

CREATE procedure [rd].[sp_GetRoads_intranet]
-- MRB Aug 2006 Used to generate export file for populating
-- Rural Post Intranet Road Serach tables.
as -- Called from outside RDS application (i.e. iSQL)
begin
  create table #road_ids(
    rd_id integer null,
    rd_no char(3) null,
    ) 
create table #del_counts(
    rd_id integer null,
    rd_no char(3) null,
    tc_id integer null,
    contract_no integer null,
    del_count integer null,
    ) 
  create table #road_nos(
    rd_id integer null,
    rd_no char(3) null,
    tc_id integer null,
    min_no char(10) null,
    max_no char(10) null,
    ) 
insert into #road_ids(rd_id,rd_no)
    select distinct road_id,adr_rd_no from
      address where
      contract_no < 6000
  insert into #del_counts(rd_id,rd_no,tc_id,contract_no,del_count)
    select distinct(addr.road_id),
      addr.adr_rd_no,addr.tc_id,addr.contract_no,
      count(addr.adr_id) from
      address as addr,
      #road_ids as rdi where
      addr.road_id = rdi.rd_id and
      addr.adr_rd_no = rdi.rd_no and
      addr.contract_no < 6000
      group by addr.contract_no,addr.road_id,addr.adr_rd_no,addr.tc_id
  insert into #road_nos(rd_id,rd_no,tc_id,min_no,max_no)
    select road_id,adr_rd_no,tc_id,min(convert(integer,adr_no)),max(convert(integer,adr_no)) from
      address where
      contract_no < 6000
      group by contract_no,adr_rd_no,tc_id,road_id
  --  select distinct(rd.Road_name + ' ' +  rt.rt_name), 
  select dc.contract_no,
    rn.min_no,
    rn.max_no,
    rd.road_name,
    road_type=ltrim(rtrim(rt.rt_name+' '+rs.rs_name)),
    tc.tc_name,
    dc.rd_no,
    dc.del_count from
    #del_counts as dc,
    road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
    road_suffix as rs on rd.rs_id=rs.rs_id,
    towncity as tc,
    #road_nos as rn where
    rd.road_id = dc.rd_id and
    rd.road_id = rn.rd_id and
    dc.tc_id = tc.tc_id and
    dc.tc_id = rn.tc_id and
    dc.rd_no = rn.rd_no
    --and addr.road_id = rd.road_id
    -- NOTE: the 'road_name' here is the alias for the road_name+road_type+road_suffix in the select part
    --       Also: this "group by" is probably redundant.
    group by dc.contract_no,
    rd.road_name,
    ltrim(rtrim(rt.rt_name+' '+rs.rs_name)),
    dc.rd_no,
    tc.tc_name,
    dc.del_count,
    rn.min_no,
    rn.max_no order by
    road_name asc,dc.rd_no asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_CTS_AccountCodes : 
--

CREATE procedure [rd].[OD_CTS_AccountCodes]
as
begin
  select Account_Codes.ac_id,
    Account_Codes.ac_code,
    Account_Codes.ac_description from
    odps.account_codes order by 2 asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRouteDescription : 
--

--
-- Definition for stored procedure sp_GetRouteDescription : 
--

CREATE procedure [rd].[sp_GetRouteDescription](@inContract int,@inSFKey int,@inDelDays char(7))
as
begin
  select sf_key,
    contract_no,
    rd_sequence,
    rf_delivery_days,
    rd_description_of_point=case when cust_id is null then rd_description_of_point else (select c.cust_surname_company+', '+c.cust_initials from customer as c where c.cust_id = route_description.cust_id) end ,
    rd_time_at_point,
    rfv_id,
    rfpd_id,
    rf_distance_of_leg,
    rf_running_total,
    rfv_id_2,
    cust_id from
    route_description where
    contract_no = @inContract and
    sf_key = @inSFKey and
    rf_delivery_days = @inDelDays order by
    rd_sequence asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function GetFinYear : 
--

CREATE function [rd].[GetFinYear](@indate datetime,@intype char(1))
returns datetime
as
begin
  declare @v_fsdate datetime,
  @v_esdate datetime
  if month(@indate) > 3
    begin
      select @v_fsdate=convert(datetime,convert(varchar,year(@indate))+'/07/01')
      select @v_esdate=convert(datetime,convert(varchar,year(@indate)+1)+'/06/30')
    end
  else
    begin
      select @v_fsdate=convert(datetime,convert(varchar,year(@indate)-1)+'/07/01')
      select @v_esdate=convert(datetime,convert(varchar,year(@indate))+'/06/30')
    end
  if @intype = 'S'
    return(@v_fsdate)
  else
    return(@v_esdate)
return getdate()
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRouteDescription_fast32 : 
--

CREATE procedure [rd].[sp_GetRouteDescription_fast32](@inContract int,@inSFKey int,@inDelDays char(7))
as
begin
  select sf_key,
    contract_no,
    rd_sequence,
    rf_delivery_days,
    rd_description_of_point=left(case when cust_id is null then rd_description_of_point else (select c.cust_surname_company+', '+c.cust_initials from customer as c where c.cust_id = route_description.cust_id) end ,40),
    rd_time_at_point,
    rfv_id,
    rfpd_id,
    (select left(rfpt_description,40) from route_freq_point_type where route_freq_point_type.rfpt_id = route_description.rfpd_id),
    rf_distance_of_leg,
    rf_running_total,
    rfv_id_2,
    cust_id,
    0,0 from
    route_description where
    contract_no = @inContract and
    sf_key = @inSFKey and
    rf_delivery_days = @inDelDays order by
    rd_sequence asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_UpdatedContractors : 
--


--
-- Definition for user-defined function v_fuelRateDescription : 
--

--
-- Definition for user-defined function v_fuelRateDescription : 
--

CREATE function [odps].[v_fuelRateDescription](@inDescription varchar(200))
returns varchar(200)
-- TJB  SR4654  April 2005     New
-- Called if the description is for a 'Global fuel rate change'.
-- If the description has the new wording (includes either "Increase" or "Decrease")
--    return only the first 2 lines (drop the "New standard rate...").
as -- Otherwise the whole string is returned unchanged.
begin
  declare @i integer
  select @i=CHARINDEX(@inDescription,'Increase')
  if @i = 0
    begin
      select @i=CHARINDEX(@inDescription,'Decrease')
      if @i = 0
        return @inDescription
    end
  select @i=CHARINDEX(@inDescription,'New standard')
  return substring(@inDescription,1,@i-2)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRouteDescription_fast : 
--

CREATE procedure [rd].[sp_GetRouteDescription_fast](@inContract int,@inSFKey int,@inDelDays char(7))
as
begin
  select sf_key,
    contract_no,
    rd_sequence,
    rf_delivery_days,
    rd_description_of_point=case when cust_id is null then rd_description_of_point 
	else 
    (select c.cust_surname_company+', '+c.cust_initials from customer as c where c.cust_id = route_description.cust_id) end,
    rd_time_at_point,
    rfv_id,
    rfpd_id,
    (select rfpt_description from route_freq_point_type where route_freq_point_type.rfpt_id = route_description.rfpd_id),
    rf_distance_of_leg,
    rf_running_total,
    rfv_id_2,
    cust_id from
    route_description where
    contract_no = @inContract and
    sf_key = @inSFKey and
    rf_delivery_days = @inDelDays order by
    rd_sequence asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
 

--
-- Definition for stored procedure sp_cust_list_variable : 
--
 
CREATE procedure [rd].[sp_cust_list_variable](
@inPost char(5000),
@inOcc char(200),
@inInterest char(200),
@inDate1 datetime,
@inDate2 datetime)
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added adr_unit number and road_suffix to relevant parts of addresses returned
-- TJB  Apr 2006  NPAD2 bug fixes
-- New post codes mean the inPost string may be much longer that previously.
as -- Increased its length (was 1200).
begin
  declare @li_post int,
  @li_occ int,
  @li_int int,
  @movein1 datetime,
  @movein2 datetime
  -- create temp for post_codes
  CREATE  table #post_temp(
    post_id integer null,
    ) 
--on commit delete rows;
  -- create temp for  occupations :
  CREATE  table #occ_temp(
    occ_id integer null,
    )
-- on commit delete rows;
  -- create temp for interests
  CREATE  table #interest_temp(
    int_id integer null,
    ) 
--on commit delete rows;
 
  -- get timestamps
  if @inDate1 is not null
    select @movein1 = CAST(@inDate1 AS datetime )
  else
    select @movein1=null
  if @inDate1 is not null
    select @movein2 = CAST(@inDate2 AS datetime )
  else
    select @movein2=null
  -- populate temp tables : 
  if(@inPost is not null) and(LEN(@inPost) > 1)
    execute('insert into #post_temp(post_id) '+'select distinct(post_code_id) '+'  from post_code where post_code.post_code_id in '+
      @inPost+' ; ')
  if(@inOcc is not null) and(LEN(@inOcc) > 1)
    execute('insert into #occ_temp(occ_id) '+'select distinct(occupation_id) '+'  from occupation where occupation.occupation_id in '+
      @inOcc+' ; ')
  if(@inInterest is not null) and(LEN(@inInterest) > 1)
    execute('insert into #interest_temp(int_id) '+'select distinct(interest_id) '+'  from interest where interest.interest_id in '+
      @inInterest+' ; ')
  -- get counts of temp tables
  select @li_post = count(*) from #post_temp
  select @li_occ = count(*) from #occ_temp
  select @li_int = count(*) from #interest_temp
  -- TJB  SR4663  May 2005
  -- Change 'R D ' to 'RD '
  select cust.cust_id,
    cust.cust_title,
    cust.cust_initials,
    cust.cust_surname_company,
    upper(/*ifnull(addr.adr_unit,'',addr.adr_unit+'/')*/case when isnull(addr.adr_unit,'') = '' then '' else addr.adr_unit+'/' end +rd.trim(addr.adr_no))+upper(rd.trim(addr.adr_alpha)),
    rd.road_name+/*ifnull(rt.rt_name,'',' '+rt.rt_name)*/case when isnull(rt.rt_name,'') = '' then '' else ' '+rt.rt_name end +/*ifnull(rs.rs_name,'',' '+rs.rs_name)*/case when isnull(rs.rs_name,'') = '' then '' else ' '+rs.rs_name end,
    sub.sl_name,'RD '+
    addr.adr_rd_no,
    pc.post_mail_town+'     '+pc.post_code,
    pc.post_mail_town,
    pc.post_code from
    rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id
    join address as addr on addr.adr_id = cam.adr_id
    left outer join suburblocality as sub on addr.sl_id = sub.sl_id
    left outer join post_code as pc on addr.post_code_id = pc.post_code_id
    join road as rd on addr.road_id = rd.road_id
    left outer join road_type as rt on rd.rt_id = rt.rt_id
    left outer join road_suffix as rs on rd.rs_id = rs.rs_id where
    (@li_post = 0 or addr.post_code_id = any(select post_id from #post_temp)) and
    (@li_occ = 0 or cust.cust_id = 
    any(select co.cust_id from customer_occupation as co,#occ_temp as ot where co.occupation_id = ot.occ_id)) and
    (@li_int = 0 or cust.cust_id = 
    any(select ci.cust_id from customer_interest as ci,#interest_temp as it where ci.interest_id = it.int_id)) and
    cam.move_out_date is null and
    cust.master_cust_id is null and
    (@movein1 is null or cam.move_in_date > @movein1) and
    (@movein2 is null or cam.move_in_date < @movein2) and
    cust.cust_surname_company not like '%&%' and
    -- and cust.cust_title not like '%&%'
    -- and cust.cust_initials not like '%&%'
    cust.cust_title is not null and
    cust.cust_dir_listing_ind = 'Y'
end
 
 
 
 







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function GetRateReturn : 
--

CREATE function [rd].[GetRateReturn](@inNomVehicle decimal(10,2),@inRateReturn decimal(10,2),@inSalvage decimal(10,2))
returns real
as
begin
  declare @Year1To4 real,
  @Year5 real,
  @RateRetPCT decimal(10,4),
  @SalvagePCT decimal(10,4),
  @NPVAmount real,
  @Payments real
  if not(@inRateReturn is null or @inRateReturn = 0)
    begin
      select @RateRetPCT=@inRateReturn/100
      select @SalvagePCT=@inSalvage/100
      select @Year1To4=@inNomVehicle*@RateRetPCT
      if not(@inSalvage is null or @inSalvage = 0)
        select @Year5=@Year1To4-(@inNomVehicle*@SalvagePCT)
      else
        select @Year5=@Year1To4
      select @NPVAmount=(@Year1To4/Power((1+@RateRetPCT),1))+
        (@Year1To4/Power((1+@RateRetPCT),2))+
        (@Year1To4/Power((1+@RateRetPCT),3))+
        (@Year1To4/Power((1+@RateRetPCT),4))+
        (@Year5/Power((1+@RateRetPCT),5))
      select @Payments=(((0-@NPVAmount)*Power((1+@RateRetPCT),5))*-1)/
        (Power((1+@RateRetPCT),5)-1)*@RateRetPCT
    end
  return(@Payments)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_YearlyEarnings : 
--

--
-- Definition for stored procedure OD_Z________________________________________ : 
--

CREATE procedure [odps].[OD_Z________________________________________]
as
select 1








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetUnconfirmedCustomersCount : 
--

CREATE procedure [rd].[sp_GetUnconfirmedCustomersCount](@inContract int,@indate datetime)
as
begin
  select count(*) from
    customer where
    contract_no = @incontract and
    ((cust_date_commenced is null) or(cust_date_commenced < @indate and @indate is not null))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure hcn : 
--

CREATE procedure [odps].[hcn](@sdate datetime,@edate datetime)
as
select Item='nat_ac_id_gst_gl',
  PreviousPeriod=case when rd.OD_BLF_GetValue(@sdate,@edate-1,'nat_ac_id_gst_gl') = nat_ac_id_gst_gl then
    nat_ac_id_gst_gl
  else
    rd.OD_BLF_GetValue(@sdate,@edate-1,'nat_ac_id_gst_gl')
  end,
  ThisPeriod=rd.OD_BLF_GetValue(@sdate,@edate,'nat_ac_id_gst_gl') from
  "national" where
  nat_effective_date between @sdate and @edate and
  nat_id = rd.OD_BLF_GetValue(@sdate,@edate-1,'nat_id')








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetUnconfirmedCustomers : 
--

CREATE procedure [rd].[sp_GetUnconfirmedCustomers](@Inregion int,@inOutlet int,@inContract int,@indate datetime)
as
begin
  if @indate is not null
    select region.rgn_name,
      outlet.o_name,contract_no,
      con_title,
      count1=(select count(*) from
        customer where
        (customer.contract_no = contract.contract_no) and
        (cust_date_first_loaded <= @indate) and
        ((customer.cust_date_commenced is null) or(customer.cust_date_commenced >= @indate))) from
      outlet,
      region,
      contract where
      (region.region_id = outlet.region_id) and
      (outlet.outlet_id = contract.con_base_office) and
      (contract.con_active_sequence > 0) and
      ((@incontract = contract.contract_no and
      @incontract > 0) or
      (@inoutlet = contract.con_base_office and
      @inoutlet > 0 and
      @incontract = 0) or
      (@inregion = outlet.region_id and
      @inregion > 0 and
      @inoutlet = 0 and @incontract = 0) or
      (@inRegion = 0 and @inoutlet = 0 and @incontract = 0))
  else
    select region.rgn_name,
      outlet.o_name,contract_no,
      con_title,
      count1=(select count(*) from
        customer where
        (customer.contract_no = contract.contract_no) and
        ((customer.cust_date_commenced is null))) from
      outlet,
      region,
      contract where
      (region.region_id = outlet.region_id) and
      (outlet.outlet_id = contract.con_base_office) and
      (contract.con_active_sequence > 0) and
      ((@incontract = contract.contract_no and
      @incontract > 0) or
      (@inoutlet = contract.con_base_office and
      @inoutlet > 0 and
      @incontract = 0) or
      (@inregion = outlet.region_id and
      @inregion > 0 and
      @inoutlet = 0 and @incontract = 0) or
      (@inRegion = 0 and @inoutlet = 0 and @incontract = 0))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD________________________ : 
--

CREATE function [odps].[OD________________________]()
returns datetime
as
begin
  declare @l_date datetime
  return(@l_date)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_getUnoccupied : 
--

CREATE procedure [rd].[sp_getUnoccupied](@con_id int)
-- TJB  Sept 2005  NPAD2 address schema changes
as -- Added adr_unit number and road_suffix to relevant parts of address returned
begin
  -- temp table for lastest move in dates from customer_address_moves
  create table #latest_in_temp(
    adr_id integer null,
    move_in datetime null,
    ) 
   -- temp table for lastest move in dates from customer_address_moves
  create table #latest_out_temp(
    adr_id integer null,
    move_out datetime null,
    )  -- temp table for lastest move in dates from customer_address_moves
  create table #latest_temp(
    adr_id integer null,
    ) 
  -- temp table for all address attached to a contract
  -- temp table for address'' with no customer_address_moves entry
  create table #addr_temp(
    adr_id integer null,
    road_id integer null,
    sl_id integer null,
    tc_id integer null,
    adr_no char(20) null,
    adr_rd_no char(40) null,
    ) 
  -- populate the addr_temp table
  create table #unocc_temp(
    adr_id integer null,
    road_id integer null,
    sl_id integer null,
    tc_id integer null,
    adr_no char(20) null,
    adr_rd_no char(40) null,
    )
  insert into #addr_temp(adr_id,road_id,sl_id,tc_id,adr_no,adr_rd_no)
    select addr.adr_id,
      addr.road_id,
      addr.sl_id,
      addr.tc_id,
      case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +addr.adr_no+addr.adr_alpha,
      addr.adr_rd_no from
      address as addr where
      addr.contract_no = @con_id
  -- get an outer join for address and customer_address_moves - this is all those with no move entry
  insert into #unocc_temp(adr_id,road_id,sl_id,tc_id,adr_no,adr_rd_no)
    select addr.adr_id,
      addr.road_id,
      addr.sl_id,
      addr.tc_id,
      case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +addr.adr_no+addr.adr_alpha,
      addr.adr_rd_no from
      address as addr left outer join customer_address_moves as cam on addr.adr_id=cam.adr_id where
      addr.contract_no = @con_id and
      cam.adr_id is null
  insert into #latest_out_temp(adr_id,move_out)
    select cam.adr_id,
      max(cam.move_out_date) from
      customer_address_moves as cam,
      rds_customer as cust,
      address as addr where
      addr.contract_no = @con_id and
      cam.adr_id = addr.adr_id and
      cust.master_cust_id is null and
      cam.cust_id = cust.cust_id
      group by cam.adr_id
  insert into #latest_in_temp(adr_id,move_in)
    select cam.adr_id,
      max(cam.move_in_date) from
      customer_address_moves as cam,
      rds_customer as cust,
      address as addr where
      addr.contract_no = @con_id and
      cam.adr_id = addr.adr_id and
      cust.master_cust_id is null and
      cam.cust_id = cust.cust_id
      group by cam.adr_id
  insert into #latest_temp(adr_id)
    select lat_out.adr_id from
      #latest_in_temp as lat_in,
      #latest_out_temp as lat_out where
      -- , addr_temp addr
      lat_in.adr_id = lat_out.adr_id and
      lat_in.move_in < lat_out.move_out
  -- do a double check - see if any of these has a missing move_out_date
  delete from #latest_temp where
    adr_id = any(select cam.adr_id from
      address as addr join customer_address_moves as cam on addr.adr_id=cam.adr_id where
      addr.contract_no = @con_id and
      cam.move_out_date is null)
  -- insert address'' into unocc_temp
  insert into #unocc_temp(adr_id,road_id,sl_id,tc_id,adr_no,adr_rd_no)
    select addr.adr_id,
      addr.road_id,
      addr.sl_id,
      addr.tc_id,
      case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +addr.adr_no+addr.adr_alpha,
      addr.adr_rd_no from
      address as addr,
      #latest_temp as lat where
      addr.adr_id = lat.adr_id and
      not addr.adr_id = 
      any(select adr_id from #unocc_temp)
  -- and addr.contract_no = con_id
  select oc.adr_no,
    road_name=rd.road_name+
    case when rt.rt_name is null then null else ' '+rt.rt_name end +
    case when rs.rs_name is null then null else ' '+rs.rs_name end ,
    sl.sl_name,
    tc.tc_name,
    oc.adr_rd_no,
    @con_id,
    con.con_title from
    #unocc_temp as oc left outer join road as rd on
    rd.road_id = oc.road_id
	 left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
    road_suffix as rs on rd.rs_id=rs.rs_id
	 left outer join towncity as tc on
    (oc.tc_id = tc.tc_id),
    #unocc_temp as oc2 left outer join suburblocality as sl on
    (oc2.sl_id = sl.sl_id),
    contract as con where
    con.contract_no = @con_id order by
    -- and sl.sl_id = oc.sl_id
    -- and tc.tc_id = oc.tc_id
    -- and rd.road_id = oc.road_id
    road_name asc,oc.adr_no asc
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure  [odps].[OD_RPF_Invoice_pay_piecerate_detail](@inContractor int,@inDate datetime,@inContract int,@inRegion int,@inCname char(40),@inCtKey int)
as
begin
  -- TJB  SR4684  June/2006
  -- Addd processing for Parcel Post
  --
  -- 14/02/02 PBY Request#4326
  -- Removed hardcoding of Kiwimail, CourierPost and XP from sql code.
  -- Used the corresponding piece_rate_suplier.prs_key instead.
  --
  -- Kiwimail       prs_key 1
  -- CourierPost    prs_key 2
  -- XP  (Skyroad)  prs_key 3
  -- Parcel Post    prs_key 4
  --
  set implicit_transactions on
  --begin transaction
  declare @lcontract int,
  @linvoice int
  -- TJB SR4639 3/12/04 - Add contract type as one of the selection criteria
  -- If the user selects one of the contracts returned by the selection, inContract will hold that value.
  -- and (inContract is null or inContract=0 or (inContract<>0 and contract.contract_no=inContract))
  declare vc_contract_list cursor for select distinct
      payment.contract_no,
      payment.invoice_id from
      payment,
      rd.contract,
      rd.outlet,
      rd.contractor,
      rd.types_for_contract where
      payment.contract_no = contract.contract_no and
      contract.con_base_office = outlet.outlet_id and
      contractor.contractor_supplier_no = payment.contractor_supplier_no and
      payment.invoice_date = @inDate and
      ((c_surname_company like @inCname+'%' and len(@inCname) > 0) or len(@inCname) = 0 or @inCname is null) and
      ((outlet.region_id = @inRegion and @inRegion > 0) or @inRegion = 0 or @inRegion is null) and
      (@inCtKey is null or @inCtKey = 0 or(@inCtKey <> 0 and types_for_contract.ct_key = @inCtKey)) and
      types_for_contract.contract_no = contract.contract_no
  delete from t_invoice_piecerates -- Kiwimail
  delete from t_invoice_piecerates2 -- Courier Post
  delete from t_invoice_piecerates3 -- SkyRoad (XP)
  delete from t_invoice_piecerates4 -- Parcel Post
  commit transaction
  -- If specific contract is specified, do this
  if(@inContract is not null) and(@inContract > 0)
    begin
      insert into t_invoice_piecerates(invoice_id,
        atype,
        prd_date,
        prt_code,
        prd_quantity,
        cost,
        rate,
        rownum)
        select invoice_id,
          prs_description,
          piece_rate_delivery.prd_date,
          piece_rate_type.prt_code,
          piece_rate_delivery.prd_quantity,
          piece_rate_delivery.prd_cost,
          rate=prd_cost/prd_quantity,
          row_number() over (order by invoice_id asc)
		  from
          rd.piece_rate_type,
          rd.piece_rate_delivery,
          payment,
          rd.piece_rate_supplier where
          payment.contract_no = piece_rate_delivery.contract_no and
          piece_rate_type.prs_key = piece_rate_supplier.prs_key and
          piece_rate_type.prt_key = piece_rate_delivery.prt_key and
          payment.invoice_date = piece_rate_delivery.prd_paid_to_date and
          (payment.contract_no = @inContract and piece_rate_supplier.prs_key = 1) and
          payment.invoice_date = @inDate and
          piece_rate_delivery.prd_paid_to_date = @inDate
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          set implicit_transactions off --add
          return(-100001000)
        end
      insert into t_invoice_piecerates2(invoice_id,
        atype,
        prd_date,
        prt_code,
        prd_quantity,
        cost,
        rate,
        rownum)
        select invoice_id,
          prs_description,
          piece_rate_delivery.prd_date,
          piece_rate_type.prt_code,
          piece_rate_delivery.prd_quantity,
          piece_rate_delivery.prd_cost,
          rate=prd_cost/prd_quantity,
          row_number() over (order by invoice_id asc)
		  from
          rd.piece_rate_type,
          rd.piece_rate_delivery,
          payment,
          rd.piece_rate_supplier where
          payment.contract_no = piece_rate_delivery.contract_no and
          piece_rate_type.prs_key = piece_rate_supplier.prs_key and
          piece_rate_type.prt_key = piece_rate_delivery.prt_key and
          payment.invoice_date = piece_rate_delivery.prd_paid_to_date and
          (payment.contract_no = @inContract and piece_rate_supplier.prs_key = 2) and
          payment.invoice_date = @inDate and
          piece_rate_delivery.prd_paid_to_date = @inDate
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          set implicit_transactions off  --add
          return(-100001010)
        end
      insert into t_invoice_piecerates3(invoice_id,
        atype,
        prd_date,
        prt_code,
        prd_quantity,
        cost,
        rate,
        rownum)
        select invoice_id,
          prs_description,
          piece_rate_delivery.prd_date,
          piece_rate_type.prt_code,
          piece_rate_delivery.prd_quantity,
          piece_rate_delivery.prd_cost,
          rate=prd_cost/prd_quantity,
          row_number() over (order by invoice_id asc)
		  from
          rd.piece_rate_type,
          rd.piece_rate_delivery,
          payment,
          rd.piece_rate_supplier where
          payment.contract_no = piece_rate_delivery.contract_no and
          piece_rate_type.prs_key = piece_rate_supplier.prs_key and
          piece_rate_type.prt_key = piece_rate_delivery.prt_key and
          payment.invoice_date = piece_rate_delivery.prd_paid_to_date and
          (payment.contract_no = @inContract and piece_rate_supplier.prs_key = 3) and
          payment.invoice_date = @inDate and
          piece_rate_delivery.prd_paid_to_date = @inDate
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          set implicit_transactions off --add
          return(-100001110)
        end
      insert into t_invoice_piecerates4(invoice_id,
        atype,
        prd_date,
        prt_code,
        prd_quantity,
        cost,
        rate,
        rownum)
        select invoice_id,
          prs_description,
          piece_rate_delivery.prd_date,
          piece_rate_type.prt_code,
          piece_rate_delivery.prd_quantity,
          piece_rate_delivery.prd_cost,
          rate=prd_cost/prd_quantity,
          row_number() over (order by invoice_id asc)
		  from
          rd.piece_rate_type,
          rd.piece_rate_delivery,
          payment,
          rd.piece_rate_supplier where
          payment.contract_no = piece_rate_delivery.contract_no and
          piece_rate_type.prs_key = piece_rate_supplier.prs_key and
          piece_rate_type.prt_key = piece_rate_delivery.prt_key and
          payment.invoice_date = piece_rate_delivery.prd_paid_to_date and
          (payment.contract_no = @inContract and piece_rate_supplier.prs_key = 4) and
          payment.invoice_date = @inDate and
          piece_rate_delivery.prd_paid_to_date = @inDate
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          set implicit_transactions off --add
          return(-100001210)
        end
        commit transaction --add by hhuang on 2007/10/10
    end
  else
    begin
      -- If its an 'all contracts' situation, do this
      open vc_contract_list
      if @@error <> 0
        begin
          rollback transaction
          set implicit_transactions off --add
          return(-100001001)
        end
      /* Watcom only
      cListLoop:
      */while 1=1 
        begin
          fetch next from vc_contract_list into @lcontract,@linvoice
          if @@fetch_status <0
            break
            /* Watcom only
            cListLoop
            */
          insert into t_invoice_piecerates(invoice_id,
            atype,
            prd_date,
            prt_code,
            prd_quantity,
            cost,
            rate,
            rownum)
            select invoice_id,
              prs_description,
              piece_rate_delivery.prd_date,
              piece_rate_type.prt_code,
              piece_rate_delivery.prd_quantity,
              piece_rate_delivery.prd_cost,
              rate=prd_cost/prd_quantity,
              row_number() over (order by invoice_id asc)
			  from
              rd.piece_rate_type,
              rd.piece_rate_delivery,
              payment,
              rd.piece_rate_supplier where
              piece_rate_delivery.prt_key = piece_rate_type.prt_key and
              piece_rate_delivery.prd_paid_to_date = payment.invoice_date and
              piece_rate_supplier.prs_key = piece_rate_type.prs_key and
              piece_rate_supplier.prs_key = 1 and
              payment.contract_no = @lcontract and
              payment.invoice_id = @linvoice and
              payment.invoice_date = @inDate and
              payment.contract_no = piece_rate_delivery.contract_no
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              set implicit_transactions off --add
              return(-100001101)
            end
          insert into t_invoice_piecerates2(invoice_id,
            atype,
            prd_date,
            prt_code,
            prd_quantity,
            cost,
            rate,
            rownum)
            select invoice_id,
              prs_description,
              piece_rate_delivery.prd_date,
              piece_rate_type.prt_code,
              piece_rate_delivery.prd_quantity,
              piece_rate_delivery.prd_cost,
              rate=prd_cost/prd_quantity,
              row_number() over (order by invoice_id asc)
			  from
              rd.piece_rate_type,
              rd.piece_rate_delivery,
              payment,
              rd.piece_rate_supplier where
              piece_rate_delivery.prt_key = piece_rate_type.prt_key and
              piece_rate_delivery.prd_paid_to_date = payment.invoice_date and
              piece_rate_supplier.prs_key = piece_rate_type.prs_key and
              piece_rate_supplier.prs_key = 2 and
              payment.invoice_date = @inDate and
              payment.contract_no = @lcontract and
              payment.invoice_id = @linvoice and
              payment.contract_no = piece_rate_delivery.contract_no
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              set implicit_transactions off --add
              return(-100001102)
            end
          insert into t_invoice_piecerates3(invoice_id,
            atype,
            prd_date,
            prt_code,
            prd_quantity,
            cost,
            rate,
            rownum)
            select invoice_id,
              prs_description,
              piece_rate_delivery.prd_date,
              piece_rate_type.prt_code,
              piece_rate_delivery.prd_quantity,
              piece_rate_delivery.prd_cost,
              rate=prd_cost/prd_quantity,
              row_number() over (order by invoice_id asc)
			  from
              rd.piece_rate_type,
              rd.piece_rate_delivery,
              payment,
              rd.piece_rate_supplier where
              piece_rate_delivery.prt_key = piece_rate_type.prt_key and
              piece_rate_delivery.prd_paid_to_date = payment.invoice_date and
              piece_rate_supplier.prs_key = piece_rate_type.prs_key and
              piece_rate_supplier.prs_key = 3 and
              payment.invoice_date = @inDate and
              payment.contract_no = @lcontract and
              payment.invoice_id = @linvoice and
              payment.contract_no = piece_rate_delivery.contract_no
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              set implicit_transactions off --add
              return(-100001112)
            end
          insert into t_invoice_piecerates4(invoice_id,
            atype,
            prd_date,
            prt_code,
            prd_quantity,
            cost,
            rate,
            rownum)
            select invoice_id,
              prs_description,
              piece_rate_delivery.prd_date,
              piece_rate_type.prt_code,
              piece_rate_delivery.prd_quantity,
              piece_rate_delivery.prd_cost,
              rate=prd_cost/prd_quantity,
              row_number() over (order by invoice_id asc)
		      from
              rd.piece_rate_type,
              rd.piece_rate_delivery,
              payment,
              rd.piece_rate_supplier where
              piece_rate_delivery.prt_key = piece_rate_type.prt_key and
              piece_rate_delivery.prd_paid_to_date = payment.invoice_date and
              piece_rate_supplier.prs_key = piece_rate_type.prs_key and
              piece_rate_supplier.prs_key = 4 and
              payment.invoice_date = @inDate and
              payment.contract_no = @lcontract and
              payment.invoice_id = @linvoice and
              payment.contract_no = piece_rate_delivery.contract_no
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              set implicit_transactions off  --add
              return(-100001212)
            end
        end
      close vc_contract_list
      commit transaction
      set implicit_transactions off --add
    end
    DEALLOCATE vc_contract_list --add by hhuang on 2007/10/10
  return(0)
end


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_Invoice_pay_piecerate_detail : 
--

CREATE procedure [odps].[OD_RPS_Invoice_pay_piecerate_detail](@invoiceid int)
as
begin
  declare @v_tempint int,
  @v_tempint2 int
  select @v_tempint = count(*) 
    from t_invoice_piecerates where invoice_id = @invoiceid
  select @v_tempint2 = count(*) 
    from t_invoice_piecerates2 where invoice_id = @invoiceid
  if(@v_tempint >= @v_tempint2) or((@v_tempint2 is null) or(@v_tempint2 = 0))
    select t_invoice_piecerates.invoice_id,
      t_invoice_piecerates.prd_date,
      t_invoice_piecerates.prt_code,
      t_invoice_piecerates.prd_quantity,
      t_invoice_piecerates.rate,
      t_invoice_piecerates.cost,
      t_invoice_piecerates2.prd_date,
      t_invoice_piecerates2.prt_code,
      t_invoice_piecerates2.prd_quantity,
      t_invoice_piecerates2.rate,
      t_invoice_piecerates2.cost from
      t_invoice_piecerates left outer join t_invoice_piecerates2 on t_invoice_piecerates.invoice_id = t_invoice_piecerates2.invoice_id and
      t_invoice_piecerates.rownum = t_invoice_piecerates2.rownum where
      t_invoice_piecerates.invoice_id = @invoiceid order by
      t_invoice_piecerates.prd_date asc,
      t_invoice_piecerates.prt_code asc
  else
    select t_invoice_piecerates2.invoice_id,
      t_invoice_piecerates.prd_date,
      prt_code=t_invoice_piecerates.prt_code,
      t_invoice_piecerates.prd_quantity,
      t_invoice_piecerates.rate,
      t_invoice_piecerates.cost,
      t_invoice_piecerates2.prd_date,
      t_invoice_piecerates2.prt_code,
      t_invoice_piecerates2.prd_quantity,
      t_invoice_piecerates2.rate,
      t_invoice_piecerates2.cost from
      t_invoice_piecerates2 left outer join t_invoice_piecerates on t_invoice_piecerates2.invoice_id = t_invoice_piecerates.invoice_id and
      t_invoice_piecerates2.rownum = t_invoice_piecerates.rownum where
      t_invoice_piecerates2.invoice_id = @invoiceid order by
      t_invoice_piecerates2.prd_date asc,
      t_invoice_piecerates2.prt_code asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPF_Invoice_pay_piecerate_detailv2 : 
--

CREATE procedure [odps].[OD_RPF_Invoice_pay_piecerate_detailv2](@incontractor int,@indate datetime,@incontract int,@inregion int,@cname char(40))
as
begin
  -- 14/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
  -- sql code.  Used the corresponding piece_rate_suplier.prs_key instead.
  declare @lcontract int,
  @linvoice int
  declare vc_contract_list cursor for select payment.contract_no,payment.invoice_id from
      payment,
      rd.contract,
      rd.outlet,
      rd.contractor where
      (payment.contract_no = contract.contract_no) and
      (contract.con_base_office = outlet.outlet_id) and
      (contractor.contractor_supplier_no = payment.contractor_supplier_no) and
      ((c_surname_company like @cname + '%' and len(@cname) > 0) or(len(@cname) = 0) or(@cname is null)) and
      (payment.invoice_date = @indate) and
      ((outlet.region_id = @inregion and @inregion > 0) or
      (@inregion = 0) or(@inregion is null))
  delete from t_invoice_piecerates
  delete from t_invoice_piecerates2
  delete from t_invoice_piecerates3
  commit transaction
  if(@incontract is not null) and(@incontract > 0)
    begin
      insert into t_invoice_piecerates(invoice_id,atype,prd_date,prt_code,prd_quantity,cost,rate,rownum)
        select invoice_id,prs_description,piece_rate_delivery.prd_date,
          piece_rate_type.prt_code,
          piece_rate_delivery.prd_quantity,
          piece_rate_delivery.prd_cost,
          rate=prd_cost/prd_quantity,
          row_number() over (order by invoice_id asc)
		  from
          rd.piece_rate_type,
          rd.piece_rate_delivery,
          payment,
          rd.piece_rate_supplier where
          (payment.contract_no = piece_rate_delivery.contract_no) and
          (piece_rate_type.prs_key = piece_rate_supplier.prs_key) and
          (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
          (payment.invoice_date = piece_rate_delivery.prd_paid_to_date) and
          ((payment.contract_no = @incontract) and
          (piece_rate_supplier.prs_key = 1)) and
          (invoice_date = @indate) and
          (piece_rate_delivery.prd_paid_to_date = @indate)
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-100001000)
        end
      insert into t_invoice_piecerates2(invoice_id,atype,prd_date,prt_code,prd_quantity,cost,rate,rownum)
        select invoice_id,prs_description,piece_rate_delivery.prd_date,
          piece_rate_type.prt_code,
          piece_rate_delivery.prd_quantity,
          piece_rate_delivery.prd_cost,
          rate=prd_cost/prd_quantity,
          row_number() over (order by invoice_id asc)
		  from
          rd.piece_rate_type,
          rd.piece_rate_delivery,
          payment,
          rd.piece_rate_supplier where
          (payment.contract_no = piece_rate_delivery.contract_no) and
          (piece_rate_type.prs_key = piece_rate_supplier.prs_key) and
          (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
          (payment.invoice_date = piece_rate_delivery.prd_paid_to_date) and
          ((payment.contract_no = @incontract) and
          (piece_rate_supplier.prs_key = 2)) and
          (invoice_date = @indate) and
          (piece_rate_delivery.prd_paid_to_date = @indate)
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-100001010)
        end
      insert into t_invoice_piecerates3(invoice_id,atype,prd_date,prt_code,prd_quantity,cost,rate,rownum)
        select invoice_id,prs_description,piece_rate_delivery.prd_date,
          piece_rate_type.prt_code,
          piece_rate_delivery.prd_quantity,
          piece_rate_delivery.prd_cost,
          rate=prd_cost/prd_quantity,
          row_number() over (order by invoice_id asc)
		  from
          rd.piece_rate_type,
          rd.piece_rate_delivery,
          payment,
          rd.piece_rate_supplier where
          (payment.contract_no = piece_rate_delivery.contract_no) and
          (piece_rate_type.prs_key = piece_rate_supplier.prs_key) and
          (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
          (payment.invoice_date = piece_rate_delivery.prd_paid_to_date) and
          ((payment.contract_no = @incontract) and
          (piece_rate_supplier.prs_key = 3)) and
          (invoice_date = @indate) and
          (piece_rate_delivery.prd_paid_to_date = @indate)
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-100001110)
        end
    end
  else
    begin
      open vc_contract_list
      if @@error <> 0
        begin
          rollback transaction
          return(-100001001)
        end
      /* Watcom only
      cListLoop:
      */while 1=1 
        begin
          fetch next from vc_contract_list into @lcontract,@linvoice
          if @@fetch_status <0
            break
            /* Watcom only
            cListLoop
            */
          insert into t_invoice_piecerates(invoice_id,atype,prd_date,prt_code,prd_quantity,cost,rate,rownum)
            select invoice_id,prs_description,piece_rate_delivery.prd_date,
              piece_rate_type.prt_code,
              piece_rate_delivery.prd_quantity,
              piece_rate_delivery.prd_cost,
              rate=prd_cost/prd_quantity,
              row_number() over (order by invoice_id asc)
			  from
              rd.piece_rate_type,
              rd.piece_rate_delivery,
              payment,
              rd.piece_rate_supplier where
              (piece_rate_delivery.prt_key = piece_rate_type.prt_key) and
              (piece_rate_delivery.prd_paid_to_date = payment.invoice_date) and
              (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
              (piece_rate_supplier.prs_key = 1) and
              (payment.contract_no = @lcontract) and
              (payment.invoice_id = @linvoice) and
              (payment.invoice_date = @indate) and
              (payment.contract_no = piece_rate_delivery.contract_no)
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-100001101)
            end
          insert into t_invoice_piecerates2(invoice_id,atype,prd_date,prt_code,prd_quantity,cost,rate,rownum)
            select invoice_id,prs_description,piece_rate_delivery.prd_date,
              piece_rate_type.prt_code,
              piece_rate_delivery.prd_quantity,
              piece_rate_delivery.prd_cost,
              rate=prd_cost/prd_quantity,
              row_number() over (order by invoice_id asc)
		      from
              rd.piece_rate_type,
              rd.piece_rate_delivery,
              payment,
              rd.piece_rate_supplier where
              (piece_rate_delivery.prt_key = piece_rate_type.prt_key) and
              (piece_rate_delivery.prd_paid_to_date = payment.invoice_date) and
              (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
              (piece_rate_supplier.prs_key = 2) and
              (payment.invoice_date = @indate) and
              (payment.contract_no = @lcontract) and
              (payment.invoice_id = @linvoice) and
              (payment.contract_no = piece_rate_delivery.contract_no)
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-100001102)
            end
          insert into t_invoice_piecerates3(invoice_id,atype,prd_date,prt_code,prd_quantity,cost,rate,rownum)
            select invoice_id,prs_description,piece_rate_delivery.prd_date,
              piece_rate_type.prt_code,
              piece_rate_delivery.prd_quantity,
              piece_rate_delivery.prd_cost,
              rate=prd_cost/prd_quantity,
              row_number() over (order by invoice_id asc)
		      from
              rd.piece_rate_type,
              rd.piece_rate_delivery,
              payment,
              rd.piece_rate_supplier where
              (piece_rate_delivery.prt_key = piece_rate_type.prt_key) and
              (piece_rate_delivery.prd_paid_to_date = payment.invoice_date) and
              (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
              (piece_rate_supplier.prs_key = 3) and
              (payment.invoice_date = @indate) and
              (payment.contract_no = @lcontract) and
              (payment.invoice_id = @linvoice) and
              (payment.contract_no = piece_rate_delivery.contract_no)
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-100001112)
            end
        end
      close vc_contract_list
      commit transaction
    end
  return(0)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_Invoice_pay_piecerate_detailcp : 
--

CREATE procedure [odps].[OD_RPS_Invoice_pay_piecerate_detailcp](@invoiceid int,@contractno int,@contractorno int,@payperiod_start datetime,@payperiod_end datetime)
as
begin
  declare @v_contract_no int,
  @v_cr_effective_date datetime,
  @v_contractor_start datetime,
  @v_contractor_end datetime
  --Cursor retrieves contractor start and end dates
  -- SR#4465 PBY 18-01-2003 Subselect will returns multiple rows if there are more than 1 contractors
  -- within the same renewal period.  Added a MIN function to always retrieve the oldest
  -- next contractor''s contract start date
  --
  -- TJB  SR4667  June05
  -- Fix bug where these dates weren''t selected when a contractor had two contracts
  -- with different sequence numbers, and the one being searched for wasn''t the max() one.
  -- Dropped use of cursor (see the select below the 'fetch').
  --
  --Find out if there are more than one contractors in the payperiod
  select @v_contract_no = count(contract_no)
    from odps.payment where
    contract_no = @contractno and
    payment.POTS = 'N' and
    invoice_date = @payperiod_end
  --If there are more than one contract then the contract has changed hands, go in here
  if @v_contract_no > 1
    begin
      -- open vc_contract_list;
      -- fetch next vc_contract_list into v_contractor_start,v_contractor_end;
      select @v_contractor_start= 
        (select rd.date(MIN(cr.cr_effective_date)-1) from
          rd.contractor_renewals as cr where
          cr.contract_no = contract.contract_no and
          cr.contract_seq_number = contract.con_active_sequence and
          cr.cr_effective_date > contractor_renewals.cr_effective_date)
        from rd.contract,
        rd.contractor_renewals where
        contract.contract_no = @contractno and
        contractor_renewals.contract_no = contract.contract_no and
        contractor_renewals.contractor_supplier_no = @contractorno and
        contractor_renewals.contract_seq_number = 
        (select max(cr2.contract_seq_number) from
          rd.contractor_renewals as cr2 where
          cr2.contract_no = @contractno and
          cr2.contractor_supplier_no = @contractorno) and
        (contract.con_date_terminated is null or
        contract.con_date_terminated > @payperiod_end or
        (contract.con_date_terminated - @payperiod_start) < 32 or
        contract.con_date_terminated between @payperiod_start and @payperiod_end) order by
        contractor_renewals.cr_effective_date asc
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-8)
        end
      if @v_contractor_end is null
        select @v_contractor_end=rd.date(rd.today()+30)
      select t_invoice_piecerates2.invoice_id,
        t_invoice_piecerates2.prd_date,
        t_invoice_piecerates2.prt_code,
        t_invoice_piecerates2.prd_quantity,
        t_invoice_piecerates2.rate,
        t_invoice_piecerates2.cost from
        t_invoice_piecerates2 where
        t_invoice_piecerates2.invoice_id = @invoiceid and
        t_invoice_piecerates2.prd_date between @v_contractor_start and @v_contractor_end order by
        t_invoice_piecerates2.prd_date asc,
        t_invoice_piecerates2.prt_code asc
    end
  else
    select t_invoice_piecerates2.invoice_id,
      t_invoice_piecerates2.prd_date,
      t_invoice_piecerates2.prt_code,
      t_invoice_piecerates2.prd_quantity,
      t_invoice_piecerates2.rate,
      t_invoice_piecerates2.cost from
      t_invoice_piecerates2 where
      t_invoice_piecerates2.invoice_id = @invoiceid order by
      t_invoice_piecerates2.prd_date asc,
      t_invoice_piecerates2.prt_code asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetExtnData : 
--

CREATE procedure [rd].[sp_GetExtnData](@in_contract int)
as
begin
  declare @nWageHourlyRate decimal(10,2)
  declare @nRepairsMaint decimal(10,2)
  declare @nTyreTubes decimal(10,2)
  declare @nVehicalAllow decimal(10,2)
  declare @nACCRate decimal(10,2)
  declare @nItemsHour decimal(10,2)
  declare @nFuel decimal(10,2)
  declare @nConsumption decimal(10,2)
  declare @dStartDate datetime
  declare @nSequenceNo int
  declare @nCounter int
  select @dStartDate=con_start_date,@nSequenceNo=contract_seq_number 
  from contract_renewals 
  where contract_renewals.contract_no = @in_Contract and
    contract_renewals.contract_seq_number = (select max(contract_seq_number) from
      contract_renewals where contract_no = @in_Contract)
  select @nWageHourlyRate=isnull(contract_rates.rr_wage_hourly_rate,renewal_rate.rr_wage_hourly_rate),
    @nRepairsMaint=isnull(contract_rates.rr_repairs_maintenance_rate,renewal_rate.rr_repairs_maintenance_rate),
    @nTyreTubes=isnull(contract_rates.rr_tyre_tubes_rate,renewal_rate.rr_tyre_tubes_rate),
    @nVehicalAllow=isnull(contract_rates.rr_vehical_allowance_rate,renewal_rate.rr_vehical_allowance_rate),
    @nACCRate=isnull(contract_rates.rr_acc_rate,renewal_rate.rr_acc_rate),
    @nItemsHour=isnull(contract_rates.rr_item_proc_rate_per_hour,renewal_rate.rr_item_proc_rate_per_hr),
    @nFuel=isnull(contract_rates.rr_fuel_rate,fuel_rates.fr_fuel_rate),
    @nConsumption=isnull(contract_rates.rr_consumption_rate,fuel_rates.fr_fuel_consumtion_rate)
  from contract_renewals 
    left outer join contract_rates on
    contract_renewals.contract_no = contract_rates.contract_no and
    contract_renewals.contract_seq_number = contract_rates.contract_seq_number 
    join renewal_rate on
    contract_renewals.con_rg_code_at_renewal = renewal_rate.rg_code and
    contract_renewals.con_rates_effective_date = renewal_rate.rr_rates_effective_date 
    join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A'
    join vehicle on
    contract_vehical.vehicle_number = vehicle.vehicle_number
    join fuel_type on
    vehicle.ft_key = fuel_type.ft_key
    join fuel_rates on
    fuel_type.ft_key = fuel_rates.ft_key where
    fuel_rates.rg_code = renewal_rate.rg_code and
    fuel_rates.rr_rates_effective_date = renewal_rate.rr_rates_effective_date and
    contract_renewals.contract_no = @in_contract and
    contract_renewals.contract_seq_number = @nSequenceNo
  select @nCounter=count(*) from frequency_distances 
  where contract_no = @in_contract and
    frequency_distances.fd_effective_date >= @dStartDate and
    @dStartDate is not null
  if @nCounter > 0
    select contract.contract_no,
      contract.con_title,
      num_rows=count(*),
      distance=(sum(isnull(contract_renewals.con_distance_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum),
      boxes=(sum(isnull(contract_renewals.con_no_customers_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_of_boxes,0)),
      rural_bags=(sum(isnull(contract_renewals.con_no_rural_private_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_rural_bags,0)),
      other_bags=(sum(isnull(contract_renewals.con_no_other_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_other_bags,0)),
      private_bags=(sum(isnull(contract_renewals.con_no_private_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_private_bags,0)),
      post_offices=(sum(isnull(contract_renewals.con_no_post_offices_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_post_offices,0)),
      no_cmbs=(sum(isnull(contract_renewals.con_no_cmbs_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_cmbs,0)),
      no_cmb_customers=(sum(isnull(contract_renewals.con_no_cmb_custs_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_cmb_customers,0)),
      del_hrs=(sum(isnull(contract_renewals.con_del_hrs_week_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
      proc_hrs=(sum(isnull(contract_renewals.con_processing_hours_per_week,0))/count(*))+
      sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
      mail_volume=(sum(isnull(contract_renewals.con_volume_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_volume,0)),
      extn_effective_date=rd.today(),
      extn_distance=0,
      extn_boxes=0,
      extn_rural_bags=0,
      extn_other_bags=0,
      extn_private_bags=0,
      extn_post_offices=0,
      extn_no_cmbs=0,
      extn_no_cmb_customers=0,
      extn_del_hrs=0,
      extn_proc_hrs=0,
      extn_mail_volume=0,
      extn_reason=space(250),
      no_del_days_year=0,
      @nWageHourlyRate,
      @nRepairsMaint,
      @nTyreTubes,
      @nVehicalAllow,
      @nACCRate,
      rr_item_proc_rate_per_hr=@nItemsHour,
      @nFuel,
      @nConsumption,0 
    from contract 
      join contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number 
      join frequency_distances on
      (contract_renewals.contract_no = frequency_distances.contract_no and
      frequency_distances.fd_effective_date >= @dStartDate and @dStartDate is not null)--,0),
      join  standard_frequency on
      frequency_distances.sf_key = standard_frequency.sf_key
      join rate_days on
      standard_frequency.sf_key = rate_days.sf_key 
    where contract.contract_no = @in_contract and
      rate_days.rg_code = contract_renewals.con_rg_code_at_renewal and
      rate_days.rr_rates_effective_date = contract_renewals.con_rates_effective_date
      group by contract.contract_no,contract.con_title--,rr_item_proc_rate_per_hr
  else
    select contract.contract_no,
      contract.con_title,
      1,
      isnull(contract_renewals.con_distance_at_renewal,0),
      isnull(contract_renewals.con_no_customers_at_renewal,0),
      isnull(contract_renewals.con_no_rural_private_bags_at_renewal,0),
      isnull(contract_renewals.con_no_other_bags_at_renewal,0),
      isnull(contract_renewals.con_no_private_bags_at_renewal,0),
      isnull(contract_renewals.con_no_post_offices_at_renewal,0),
      isnull(contract_renewals.con_no_cmbs_at_renewal,0),
      isnull(contract_renewals.con_no_cmb_custs_at_renewal,0),
      isnull(contract_renewals.con_del_hrs_week_at_renewal,0),
      isnull(contract_renewals.con_processing_hours_per_week,0),
      isnull(contract_renewals.con_volume_at_renewal,0),
      extn_effective_date=rd.today(),
      extn_distance=0,
      extn_boxes=0,
      extn_rural_bags=0,
      extn_other_bags=0,
      extn_private_bags=0,
      extn_post_offices=0,
      extn_no_cmbs=0,
      extn_no_cmb_customers=0,
      extn_del_hrs=0,
      extn_proc_hrs=0,
      extn_mail_volume=0,
      extn_reason=space(250),
      no_del_days_year=0,
      @nWageHourlyRate,
      @nRepairsMaint,
      @nTyreTubes,
      @nVehicalAllow,
      @nACCRate,
      rr_item_proc_rate_per_hr=@nItemsHour,
      @nFuel,
      @nConsumption,0 
    from contract 
      join  contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number 
    where contract.contract_no = @in_contract
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetExtnDatav2 : 
--

CREATE procedure [rd].[sp_GetExtnDatav2](@in_contract int) 
as
begin
  declare @nWageHourlyRate numeric(10,2)
  declare @nRepairsMaint numeric(10,2)
  declare @nTyreTubes numeric(10,2)
  declare @nVehicalAllow numeric(10,2)
  declare @nACCRate numeric(10,2)
  declare @nItemsHour numeric(10,2)
 declare  @nRUC numeric(8,2)
  declare @nFuel numeric(10,2)
  declare @nConsumption numeric(10,2)
 declare  @dStartDate datetime
  declare @nSequenceNo int
  declare @nCounter int
  select @dStartDate=con_start_date,@nSequenceNo=contract_seq_number 
  from contract_renewals where
    contract_renewals.contract_no = @in_Contract and
    contract_renewals.contract_seq_number = (select max(contract_seq_number) from
      contract_renewals where
      contract_no = @in_Contract)
  select @nWageHourlyRate=isnull(contract_rates.rr_wage_hourly_rate,renewal_rate.rr_wage_hourly_rate),
    @nRepairsMaint=isnull(contract_rates.rr_repairs_maintenance_rate,renewal_rate.rr_repairs_maintenance_rate),
    @nTyreTubes=isnull(contract_rates.rr_tyre_tubes_rate,renewal_rate.rr_tyre_tubes_rate),
    @nVehicalAllow=isnull(contract_rates.rr_vehical_allowance_rate,renewal_rate.rr_vehical_allowance_rate),
    @nACCRate=isnull(contract_rates.rr_acc_rate,renewal_rate.rr_acc_rate),
    @nItemsHour=isnull(contract_rates.rr_item_proc_rate_per_hour,renewal_rate.rr_item_proc_rate_per_hr),
    @nFuel=isnull(contract_rates.rr_fuel_rate,fuel_rates.fr_fuel_rate),
    @nConsumption=isnull(contract_rates.rr_consumption_rate,fuel_rates.fr_fuel_consumtion_rate),
    @nRuc=isnull(contract_rates.rr_RUC,renewal_rate.rr_RUC)
  from contract_renewals 
    left outer join contract_rates on
    contract_renewals.contract_no = contract_rates.contract_no and
    contract_renewals.contract_seq_number = contract_rates.contract_seq_number 
    join renewal_rate on
    contract_renewals.con_rg_code_at_renewal = renewal_rate.rg_code and
    contract_renewals.con_rates_effective_date = renewal_rate.rr_rates_effective_date 
    join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A'
    join vehicle on
    contract_vehical.vehicle_number = vehicle.vehicle_number
    join fuel_type on
    vehicle.ft_key = fuel_type.ft_key
    join fuel_rates on
    fuel_type.ft_key = fuel_rates.ft_key 
  where
    fuel_rates.rg_code = renewal_rate.rg_code and
    fuel_rates.rr_rates_effective_date = renewal_rate.rr_rates_effective_date and
    contract_renewals.contract_no = @in_contract and
    contract_renewals.contract_seq_number = @nSequenceNo
  select @nCounter= count(*) from frequency_distances 
  where contract_no = @in_contract and
    frequency_distances.fd_effective_date >= @dStartDate and
    @dStartDate is not null
  if @nCounter > 0
    select contract.contract_no,
      contract.con_title,
      num_rows=count(*),
      distance=(sum(isnull(contract_renewals.con_distance_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum),
      boxes=(sum(isnull(contract_renewals.con_no_customers_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_of_boxes,0)),
      rural_bags=(sum(isnull(contract_renewals.con_no_rural_private_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_rural_bags,0)),
      other_bags=(sum(isnull(contract_renewals.con_no_other_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_other_bags,0)),
      private_bags=(sum(isnull(contract_renewals.con_no_private_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_private_bags,0)),
      post_offices=(sum(isnull(contract_renewals.con_no_post_offices_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_post_offices,0)),
      no_cmbs=(sum(isnull(contract_renewals.con_no_cmbs_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_cmbs,0)),
      no_cmb_customers=(sum(isnull(contract_renewals.con_no_cmb_custs_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_cmb_customers,0)),
      del_hrs=(sum(isnull(contract_renewals.con_del_hrs_week_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
      proc_hrs=(sum(isnull(contract_renewals.con_processing_hours_per_week,0))/count(*))+
      sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
      mail_volume=(sum(isnull(contract_renewals.con_volume_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_volume,0)),
      extn_effective_date=rd.today(),
      extn_distance=0,
      extn_boxes=0,
      extn_rural_bags=0,
      extn_other_bags=0,
      extn_private_bags=0,
      extn_post_offices=0,
      extn_no_cmbs=0,
      extn_no_cmb_customers=0,
      extn_del_hrs=0,
      extn_proc_hrs=0,
      extn_mail_volume=0,
      extn_reason=space(250),
      no_del_days_year=0,
      @nWageHourlyRate,
      @nRepairsMaint,
      @nTyreTubes,
      @nVehicalAllow,
      @nACCRate,
      rr_item_proc_rate_per_hr=@nItemsHour,
      @nFuel,
      @nConsumption,0,@nRUC
    from  contract 
      join contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number 
      join frequency_distances on
      (contract_renewals.contract_no = frequency_distances.contract_no and
      frequency_distances.fd_effective_date >= @dStartDate and
      @dStartDate is not null)--,0),
      join standard_frequency on
      frequency_distances.sf_key = standard_frequency.sf_key
      join rate_days on
      standard_frequency.sf_key = rate_days.sf_key 
    where
      contract.contract_no = @in_contract and
      rate_days.rg_code = contract_renewals.con_rg_code_at_renewal and
      rate_days.rr_rates_effective_date = contract_renewals.con_rates_effective_date
      group by contract.contract_no,contract.con_title--,rr_item_proc_rate_per_hr
  else
    select contract.contract_no,
      contract.con_title,
      1,
      isnull(contract_renewals.con_distance_at_renewal,0),
      isnull(contract_renewals.con_no_customers_at_renewal,0),
      isnull(contract_renewals.con_no_rural_private_bags_at_renewal,0),
      isnull(contract_renewals.con_no_other_bags_at_renewal,0),
      isnull(contract_renewals.con_no_private_bags_at_renewal,0),
      isnull(contract_renewals.con_no_post_offices_at_renewal,0),
      isnull(contract_renewals.con_no_cmbs_at_renewal,0),
      isnull(contract_renewals.con_no_cmb_custs_at_renewal,0),
      isnull(contract_renewals.con_del_hrs_week_at_renewal,0),
      isnull(contract_renewals.con_processing_hours_per_week,0),
      isnull(contract_renewals.con_volume_at_renewal,0),
      extn_effective_date=rd.today(),
      extn_distance=0,
      extn_boxes=0,
      extn_rural_bags=0,
      extn_other_bags=0,
      extn_private_bags=0,
      extn_post_offices=0,
      extn_no_cmbs=0,
      extn_no_cmb_customers=0,
      extn_del_hrs=0,
      extn_proc_hrs=0,
      extn_mail_volume=0,
      extn_reason=space(250),
      no_del_days_year=0,
      @nWageHourlyRate,
      @nRepairsMaint,
      @nTyreTubes,
      @nVehicalAllow,
      @nACCRate,
      rr_item_proc_rate_per_hr=@nItemsHour,
      @nFuel,
      @nConsumption,0,@nRUC from
      contract join
      contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number where
      contract.contract_no = @in_contract
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_Invoice_pay_piecerate_detailpp : 
--

CREATE procedure [odps].[OD_RPS_Invoice_pay_piecerate_detailpp](@invoiceid int,@contractno int,@contractorno int,@payperiod_start datetime,@payperiod_end datetime)
-- TJB  SR4684  June/2006    -- New --
as -- Adapted from OD_RPS_Invoice_pay_piecerate_detailxp
begin
  declare @v_contract_no int,
  @v_cr_effective_date datetime,
  @v_contractor_start datetime,
  @v_contractor_end datetime
  --Cursor retrieves contractor start and end dates
  -- SR#4465 PBY 18-01-2003 Subselect will returns multiple rows if there are more than 1 contractors
  -- within the same renewal period.  Added a MIN function to always retrieve the oldest
  -- next contractor''s contract start date
  -- TJB  SR4667  June05
  -- Fix bug where these dates weren''t selected when a contractor had two contracts
  -- with different sequence numbers, and the one being searched for wasn''t the max() one.
  -- Dropped use of cursor (see the select below the 'fetch').
  --  declare vc_contract_list dynamic scroll cursor for 
  --Find out if there are more than one contractors in the payperiod
  select @v_contract_no=count(contract_no) 
    from odps.payment where
    contract_no = @contractno and
    payment.POTS = 'N' and
    invoice_date = @payperiod_end
  --If there are more than one contract then the contract has changed hands, go in here
  if @v_contract_no > 1
    begin
      -- open vc_contract_list;
      -- fetch next vc_contract_list into v_contractor_start,v_contractor_end;
      select @v_contractor_start=
        (select rd.date(MIN(cr.cr_effective_date)-1) from
          rd.contractor_renewals as cr where
          cr.contract_no = contract.contract_no and
          cr.contract_seq_number = contract.con_active_sequence and
          cr.cr_effective_date > contractor_renewals.cr_effective_date) 
         from rd.contract,
        rd.contractor_renewals where
        contract.contract_no = @contractno and
        contractor_renewals.contractor_supplier_no = @contractorno and
        contractor_renewals.contract_no = contract.contract_no and
        contractor_renewals.contract_seq_number = 
        (select max(cr2.contract_seq_number) from
          rd.contractor_renewals as cr2 where
          cr2.contract_no = @contractno and
          cr2.contractor_supplier_no = @contractorno) and
        (contract.con_date_terminated is null or
        contract.con_date_terminated > @payperiod_end or
        datediff(day,contract.con_date_terminated,@payperiod_start) < 32 or
        contract.con_date_terminated between @payperiod_start and @payperiod_end) order by
        contractor_renewals.cr_effective_date asc
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-8)
        end
      if @v_contractor_end is null
        select @v_contractor_end=rd.date(rd.today()+30)
      select tip4.invoice_id,
        tip4.prd_date,
        tip4.prt_code,
        tip4.prd_quantity,
        tip4.rate,
        tip4.cost from
        t_invoice_piecerates4 as tip4 where
        tip4.invoice_id = @invoiceid and
        tip4.prd_date between @v_contractor_start and @v_contractor_end order by
        tip4.prd_date asc,
        tip4.prt_code asc
    end
  else
    select tip4.invoice_id,
      tip4.prd_date,
      tip4.prt_code,
      tip4.prd_quantity,
      tip4.rate,
      tip4.cost from
      t_invoice_piecerates4 as tip4 where
      tip4.invoice_id = @invoiceid order by
      tip4.prd_date asc,
      tip4.prt_code asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_RptMailCarried : 
--

CREATE procedure [rd].[sp_RptMailCarried](@inContract int,@inSequence int)
as
begin
  select contract_renewals.contract_no,
    contract_renewals.contract_seq_number,
    contract.con_title,
    contract_renewals.con_start_date,
    contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_initials,
    standard_frequency.sf_description,
    mail_carried.rf_delivery_days,
    mail_carried.mc_dispatch_carried,
    uplift_outlet_name=uplift_outlet.o_name,
    mail_carried.mc_uplift_time,
    set_down_outlet_name=set_down_outlet.o_name,
    mail_carried.mc_set_down_time,
    region.rgn_name,
    outlet.o_name,
    contract.con_rd_ref_text from
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id join
    contract_renewals on
    contract.contract_no = contract_renewals.contract_no and
    contract_renewals.contract_seq_number = @inSequence left outer join
    mail_carried on
    contract.contract_no = mail_carried.contract_no and
    mail_carried.mc_disbanded_date is null
	join region on
    outlet.region_id = region.region_id
	join contractor_renewals on
    contract_renewals.contract_no = contractor_renewals.contract_no and
    contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number and
    contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date
	 join contractor on
    contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no
	 left outer join
    standard_frequency on
    mail_carried.sf_key = standard_frequency.sf_key left outer join
    outlet as uplift_outlet on
    mail_carried.mc_uplift_outlet = uplift_outlet.outlet_id left outer join
    outlet as set_down_outlet on
/*    contract join
    outlet as o on
    contract.con_base_office = o.outlet_id join
    contract_renewals as cr on
    contract.contract_no = cr.contract_no and
    cr.contract_seq_number = @inSequence left outer join
    mail_carried as mc on
    contract.contract_no = mc.contract_no and
    mc.mc_disbanded_date is null,
    outlet join
    region on
    outlet.region_id = region.region_id,
    contract_renewals join
    contractor_renewals as crr on
    contract_renewals.contract_no = crr.contract_no and
    contract_renewals.contract_seq_number = crr.contract_seq_number and
    contract_renewals.con_date_last_assigned = crr.cr_effective_date,
    contractor_renewals join
    contractor on
    contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no,
    mail_carried left outer join
    standard_frequency on
    mail_carried.sf_key = standard_frequency.sf_key left outer join
    outlet as uplift_outlet on
    mail_carried.mc_uplift_outlet = uplift_outlet.outlet_id left outer join
    outlet as set_down_outlet on
*/
    mail_carried.mc_set_down_outlet = set_down_outlet.outlet_id where
    contract.contract_no = @inContract order by
    standard_frequency.sf_description asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_DDDW_Regions : 
--

CREATE procedure [odps].[sp_DDDW_Regions]
as
begin
  select region_id,
    rgn_name from
    rd.region union
  select 0,''   order by
    2 asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_Regions : 
--

CREATE procedure [rd].[sp_DDDW_Regions]
as
begin
  select region_id,
    rgn_name from
    rd.region union
  select 0,'' order by
    2 asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRegions : 
--

CREATE procedure [rd].[sp_GetRegions]
as
begin
  select region_id,
    rgn_name from
    region
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_rb_Regions : 
--

CREATE procedure [rd].[sp_DDDW_rb_Regions](@ri int)
as
begin
  select region_id,rgn_name from
    region where
    ((region_id = @ri and @ri is not null and @ri <> -1) or
    (@ri = -1)) order by
    2 asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_summary_cust_list_hdr : 
--

CREATE procedure [rd].[sp_summary_cust_list_hdr](@in_contract_no int,@in_sf_key int,@in_rd_del_days char(7),@in_sortorder char(1))
-- TJB  SR4664  July 2005  - new
-- Replaces the select in r_summary_customer_listing datawindow
-- Dropped use of v_customers view (huge performance improvement)
-- and added union to append unsequenced customers.
-- This is one of three: this one generates the heading details
-- The others are:
--          sp_summary_cust_list_seq
--          sp_summary_cust_list_unseq
-----------------------------------------------------------------
-- TJB Release 6.8.9 fixup  Nov 2005
-- Added sort order parameter; there is only ever one result set 
-- returned, so they/it doesn''t need to be sorted.  The parameter
as -- is for consistency with the others.
begin
  declare @l_contract_seq_number integer,
  @l_effective_date datetime,
  @l_c_title char(12),
  @l_c_surname_company char(40),
  @l_c_first_names char(40),
  @l_c_initials char(40)
  select @l_contract_seq_number=max(contract_seq_number)  
    from contract_renewals where
    contract_no = @in_contract_no
  select @l_effective_date=max(cr_effective_date)  
    from contractor_renewals where
    contract_no = @in_contract_no
  select @l_c_title=contractor.c_title,
    @l_c_surname_company=contractor.c_surname_company,
    @l_c_first_names=contractor.c_first_names,
    @l_c_initials=contractor.c_initials
     from contractor,
    contractor_renewals where
    contractor_renewals.contract_no = @in_contract_no and
    contractor_renewals.contract_seq_number = @l_contract_seq_number and
    contractor_renewals.cr_effective_date = @l_effective_date and
    contractor.contractor_supplier_no = contractor_renewals.contractor_supplier_no
  select @in_contract_no,
    @l_contract_seq_number,
    contract.con_title,
    contract.con_rd_ref_text,
    @l_c_title,
    @l_c_surname_company,
    @l_c_first_names,
    @l_c_initials,
    outlet.o_name,
    region.rgn_name,
    @in_sf_key,
    @in_rd_del_days,
    standard_frequency.sf_description from
    contract,
    outlet,
    region,
    standard_frequency,
    route_frequency where
    route_frequency.contract_no = @in_contract_no and
    route_frequency.sf_key = @in_sf_key and
    route_frequency.rf_delivery_days = @in_rd_del_days and
    outlet.outlet_id = contract.con_lodgement_office and
    region.region_id = outlet.region_id and
    standard_frequency.sf_key = @in_sf_key and
    contract.contract_no = @in_contract_no
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function GetDailyDistForOutlet : 
--

CREATE function [rd].[GetDailyDistForOutlet](@inOutlet int)
returns decimal(10,2)
as
begin
  --declare
  /* Watcom only
  err_notfound exception for sqlstate value '02000'
  */
  declare cur_getdistance cursor for select sum(rou.rf_distance*
      rate_days.rtd_days_per_annum)/
      max(rate_days.rtd_days_per_annum) from
      contract join
      outlet on
      contract.con_base_office = outlet.outlet_id and
      outlet.outlet_id = @inOutlet join
      contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number join
      route_frequency as rou on
      contract.contract_no = rou.contract_no and
      rou.rf_active = 'Y'join
      rate_days on
      rou.sf_key = rate_days.sf_key
		join
      region on
      outlet.region_id = region.region_id where
      contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
      contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
      contract.contract_no = 
      any(select types_for_contract.contract_no from
        types_for_contract join
        contract_type on types_for_contract.ct_key = contract_type.ct_key where
        contract_type.ct_rd_ref_mandatory = 'Y')
      group by contract.contract_no,contract_renewals.contract_seq_number
 declare @dDailyDistance decimal(10,2),
  @dTotalDailyDistance decimal(10,2)
  select @dTotalDailyDistance=0
  open cur_getdistance
  /* Watcom only
  CursorLoop:
  */while 1=1 
    begin
      fetch next from cur_GetDistance into @dDailyDistance
      if @@fetch_status <0
        break
        /* Watcom only
        CursorLoop
        */
      if @dDailyDistance is not null
        select @dTotalDailyDistance=@dTotalDailyDistance+@dDailyDistance
    end
  close cur_GetDistance
  return @dTotalDailyDistance
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_out_val_list : 
--

CREATE procedure [rd].[sp_out_val_list]
-- TWC - 05/09/2003 
-- This is a new procedure to populate the "Outstanding Validation Lists" report
-- For now this takes no arguments and returns all contracts 
-- TJB  SR4657  June05
-- Added conditions:  newest renewal date, contract not terminated
as -- Fixed selection updated < printed
begin
  declare @current_date datetime
  declare @period integer
  select @current_date=getdate()
  select @period=30
  select reg.rgn_name,
    con.contract_no,
    isnull(ct.c_first_names,'')+' '+ct.c_surname_company,
    ct.c_phone_day,
    ct.c_phone_night,
    ct.c_mobile,
    con.cust_list_printed,
    con.cust_list_updated from
    region as reg join outlet as "out" on reg.region_id=out.region_id join contract as con on
    ("out".outlet_id = con.con_base_office),
    contractor_renewals as cr join contractor as ct on cr.contractor_supplier_no=ct.contractor_supplier_no where
    cr.contract_no = con.contract_no and
    cr.contract_seq_number = con.con_active_sequence and
    cr.cr_effective_date = (select max(cr_effective_date) from contractor_renewals as cr2 where
      cr2.contract_no = cr.contract_no and
      cr2.contract_seq_number = cr.contract_seq_number and
      cr_effective_date <= getdate()) and
    con.con_date_terminated is null and
    con.cust_list_printed is not null and
    con.cust_list_printed < dateadd(day,-30,@current_date) and
    (con.cust_list_updated is null or
    con.cust_list_updated < con.cust_list_printed)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_Pay_Summary : 
--

CREATE procedure  [odps].[OD_RPS_Pay_Summary](@sdate datetime,@edate datetime,@inregion int)
as
begin
  -- TJB  SR4684  20-June-2006
  -- Split SkyRoad out of contract_adjustments and added as a separately-returned value
  -- Added ParcelPost
  --
  -- 18/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
  -- sql code.  Used the corresponding payment_component_type.prs_key instead.
  -- Note:
  --	Kiwimail	1
  --	CourierPost	2
  --	XP (Skytrain)	3
  --	ParcelPost	4
  select distinct region=(select rgn_name from
      rd.region where
      region.region_id = outlet.region_id),
    contract_no=contract.contract_no,
    name=c_surname_company+case when c_initials is null then '' else ', '+c_initials end,
    m_standard=(select isnull(sum(pc_amount),0) from
       odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      (((payment_component_type.pct_description like 'Contract payment value%' or
      payment_component_type.pct_description like 'Frequency Adjustment%') and
      left(payment_component.comments,6) <> 'Arrear') and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))),
    m_allowance=(select isnull(sum(pc_amount),0) from
      odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Contract allowance%' and
      left(payment_component.comments,6) <> 'Arrear') and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))),
    m_extension=(select isnull(sum(pc_amount),0) from
      odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      ((left(payment_component.comments,6) = 'Arrear') and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))),
    m_contract_adjustment=(select isnull(sum(pc_amount),0) from
      odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Contract Adjustment%' and
      left(payment_component.comments,6) <> 'Arrear') and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))),
    m_Adpost=(select isnull(sum(pc_amount),0) from
      odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.prs_key = 1) and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))),
    m_CourierPost=(select isnull(sum(pc_amount),0) from
      odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.prs_key = 2) and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))),
    m_GST_value=(select isnull(sum(pc_amount*-1),0) from
      odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'GST%') and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))),
    m_wtax_value=(select isnull(sum(pc_amount*-1),0) from
      odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Withholding Tax%') and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))),
    m_adj_notax=(select isnull(sum(pc_amount*-1),0) from
      odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Post-Tax Adjustments%') and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))),
    contract_type=contract_type.contract_type,
    m_ParcelPost=(select isnull(sum(pc_amount),0) from
      odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.prs_key = 4) and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))),
    m_SkyRoad=(select isnull(sum(pc_amount),0) from
      odps.Payment INNER JOIN
       odps.Payment_Component ON odps.Payment.Invoice_ID = odps.Payment_Component.Invoice_ID INNER JOIN
       odps.Payment_Component_Type ON odps.Payment_Component.pct_id = odps.Payment_Component_Type.pct_id where
      (payment.invoice_date between @sdate and @edate) and
--      (payment_component.invoice_id = payment.invoice_id) and
--      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.prs_key = 3) and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number))) from
     rd.contract INNER JOIN
     rd.outlet ON contract.con_base_office = outlet.outlet_id INNER JOIN
     rd.contractor_renewals ON contract.contract_no = contractor_renewals.contract_no INNER JOIN
     rd.contractor ON (contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no) INNER JOIN
     rd.contract_type ON (contract.con_base_cont_type = contract_type.ct_key) where
--    (contract.con_base_office = outlet.outlet_id) and
--    (contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no) and
--    (contract.contract_no = contractor_renewals.contract_no) and
--    (contract.con_base_cont_type = contract_type.ct_key) and
    ((outlet.region_id = @inregion and @inregion > 0) or(@inregion = 0)) and
    exists(select payment.contractor_supplier_no from
      payment where
      (payment.contract_no = contractor_renewals.contract_no) and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no) and
      (payment.contract_seq_number = contractor_renewals.contract_seq_number) and
      (payment.invoice_date between @sdate and @edate))
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*
ALTER procedure rd.sp_GetRdsUserGroup(@AL_PARENT_ID1 int)
as
begin
  select LABEL=RDS_USER_GROUP.UG_NAME,ID=RDS_USER_GROUP.UG_ID,ACCOUNT=RDS_USER_GROUP.UG_ID,PARENT_ID1=@AL_PARENT_ID1,
    PICTINDEX=2 from RDS_USER_GROUP where @AL_PARENT_ID1 = 1 union select LABEL=RDS_USER.U_NAME,
    ID=RDS_USER_ID.UI_ID,ACCOUNT=RDS_USER.U_ID,PARENT_ID1=@AL_PARENT_ID1,PICTINDEX=3 from RDS_USER,
    RDS_USER_ID where @AL_PARENT_ID1 = 2 and RDS_USER.U_ID = RDS_USER_ID.U_ID union select LABEL=RDS_MAINTENANCE_TABLE.MT_NAME,
    ID=RDS_MAINTENANCE_TABLE.MT_ID,ACCOUNT=0,PARENT_ID1=@AL_PARENT_ID1,PICTINDEX=5 from
    RDS_MAINTENANCE_TABLE where @AL_PARENT_ID1 = 3
end
*/
CREATE procedure [rd].[sp_GetRdsUserInfo](@AL_PARENT_ID1 int,@AL_PARENT_ID2 int)
as
begin
  select LABEL=RDS_USER.U_NAME,ID=RDS_USER_ID.UI_ID,ACCOUNT=RDS_USER.U_ID,PARENT_ID1=@AL_PARENT_ID1,
    PARENT_ID2=@AL_PARENT_ID2,PICTINDEX=3 from RDS_USER,RDS_USER_GROUP,RDS_USER_ID,RDS_USER_ID_GROUP where
    (RDS_USER_ID.U_ID = RDS_USER.U_ID) and(RDS_USER_ID_GROUP.UI_ID = RDS_USER_ID.UI_ID) and
    (RDS_USER_ID_GROUP.UG_ID = RDS_USER_GROUP.UG_ID) and((RDS_USER_GROUP.UG_ID = @AL_PARENT_ID1) and(@AL_PARENT_ID2 = 1)) union
  select RDS_USER_GROUP.UG_NAME,RDS_USER_GROUP.UG_ID,0,@AL_PARENT_ID1,@AL_PARENT_ID2,PICTINDEX=2 from
    RDS_USER,RDS_USER_GROUP,RDS_USER_ID,RDS_USER_ID_GROUP where(RDS_USER_ID.U_ID = RDS_USER.U_ID) and
    (RDS_USER_ID_GROUP.UI_ID = RDS_USER_ID.UI_ID) and(RDS_USER_ID_GROUP.UG_ID = RDS_USER_GROUP.UG_ID) and
    ((RDS_USER_ID_GROUP.UI_ID = @AL_PARENT_ID1) and(@AL_PARENT_ID2 = 2)) union select REGION.RGN_NAME,REGION.REGION_ID,
    0,@AL_PARENT_ID1,@AL_PARENT_ID2,PICTINDEX=2 from REGION where @AL_PARENT_ID2 = 3 and @AL_PARENT_ID1 = 1
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_ContractSummaryDetails : 
--

CREATE procedure [rd].[sp_ContractSummaryDetails](@inContract int,@inSequence int)
-- TJB  SR4657  June05
as -- Changed source of lastdate returned value
begin
  select contract.contract_no,
    contract.con_old_mail_service_no,
    contract.con_title,
    contract_renewals.con_renewal_payment_value,
    region.rgn_name,
    region.rgn_rcm_manager,
    region.rgn_telephone,
    outlet_a.o_name,
    contract_renewals.con_start_date,
    contract_renewals.con_expiry_date,
    contract.con_last_work_msrmnt_check,
    contract.con_last_delivery_check,
    ext_amt=(select sum(fa.fd_adjustment_amount) from rd.contract_renewals as cr,rd.frequency_adjustments as fa where fa.contract_no = contract.contract_no and(cr.contract_no = fa.contract_no) and(cr.contract_seq_number = fa.contract_seq_number)),
    lodgement=(select o_name from rd.outlet where outlet_id = contract.con_lodgement_office),
    contract.con_active_sequence,
    contract.con_rcm_paper_file_text,
    contract.con_rd_ref_text,
    contract.con_rd_paper_file_text,
    contract_renewals.con_acceptance_flag,
    -- TJB  SR4657  June05
    -- (select c.con_date_last_prt_for_od from contract as c where c.contract_no = contract.contract_no) as lastdate 
    lastdate=contract.cust_list_printed from
    rd.contract,
    rd.outlet as outlet_a,
    rd.contract_renewals,
    rd.region where
    (region.region_id = outlet_a.region_id) and
    (outlet_a.outlet_id = contract.con_base_office) and
    (contract.contract_no = contract_renewals.contract_no) and
    (((contract_renewals.contract_seq_number = 
    (select con_active_sequence from
      contract where
      contract.contract_no = contract_renewals.contract_no) and
    @insequence = -2)) or
    ((1 = 1 and @insequence = -1)) or
    ((contract_renewals.contract_seq_number = @insequence and
    @insequence not in(-1,-2)))) and
    ((contract.contract_no = @incontract and @incontract <> -1) or
    (@incontract = -1))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function RDRunsRegionV2 : 
--

CREATE function [rd].[RDRunsRegionV2](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns int
as
begin
  declare @iReturn int
  select @iReturn = count(*) 
    from contract join outlet on contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) join
    contract_renewals on contract.contract_no = contract_renewals.contract_no and
    contract.con_active_sequence = contract_renewals.contract_seq_number join region on outlet.region_id = region.region_id where
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    contract.con_date_terminated is null and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  if @iReturn = 0
    select @iReturn=null
  return @iReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function RDRunsRegion : 
--

CREATE function [rd].[RDRunsRegion](@inRegion int,@inOutlet int,@inRenGroup int)
returns int
as
begin
  declare @iReturn int
  select @iReturn = count(*) 
    from contract join outlet on contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) join
    contract_renewals on contract.contract_no = contract_renewals.contract_no and
    contract.con_active_sequence = contract_renewals.contract_seq_number join region on outlet.region_id = region.region_id where
    contract.contract_no = 
    any(select types_for_contract.contract_no from
      types_for_contract join contract_type on contract_type.ct_key = types_for_contract.ct_key  where
      contract_type.ct_rd_ref_mandatory = 'Y') and
    contract.con_date_terminated is null and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  if @iReturn = 0
    select @iReturn=null
  return @iReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OwnDrvRegion : 
--

CREATE function [rd].[OwnDrvRegion](@inRegion int,@inOutlet int,@inRenGroup int)
returns int
as
begin
  declare @iReturn int
  select @iReturn = count(distinct contractor_renewals.contractor_supplier_no) 
    from contract join
    contract_renewals on
    contract.contract_no = contract_renewals.contract_no and
    contract.con_active_sequence = contract_renewals.contract_seq_number join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) join
    contractor_renewals on
    contract_renewals.contract_no = contractor_renewals.contract_no and
    contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number and
    contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date join
    region on
    outlet.region_id = region.region_id where
    contract.contract_no = any(select types_for_contract.contract_no from
      types_for_contract join
      contract_type on types_for_contract.ct_key = contract_type.ct_key where
      contract_type.ct_rd_ref_mandatory = 'Y') and
    contract.con_date_terminated is null and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  if @iReturn = 0
    select @iReturn=null
  return @iReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_VolumesValues : 
--

CREATE procedure [odps].[OD_RPS_VolumesValues](@sdate datetime,@edate datetime,@inregion int)
-- 14/02/02 PBY Request#4326
-- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
-- sql code.  Used the corresponding piece_rate_suplier.prs_key instead.
as
select distinct contract_no=contract.contract_no,
  region=(select rgn_name from rd.region where region.region_id = outlet.region_id),
  name=c_surname_company + case when c_first_names is null then '' else ', ' + c_first_names end,
  adpostvolume=(select sum(pcpr_volume) from payment_component_piece_rates,payment,payment_component,rd.piece_rate_type,rd.piece_rate_supplier where payment.invoice_id = payment_component.invoice_id and payment.contractor_supplier_no = contractor.contractor_supplier_no and payment.contract_no = contract.contract_no and payment_component_piece_rates.prt_key = piece_rate_type.prt_key and piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 1 and payment_component.pc_id = payment_component_piece_rates.pc_id and payment_component.invoice_id = payment.invoice_id and invoice_date = @edate),
  adpostvalue=(select sum(pcpr_value) from payment_component_piece_rates,payment,payment_component,rd.piece_rate_type,rd.piece_rate_supplier where payment.invoice_id = payment_component.invoice_id and payment.contractor_supplier_no = contractor.contractor_supplier_no and payment.contract_no = contract.contract_no and payment_component_piece_rates.prt_key = piece_rate_type.prt_key and piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 1 and payment_component.pc_id = payment_component_piece_rates.pc_id and payment_component.invoice_id = payment.invoice_id and invoice_date = @edate),
  courierpostvolume=(select sum(pcpr_volume) from payment_component_piece_rates,payment,payment_component,rd.piece_rate_type,rd.piece_rate_supplier where payment.invoice_id = payment_component.invoice_id and payment.contractor_supplier_no = contractor.contractor_supplier_no and payment.contract_no = contract.contract_no and payment_component_piece_rates.prt_key = piece_rate_type.prt_key and piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 2 and payment_component.pc_id = payment_component_piece_rates.pc_id and payment_component.invoice_id = payment.invoice_id and invoice_date = @edate),
  courierpostvalue=(select sum(pcpr_value) from payment_component_piece_rates,payment,payment_component,rd.piece_rate_type,rd.piece_rate_supplier where payment.invoice_id = payment_component.invoice_id and payment.contractor_supplier_no = contractor.contractor_supplier_no and payment.contract_no = contract.contract_no and payment_component_piece_rates.prt_key = piece_rate_type.prt_key and piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 2 and payment_component.pc_id = payment_component_piece_rates.pc_id and payment_component.invoice_id = payment.invoice_id and invoice_date = @edate),
  contract_type.contract_type from
  rd.contract,
  rd.outlet,
  rd.contractor,
  rd.contractor_renewals,
  rd.contract_type,rd.types_for_contract where
  (contract.con_base_office = outlet.outlet_id) and
  (contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no) and
  (contract.contract_no = contractor_renewals.contract_no) and
  (types_for_contract.ct_key = contract_type.ct_key) and
  (types_for_contract.contract_no = contract.contract_no) and
  ((outlet.region_id = @inregion and
  @inregion > 0) or
  (@inregion = 0)) and
  exists(select payment.contractor_supplier_no from
    payment,
    payment_component,
    payment_component_piece_rates where
    (payment_component.invoice_id = payment.invoice_id) and
    (payment_component_piece_rates.pc_id = payment_component.pc_id) and
    (payment.contract_no = contractor_renewals.contract_no) and
    (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no) and
    (payment.contract_seq_number = contractor_renewals.contract_seq_number) and
    ((payment.invoice_date = @edate))) order by
  1 asc








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_VolumesValues_Summary : 
--

CREATE procedure [odps].[OD_RPS_VolumesValues_Summary](@sdate datetime,@edate datetime,@inregion int)
as
begin
  -- TJB  SR4684  June-2006
  -- Added support for ParcelPost
  --
  -- 14/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
  -- sql code.  Used the corresponding piece_rate_suplier.prs_key instead.
  select distinct contract_no=contract.contract_no,
    region=(select rgn_name from rd.region where
      region.region_id = outlet.region_id),
    name=c_surname_company+case when c_first_names is null then '' else ', '+c_first_names end ,
    adpostvolume=(select sum(pcpr_volume) from
      payment_component_piece_rates,
      payment,
      payment_component,
      rd.piece_rate_type,
      rd.piece_rate_supplier where
      payment.invoice_id = payment_component.invoice_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.contract_no = contract.contract_no and
      payment_component_piece_rates.prt_key = piece_rate_type.prt_key and
      piece_rate_type.prs_key = piece_rate_supplier.prs_key and
      piece_rate_supplier.prs_key = 1 and
      payment_component.pc_id = payment_component_piece_rates.pc_id and
      payment_component.invoice_id = payment.invoice_id and
      invoice_date = @edate),
    adpostvalue=(select sum(pcpr_value) from
      payment_component_piece_rates,payment,
      payment_component,
      rd.piece_rate_type,
      rd.piece_rate_supplier where
      payment.invoice_id = payment_component.invoice_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.contract_no = contract.contract_no and
      payment_component_piece_rates.prt_key = piece_rate_type.prt_key and
      piece_rate_type.prs_key = piece_rate_supplier.prs_key and
      piece_rate_supplier.prs_key = 1 and
      payment_component.pc_id = payment_component_piece_rates.pc_id and
      payment_component.invoice_id = payment.invoice_id and
      invoice_date = @edate),
    courierpostvolume=(select sum(pcpr_volume) from
      payment_component_piece_rates,payment,
      payment_component,
      rd.piece_rate_type,
      rd.piece_rate_supplier where
      payment.invoice_id = payment_component.invoice_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.contract_no = contract.contract_no and
      payment_component_piece_rates.prt_key = piece_rate_type.prt_key and
      piece_rate_type.prs_key = piece_rate_supplier.prs_key and
      piece_rate_supplier.prs_key = 2 and
      payment_component.pc_id = payment_component_piece_rates.pc_id and
      payment_component.invoice_id = payment.invoice_id and
      invoice_date = @edate),
    courierpostvalue=(select sum(pcpr_value) from
      payment_component_piece_rates,
      payment,payment_component,
      rd.piece_rate_type,
      rd.piece_rate_supplier where
      payment.invoice_id = payment_component.invoice_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.contract_no = contract.contract_no and
      payment_component_piece_rates.prt_key = piece_rate_type.prt_key and
      piece_rate_type.prs_key = piece_rate_supplier.prs_key and
      piece_rate_supplier.prs_key = 2 and
      payment_component.pc_id = payment_component_piece_rates.pc_id and
      payment_component.invoice_id = payment.invoice_id and
      invoice_date = @edate),
    XPvolume=(select sum(pcpr_volume) from
      payment_component_piece_rates,payment,
      payment_component,
      rd.piece_rate_type,
      rd.piece_rate_supplier where
      payment.invoice_id = payment_component.invoice_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.contract_no = contract.contract_no and
      payment_component_piece_rates.prt_key = piece_rate_type.prt_key and
      piece_rate_type.prs_key = piece_rate_supplier.prs_key and
      piece_rate_supplier.prs_key = 3 and
      payment_component.pc_id = payment_component_piece_rates.pc_id and
      payment_component.invoice_id = payment.invoice_id and
      invoice_date = @edate),
    XPvalue=(select sum(pcpr_value) from
      payment_component_piece_rates,
      payment,payment_component,
      rd.piece_rate_type,
      rd.piece_rate_supplier where
      payment.invoice_id = payment_component.invoice_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.contract_no = contract.contract_no and
      payment_component_piece_rates.prt_key = piece_rate_type.prt_key and
      piece_rate_type.prs_key = piece_rate_supplier.prs_key and
      piece_rate_supplier.prs_key = 3 and
      payment_component.pc_id = payment_component_piece_rates.pc_id and
      payment_component.invoice_id = payment.invoice_id and
      invoice_date = @edate),
    contract_type=contract_type.contract_type,
    parcelpostvolume=(select sum(pcpr_volume) from
      payment_component_piece_rates,payment,
      payment_component,
      rd.piece_rate_type,
      rd.piece_rate_supplier where
      payment.invoice_id = payment_component.invoice_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.contract_no = contract.contract_no and
      payment_component_piece_rates.prt_key = piece_rate_type.prt_key and
      piece_rate_type.prs_key = piece_rate_supplier.prs_key and
      piece_rate_supplier.prs_key = 4 and
      payment_component.pc_id = payment_component_piece_rates.pc_id and
      payment_component.invoice_id = payment.invoice_id and
      invoice_date = @edate),
    parcelpostvalue=(select sum(pcpr_value) from
      payment_component_piece_rates,
      payment,payment_component,
      rd.piece_rate_type,
      rd.piece_rate_supplier where
      payment.invoice_id = payment_component.invoice_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.contract_no = contract.contract_no and
      payment_component_piece_rates.prt_key = piece_rate_type.prt_key and
      piece_rate_type.prs_key = piece_rate_supplier.prs_key and
      piece_rate_supplier.prs_key = 4 and
      payment_component.pc_id = payment_component_piece_rates.pc_id and
      payment_component.invoice_id = payment.invoice_id and
      invoice_date = @edate) from
    rd.contract,
    rd.outlet,
    rd.contractor,
    rd.contractor_renewals,
    rd.contract_type,
    rd.types_for_contract where
    contract.con_base_office = outlet.outlet_id and
    contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no and
    contract.contract_no = contractor_renewals.contract_no and
    types_for_contract.ct_key = contract_type.ct_key and
    types_for_contract.contract_no = contract.contract_no and
    (@inregion = 0 or(@inregion > 0 and outlet.region_id = @inregion)) and
    exists(select payment.contractor_supplier_no from
      payment,
      payment_component,
      payment_component_piece_rates where
      payment_component.invoice_id = payment.invoice_id and
      payment_component_piece_rates.pc_id = payment_component.pc_id and
      payment.contract_no = contractor_renewals.contract_no and
      payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
      payment.contract_seq_number = contractor_renewals.contract_seq_number and
      payment.invoice_date = @edate) order by
    contract_no asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_VolumesValues_Detailv2 : 
--

CREATE procedure [odps].[OD_RPS_VolumesValues_Detailv2](@sdate datetime,@edate datetime,@inregion int)
as
begin
  select region.rgn_name,
    contractor.c_surname_company,
    contractor.c_first_names,
    piece_rate_supplier.prs_description,
    piece_rate_type.prt_code + ' (' + prt_description + ')',
    payment_component_piece_rates.pcpr_volume,
    payment_component_piece_rates.pcpr_value,
    contract.contract_no,
    contract_type.contract_type from
    payment,
    payment_component,
    rd.piece_rate_supplier,
    payment_component_piece_rates,
    rd.piece_rate_type,
    rd.contractor,
    rd.contract,
    rd.outlet,
    rd.region,
    rd.contract_type,rd.types_for_contract where
    (payment_component.invoice_id = payment.invoice_id) and
    (types_for_contract.ct_key = contract_type.ct_key) and
    (types_for_contract.contract_no = contract.contract_no) and
    (payment_component_piece_rates.pc_id = payment_component.pc_id) and
    (piece_rate_type.prs_key = piece_rate_supplier.prs_key) and
    (piece_rate_type.prt_key = payment_component_piece_rates.prt_key) and
    (payment.contractor_supplier_no = contractor.contractor_supplier_no) and
    (payment.contract_no = contract.contract_no) and
    (region.region_id = outlet.region_id) and
    (contract.con_base_office = outlet.outlet_id) and
    ((outlet.region_id = @inregion and
    @inregion > 0) or
    (@inregion = 0)) and
    payment.invoice_date between @sdate and @edate order by
    region.rgn_name asc,
    contract.contract_no asc,
    contractor.c_surname_company asc,
    contractor.c_first_names asc,
    piece_rate_supplier.prs_description asc,
    piece_rate_type.prt_description asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_VolumesValuesV2 : 
--

CREATE procedure [odps].[OD_RPS_VolumesValuesV2](@sdate datetime,@edate datetime,@inregion int)
as
begin
  -- 14/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
  -- sql code.  Used the corresponding piece_rate_suplier.prs_key instead.
  select distinct contract_no=contract.contract_no,
    region=(select rgn_name from rd.region where region.region_id = outlet.region_id),
    name=c_surname_company + case when c_first_names is null then '' else ', ' + c_first_names end,
    adpostvolume=(select sum(pcpr_volume) from payment_component_piece_rates,payment,payment_component,rd.piece_rate_type,rd.piece_rate_supplier where payment.invoice_id = payment_component.invoice_id and payment.contractor_supplier_no = contractor.contractor_supplier_no and payment.contract_no = contract.contract_no and payment_component_piece_rates.prt_key = piece_rate_type.prt_key and piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 1 and payment_component.pc_id = payment_component_piece_rates.pc_id and payment_component.invoice_id = payment.invoice_id and invoice_date = @edate),
    adpostvalue=(select sum(pcpr_value) from payment_component_piece_rates,payment,payment_component,rd.piece_rate_type,rd.piece_rate_supplier where payment.invoice_id = payment_component.invoice_id and payment.contractor_supplier_no = contractor.contractor_supplier_no and payment.contract_no = contract.contract_no and payment_component_piece_rates.prt_key = piece_rate_type.prt_key and piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 1 and payment_component.pc_id = payment_component_piece_rates.pc_id and payment_component.invoice_id = payment.invoice_id and invoice_date = @edate),
    courierpostvolume=(select sum(pcpr_volume) from payment_component_piece_rates,payment,payment_component,rd.piece_rate_type,rd.piece_rate_supplier where payment.invoice_id = payment_component.invoice_id and payment.contractor_supplier_no = contractor.contractor_supplier_no and payment.contract_no = contract.contract_no and payment_component_piece_rates.prt_key = piece_rate_type.prt_key and piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 2 and payment_component.pc_id = payment_component_piece_rates.pc_id and payment_component.invoice_id = payment.invoice_id and invoice_date = @edate),
    courierpostvalue=(select sum(pcpr_value) from payment_component_piece_rates,payment,payment_component,rd.piece_rate_type,rd.piece_rate_supplier where payment.invoice_id = payment_component.invoice_id and payment.contractor_supplier_no = contractor.contractor_supplier_no and payment.contract_no = contract.contract_no and payment_component_piece_rates.prt_key = piece_rate_type.prt_key and piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 2 and payment_component.pc_id = payment_component_piece_rates.pc_id and payment_component.invoice_id = payment.invoice_id and invoice_date = @edate),
    XPvolume=(select sum(pcpr_volume) from payment_component_piece_rates,payment,payment_component,rd.piece_rate_type,rd.piece_rate_supplier where payment.invoice_id = payment_component.invoice_id and payment.contractor_supplier_no = contractor.contractor_supplier_no and payment.contract_no = contract.contract_no and payment_component_piece_rates.prt_key = piece_rate_type.prt_key and piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 3 and payment_component.pc_id = payment_component_piece_rates.pc_id and payment_component.invoice_id = payment.invoice_id and invoice_date = @edate),
    XPvalue=(select sum(pcpr_value) from payment_component_piece_rates,payment,payment_component,rd.piece_rate_type,rd.piece_rate_supplier where payment.invoice_id = payment_component.invoice_id and payment.contractor_supplier_no = contractor.contractor_supplier_no and payment.contract_no = contract.contract_no and payment_component_piece_rates.prt_key = piece_rate_type.prt_key and piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 3 and payment_component.pc_id = payment_component_piece_rates.pc_id and payment_component.invoice_id = payment.invoice_id and invoice_date = @edate),
    contract_type.contract_type from
    rd.contract,
    rd.outlet,
    rd.contractor,
    rd.contractor_renewals,
    rd.contract_type,rd.types_for_contract where
    (contract.con_base_office = outlet.outlet_id) and
    (contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no) and
    (contract.contract_no = contractor_renewals.contract_no) and
    (types_for_contract.ct_key = contract_type.ct_key) and
    (types_for_contract.contract_no = contract.contract_no) and
    ((outlet.region_id = @inregion and
    @inregion > 0) or
    (@inregion = 0)) and
    exists(select payment.contractor_supplier_no from
      payment,
      payment_component,
      payment_component_piece_rates where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_piece_rates.pc_id = payment_component.pc_id) and
      (payment.contract_no = contractor_renewals.contract_no) and
      (payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no) and
      (payment.contract_seq_number = contractor_renewals.contract_seq_number) and
      ((payment.invoice_date = @edate))) order by
    1 asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_contractor_labelold : 
--

CREATE procedure [rd].[sp_contractor_labelold](@region int,@contractor char(40))
as
begin select name=ltrim(rtrim(c_first_names))+' '+
ltrim(rtrim(c_surname_company)),contractor.c_address 
from contractor,region,contractor_renewals,contract_renewals,
contract,outlet where(contractor.contractor_supplier_no = 
contractor_renewals.contractor_supplier_no) and(contract_renewals.contract_no = 
contractor_renewals.contract_no) and(contract_renewals.contract_seq_number = 
contractor_renewals.contract_seq_number) and(contract.contract_no = 
contract_renewals.contract_no) and(contract.con_active_sequence = 
contract_renewals.contract_seq_number) and(outlet.outlet_id = contract.con_base_office)
 and(region.region_id = outlet.region_id) and((region.region_id = @region 
and @region <> -1) or(@region = -1)) 
and((left(contractor.c_surname_company,len(ltrim(rtrim(@contractor)))) = ltrim(rtrim(@contractor)) 
and @contractor is not null) or(@contractor is null)) end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_PostTaxAdjustments_Region : 
--

CREATE procedure [odps].[OD_RPS_PostTaxAdjustments_Region](@sdate datetime,@edate datetime,@inregion int)
as
begin
  select distinct contractor.c_surname_company ,
    contractor.c_first_names ,
    post_tax_deductions_applied.pcd_amount ,
    post_tax_deductions.ded_description,
    payment.contract_no,
    region=(select rgn_name from rd.region where region.region_id = outlet.region_id),
    region.rgn_name,
    soundeks= substring(soundex(post_tax_deductions.ded_description),2,3) from
    payment,
    post_tax_deductions_applied,
    rd.contractor,
    post_tax_deductions,
    rd.contract,
    rd.outlet,
    rd.region where
    (post_tax_deductions_applied.invoice_id = payment.invoice_id) and
    (payment.contractor_supplier_no = contractor.contractor_supplier_no) and
    (post_tax_deductions_applied.ded_id = post_tax_deductions.ded_id) and
    (payment.contract_no = contract.contract_no) and
    (contract.con_base_office = outlet.outlet_id) and
    (outlet.region_id = region.region_id) and
    ((payment.invoice_date between @sdate and @edate) and
    ((outlet.region_id = @inregion and
    @inregion > 0) or
    (@inregion = 0)))
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_contractor_label : 
--

CREATE procedure [rd].[sp_contractor_label](@region int,@contractor char(40))
as
begin select name=ltrim(rtrim(c_first_names))+' '+
ltrim(rtrim(c_surname_company)),contractor.c_address from contractor,region,
contractor_renewals,contract_renewals,contract,
outlet where(contractor.contractor_supplier_no = 
contractor_renewals.contractor_supplier_no) and(contract_renewals.contract_no = 
contractor_renewals.contract_no) and(contract_renewals.contract_seq_number =
 contractor_renewals.contract_seq_number) and(contract.contract_no =
 contract_renewals.contract_no) and(contract.con_active_sequence = 
contract_renewals.contract_seq_number) and(outlet.outlet_id = 
contract.con_base_office) and(region.region_id = outlet.region_id) 
and((region.region_id = @region and @region <> -1) or(@region = -1)) 
and((left(contractor.c_surname_company,len(ltrim(rtrim(@contractor)))) = ltrim(rtrim(@contractor))
 and @contractor is not null) or(@contractor is null)) end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function GetDailyDistForReg : 
--

CREATE function [rd].[GetDailyDistForReg](@inRegion int)
returns decimal(10,2)
as
begin
  --declare
  /* Watcom only
  err_notfound exception for sqlstate value '02000'
  */
  declare cur_getdistance cursor for select sum(route_frequency.rf_distance*
      rate_days.rtd_days_per_annum)/
      max(rate_days.rtd_days_per_annum) from
      contract join
      outlet on
      contract.con_base_office = outlet.outlet_id and
      outlet.region_id = @inRegion join
      contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number join
      route_frequency on
      contract.contract_no = route_frequency.contract_no and
--!      rou.rf_active = 'Y',
--!      route_frequency join
      route_frequency.rf_active = 'Y' join
      rate_days on
--!      route_frequency.sf_key = rate_days.sf_key,
--!      outlet as ou join
      route_frequency.sf_key = rate_days.sf_key join
      region on
      outlet.region_id = region.region_id where
      contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
      contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
      contract.contract_no = 
      any(select types_for_contract.contract_no from
        types_for_contract join contract_type on types_for_contract.ct_key = contract_type.ct_key
		where
        contract_type.ct_rd_ref_mandatory = 'Y')
      group by contract.contract_no,contract_renewals.contract_seq_number

  declare @dDailyDistance decimal(10,2),
  @dTotalDailyDistance decimal(10,2)

  select @dTotalDailyDistance=0
  open cur_getdistance
  /* Watcom only
  CursorLoop:
  */while 1=1 
    begin
      fetch next from cur_GetDistance into @dDailyDistance
      if @@fetch_status < 0
        break
        /* Watcom only
        CursorLoop
        */
      if @dDailyDistance is not null
        select @dTotalDailyDistance=@dTotalDailyDistance+@dDailyDistance
    end
  close cur_GetDistance
  return @dTotalDailyDistance
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OwnDrvRegionV2 : 
--

CREATE function [rd].[OwnDrvRegionV2](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns int
as
begin
  declare @iReturn int
  select @iReturn = count(distinct contractor_renewals.contractor_supplier_no) 
    from contract join
    contract_renewals on
    contract.contract_no = contract_renewals.contract_no and
    contract.con_active_sequence = contract_renewals.contract_seq_number join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) join
    contractor_renewals on
    contract_renewals.contract_no = contractor_renewals.contract_no and
    contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number and
    contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date join
    region on
    outlet.region_id = region.region_id where
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    contract.con_date_terminated is null and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  if @iReturn = 0
    select @iReturn=null
  return @iReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_Schedule_A : 
--

CREATE procedure [rd].[sp_Schedule_A](@inContract int,@inSequence int)
-- TJB  Hack  Aug 2006
-- Add the renewal group code to the list of values returned.
-- Wanted for a hack that will determine a contract''s renewal period
-- on the Schedule A report.
--
-- TJB  SR4669  Oct 2005
-- Added email address to returned results.
-- Reformatted and simplified syntax a bit.
--
-- TJB  SR4671  Oct 2005
-- Addded c_primary_contact returned value
--
as -- TJB added Aug 2006
begin
  select contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_address,
    contractor.c_phone_day,
    contract_renewals.con_relief_driver_name,
    contract_renewals.con_relief_driver_address,
    contract_renewals.con_relief_driver_home_phone,
    contract_renewals.con_start_date,
    outlet_combined=rd.strcat((case when outlet.o_name = 'Non-RD Dummy' then 'n.a.' else outlet.o_name
    end),( case when outlet_type.ot_outlet_type <> 'Other' then ' '+outlet_type.ot_outlet_type else '' end)),
    contract.contract_no,
    contract.con_title,
    lodgement=(select rd.strcat((case when outlet1.o_name = 'Non-RD Dummy' then 'n.a.' else outlet1.o_name end),
	(case when outlet_type1.ot_outlet_type <> 'Other' then ' '+outlet_type1.ot_outlet_type else '' end)) from
      outlet as outlet1,
      outlet_type as outlet_type1 where
      outlet_type1.ot_code = outlet1.ot_code and
      outlet1.outlet_id = contract.con_lodgement_office),
    usah=(select 'User:'+current_user ),
    contract_renewals.contract_seq_number,
    contractor.c_initials,
    contractor.c_title,
    rgn_rcm_manager=region.rgn_rcm_manager+ case when rgn_telephone is null then '' else char(10)+'Telephone: '+rgn_telephone end+
    case when rgn_mobile is null then '' else char(10)+'Mobile: '+rgn_mobile end ,
    contractor.c_phone_night,
    contractor.c_mobile,
    contractor.c_email_address,
    contractor.c_mobile2,
    contractor.c_prime_contact,
    contract.rg_code from
    contract_renewals,
    contractor,
    outlet,
    contract,
    contractor_renewals,
    region,
    outlet_type where
    contract.contract_no = contract_renewals.contract_no and
    outlet_type.ot_code = outlet.ot_code and
    outlet.outlet_id = contract.con_base_office and
    contractor.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
    contract_renewals.contract_no = contractor_renewals.contract_no and
    contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number and
    contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date and
    region.region_id = outlet.region_id and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence and
    contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_RptRouteDescription2 : 
--

CREATE procedure  [rd].[sp_RptRouteDescription2](@inContract int,@inSequence int)
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added adr_unit number and road_suffix to relevant parts of address returned
as -- Added adr_alpha (missing in original)
begin
  -- PBY 24/07/2002 SR#4437 Address not displayed correctly
  select cr.contract_no,
    cr.contract_seq_number,
    con_title=left(contract.con_title,60),
    cr.con_start_date,
    c_surname_company=left(contractor.c_surname_company,40),
    c_first_names=left(contractor.c_first_names,40),
    c_initials=left(contractor.c_initials,10),
    route_description.sf_key,
    sf_description=left(standard_frequency.sf_description,35),
    route_description.rf_delivery_days,
    rfpt_description=left(route_freq_point_type.rfpt_description,40),
    route_description.rd_time_at_point,
    rd_description_of_point=left(case when route_description.cust_id is null then 
    route_description.rd_description_of_point else
    (select case when addr.adr_unit is null then '' else addr.adr_unit+'/'end+
      ISNULL(addr.adr_no,'')+
      ISNULL(addr.adr_alpha,'')+
      case when road.road_name is null then '' else ' '+road.road_name end+
      case when rt.rt_name is null then '' else ' '+rt.rt_name end +
      case when rs.rs_name is null then '' else ' '+rs.rs_name end  from
      address as addr left outer join road on addr.road_id=road.road_id left outer join
      road_type as rt on rt.rt_id=road.rt_id left outer join
      road_suffix as rs on road.rs_id=rs.rs_id where
      addr.adr_id = route_description.adr_id) end ,
    40),
    --  PBY 24/07/2002 Commented Out
    --    left(ifnull(cust_id,rd_description_of_point,(select a.adr_no+' '+r.Road_name+' '+rt.rt_name from Address as a,Road as r,road_type as rt where a.road_id = r.road_id and r.rt_id = rt.rt_id and a.adr_id = route_description.adr_id)),40) as rd_description_of_point,
    route_description.rf_distance_of_leg,
    rfv_description=left(route_freq_verbs.rfv_description,40),
    rfv_description_2=left(route_freq_verbs_2.rfv_description,40),
    route_description.rf_running_total,
    left(o.o_name,40),
    left(region.rgn_name,40),
    left(contract.con_rd_ref_text,35),
    left(rf.rf_annotation,500),
    left(rf.rf_annotation_print,1),
    route_description.cust_id 
from
    contract join
    outlet as o on
    contract.con_base_office = o.outlet_id join
    contract_renewals as cr on
    contract.contract_no = cr.contract_no and
    cr.contract_seq_number = @inSequence left outer join
    route_description  on
    contract.contract_no = route_description.contract_no
    join
    region on
    o.region_id = region.region_id
    join
    contractor_renewals as crr on
    cr.contract_no = crr.contract_no and
    cr.contract_seq_number = crr.contract_seq_number and
    cr.con_date_last_assigned = crr.cr_effective_date
	 join
    contractor on
    crr.contractor_supplier_no = contractor.contractor_supplier_no
 left outer join
    standard_frequency on
    route_description.sf_key = standard_frequency.sf_key left outer join
    route_freq_point_type on
    route_description.rfpd_id = route_freq_point_type.rfpt_id left outer join
    route_freq_verbs on
    route_description.rfv_id = route_freq_verbs.rfv_id left outer join
    route_freq_verbs as route_freq_verbs_2 on
    route_description.rfv_id_2 = route_freq_verbs_2.rfv_id,route_frequency as rf 
where
    rf.contract_no = contract.contract_no and
    rf.sf_key = route_description.sf_key and
    rf.rf_delivery_days = route_description.rf_delivery_days and
    contract.contract_no = @inContract and
    rf.rf_active = 'Y' order by
    standard_frequency.sf_description asc,
    route_description.rf_delivery_days asc,
    route_description.rd_sequence asc
end






GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_VolumesValues_Detail : 
--

CREATE procedure [odps].[OD_RPS_VolumesValues_Detail](@sdate datetime,@edate datetime,@inregion int)
as
begin
  select region.rgn_name,
    contractor.c_surname_company,
    contractor.c_first_names,
    piece_rate_supplier.prs_description,
    piece_rate_type.prt_code + ' (' + prt_description + ')',
    payment_component_piece_rates.pcpr_volume,
    payment_component_piece_rates.pcpr_value,
    contract.contract_no from
    payment,
    payment_component,
    rd.piece_rate_supplier,
    payment_component_piece_rates,
    rd.piece_rate_type,
    rd.contractor,
    rd.contract,
    rd.outlet,
    rd.region where
    (payment_component.invoice_id = payment.invoice_id) and
    (payment_component_piece_rates.pc_id = payment_component.pc_id) and
    (piece_rate_type.prs_key = piece_rate_supplier.prs_key) and
    (piece_rate_type.prt_key = payment_component_piece_rates.prt_key) and
    (payment.contractor_supplier_no = contractor.contractor_supplier_no) and
    (payment.contract_no = contract.contract_no) and
    (region.region_id = outlet.region_id) and
    (contract.con_base_office = outlet.outlet_id) and
    ((outlet.region_id = @inregion and
    @inregion > 0) or
    (@inregion = 0)) and
    payment.invoice_date between @sdate and @edate order by
    region.rgn_name asc,
    contract.contract_no asc,
    contractor.c_surname_company asc,
    contractor.c_first_names asc,
    piece_rate_supplier.prs_description asc,
    piece_rate_type.prt_description asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_GetCustoccupationStatV2 : 
--

--
-- Definition for stored procedure sp_GetCustoccupationStatV2 : 
--

CREATE procedure [rd].[sp_GetCustoccupationStatV2](@inRegion int,@inOutlet int,@inContractType int,@inPrivacy int)
as
begin
  declare @lCount integer
  if @inPrivacy = 1
    begin
      select @lCount=count(*)  from t_custstat where id = 0
      if @lcount = 1
        select region=region.rgn_name,
          occupation=occupation.occupation_description,
          occupationcount=(select count(rds_customer.cust_id) from
            address,
            contract,
            customer_address_moves,
            customer_occupation,
            outlet,
            rds_customer where
            (contract.contract_no = address.contract_no) and
            (customer_address_moves.adr_id = address.adr_id) and
            (occupation.occupation_id = customer_occupation.occupation_id) and
            (rds_customer.cust_id = customer_address_moves.cust_id) and
            (region.region_id = outlet.region_id) and
            (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
            (outlet.outlet_id = contract.con_base_office) and
            ((contract.con_base_cont_type = @inContractType) or(@inContractType = 0 or @inContractType is null)) and
            (customer_occupation.cust_id = rds_customer.cust_id) and
            ((rds_customer.master_cust_id is null) and
            (customer_address_moves.move_out_date is null))) from
          region,occupation where
          (region.region_id = @inRegion or @inRegion = 0)
      else
        select region=region.rgn_name,
          occupation=occupation.occupation_description,
          occupationcount=(select count(rds_customer.cust_id) from
            address,
            contract,
            customer_address_moves,
            customer_occupation,
            outlet,
            rds_customer where
            (contract.contract_no = address.contract_no) and
            (customer_address_moves.adr_id = address.adr_id) and
            (occupation.occupation_id = customer_occupation.occupation_id) and
            (rds_customer.cust_id = customer_address_moves.cust_id) and
            (region.region_id = outlet.region_id) and
            (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
            (outlet.outlet_id = contract.con_base_office) and
            ((contract.con_base_cont_type = @inContractType) or(@inContractType = 0 or @inContractType is null)) and
            (customer_occupation.cust_id = rds_customer.cust_id) and
            ((rds_customer.master_cust_id is null) and
            (customer_address_moves.move_out_date is null))) from
          region,occupation where
          (occupation_id = any(select id from t_custstat)) and
          (region.region_id = @inRegion or @inRegion = 0)
    end
  else
    begin
      select @lCount=count(*) from t_custstat where id = 0
      if @lcount = 1
        select region=region.rgn_name,
          occupation=occupation.occupation_description,
          occupationcount=(select count(rds_customer.cust_id) from
            address,
            contract,
            customer_address_moves,
            customer_occupation,
            outlet,
            rds_customer where
            (contract.contract_no = address.contract_no) and
            (customer_address_moves.adr_id = address.adr_id) and
            (occupation.occupation_id = customer_occupation.occupation_id) and
            (rds_customer.cust_id = customer_address_moves.cust_id) and
            (region.region_id = outlet.region_id) and
            (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
            (outlet.outlet_id = contract.con_base_office) and
            ((contract.con_base_cont_type = @inContractType) or(@inContractType = 0 or @inContractType is null)) and
            (customer_occupation.cust_id = rds_customer.cust_id) and
            ((rds_customer.master_cust_id is null) and
            (rds_customer.cust_dir_listing_ind = 'Y') and
            (customer_address_moves.move_out_date is null))) from
          region,occupation where
          (region.region_id = @inRegion or @inRegion = 0)
      else
        select region=region.rgn_name,
          occupation=occupation.occupation_description,
          occupationcount=(select count(rds_customer.cust_id) from
            address,
            contract,
            customer_address_moves,
            customer_occupation,
            outlet,
            rds_customer where
            (contract.contract_no = address.contract_no) and
            (customer_address_moves.adr_id = address.adr_id) and
            (occupation.occupation_id = customer_occupation.occupation_id) and
            (rds_customer.cust_id = customer_address_moves.cust_id) and
            (region.region_id = outlet.region_id) and
            (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
            (outlet.outlet_id = contract.con_base_office) and
            ((contract.con_base_cont_type = @inContractType) or(@inContractType = 0 or @inContractType is null)) and
            (customer_occupation.cust_id = rds_customer.cust_id) and
            ((rds_customer.master_cust_id is null) and
            (rds_customer.cust_dir_listing_ind = 'Y') and
            (customer_address_moves.move_out_date is null))) from
          region,occupation where
          (occupation_id = any(select id from t_custstat)) and
          (region.region_id = @inRegion or @inRegion = 0)
    end
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_GetCustinterestStatV2 : 
--

--
-- Definition for stored procedure sp_GetCustinterestStatV2 : 
--

CREATE procedure [rd].[sp_GetCustinterestStatV2](@inRegion int,@inOutlet int,@inContractType int,@inPrivacy int)
as
begin
  declare @lCount integer
  if @inPrivacy = 1
    begin
      select @lCount=count(*)  from t_custstat where id = 0
      if @lcount = 1
        select region=region.rgn_name,
          interest=interest.interest_description,
          interestcount=(select count(rds_customer.cust_id) from
            address,
            contract,
            customer_address_moves,
            customer_interest,
            outlet,
            rds_customer where
            (contract.contract_no = address.contract_no) and
            (customer_address_moves.adr_id = address.adr_id) and
            (interest.interest_id = customer_interest.interest_id) and
            (rds_customer.cust_id = customer_address_moves.cust_id) and
            (region.region_id = outlet.region_id) and
            (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
            (outlet.outlet_id = contract.con_base_office) and
            ((contract.con_base_cont_type = @inContractType) or(@inContractType = 0 or @inContractType is null)) and
            (customer_interest.cust_id = rds_customer.cust_id) and
            ((rds_customer.master_cust_id is null) and
            (customer_address_moves.move_out_date is null))) from
          region,interest where
          (region.region_id = @inRegion or @inRegion = 0)
      else
        select region=region.rgn_name,
          interest=interest.interest_description,
          interestcount=(select count(rds_customer.cust_id) from
            address,
            contract,
            customer_address_moves,
            customer_interest,
            outlet,
            rds_customer where
            (contract.contract_no = address.contract_no) and
            (customer_address_moves.adr_id = address.adr_id) and
            (interest.interest_id = customer_interest.interest_id) and
            (rds_customer.cust_id = customer_address_moves.cust_id) and
            (region.region_id = outlet.region_id) and
            (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
            (outlet.outlet_id = contract.con_base_office) and
            ((contract.con_base_cont_type = @inContractType) or(@inContractType = 0 or @inContractType is null)) and
            (customer_interest.cust_id = rds_customer.cust_id) and
            ((rds_customer.master_cust_id is null) and
            (customer_address_moves.move_out_date is null))) from
          region,interest where
          (interest_id = any(select id from t_custstat)) and
          (region.region_id = @inRegion or @inRegion = 0)
    end
  else
    begin
      select @lCount=count(*)  from t_custstat where id = 0
      if @lcount = 1
        select region=region.rgn_name,
          interest=interest.interest_description,
          interestcount=(select count(rds_customer.cust_id) from
            address,
            contract,
            customer_address_moves,
            customer_interest,
            outlet,
            rds_customer where
            (contract.contract_no = address.contract_no) and
            (customer_address_moves.adr_id = address.adr_id) and
            (interest.interest_id = customer_interest.interest_id) and
            (rds_customer.cust_id = customer_address_moves.cust_id) and
            (region.region_id = outlet.region_id) and
            (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
            (outlet.outlet_id = contract.con_base_office) and
            ((contract.con_base_cont_type = @inContractType) or(@inContractType = 0 or @inContractType is null)) and
            (customer_interest.cust_id = rds_customer.cust_id) and
            ((rds_customer.master_cust_id is null) and
            (rds_customer.cust_dir_listing_ind = 'Y') and
            (customer_address_moves.move_out_date is null))) from
          region,interest where
          (region.region_id = @inRegion or @inRegion = 0)
      else
        select region=region.rgn_name,
          interest=interest.interest_description,
          interestcount=(select count(rds_customer.cust_id) from
            address,
            contract,
            customer_address_moves,
            customer_interest,
            outlet,
            rds_customer where
            (contract.contract_no = address.contract_no) and
            (customer_address_moves.adr_id = address.adr_id) and
            (interest.interest_id = customer_interest.interest_id) and
            (rds_customer.cust_id = customer_address_moves.cust_id) and
            (region.region_id = outlet.region_id) and
            (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
            (outlet.outlet_id = contract.con_base_office) and
            ((contract.con_base_cont_type = @inContractType) or(@inContractType = 0 or @inContractType is null)) and
            (customer_interest.cust_id = rds_customer.cust_id) and
            ((rds_customer.master_cust_id is null) and
            (rds_customer.cust_dir_listing_ind = 'Y') and
            (customer_address_moves.move_out_date is null))) from
          region,interest where
          (interest_id = any(select id from t_custstat)) and
          (region.region_id = @inRegion or @inRegion = 0)
    end
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_RptRouteDescription : 
--

CREATE procedure [rd].[sp_RptRouteDescription](@inContract int,@inSequence int)
as
begin
  select contract_renewals.contract_no,
    contract_renewals.contract_seq_number,
    contract.con_title,
    contract_renewals.con_start_date,
    contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_initials,
    route_description.sf_key,
    standard_frequency.sf_description,
    route_description.rf_delivery_days,
    route_freq_point_type.rfpt_description,
    route_description.rd_time_at_point,
    route_description.rd_description_of_point,
    route_description.rf_distance_of_leg,
    route_freq_verbs.rfv_description,
    route_freq_verbs_2.rfv_description,
    route_description.rf_running_total,
    outlet.o_name,
    region.rgn_name,
    contract.con_rd_ref_text from
    contract join
    outlet  on contract.con_base_office = outlet.outlet_id join
    contract_renewals on
    contract.contract_no = contract_renewals.contract_no and
    contract_renewals.contract_seq_number = @inSequence left outer join
    route_description on
    contract.contract_no = route_description.contract_no
	 join region on
    outlet.region_id = region.region_id
	 join contractor_renewals on
    contract_renewals.contract_no = contractor_renewals.contract_no and
    contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number and
    contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date
	 join contractor on
    contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no
	 left outer join
    standard_frequency on
    route_description.sf_key = standard_frequency.sf_key left outer join
    route_freq_point_type on
    route_description.rfpd_id = route_freq_point_type.rfpt_id left outer join
    route_freq_verbs on
    route_description.rfv_id = route_freq_verbs.rfv_id left outer join
    route_freq_verbs as route_freq_verbs_2 on
/*!
    contract join
    outlet as o on contract.con_base_office = o.outlet_id join
    contract_renewals as cr on
    contract.contract_no = cr.contract_no and
    cr.contract_seq_number = @inSequence left outer join
    route_description as rd on
    contract.contract_no = rd.contract_no,
    outlet join
    region on
    outlet.region_id = region.region_id,
    contract_renewals join
    contractor_renewals as crr on
    contract_renewals.contract_no = crr.contract_no and
    contract_renewals.contract_seq_number = crr.contract_seq_number and
    contract_renewals.con_date_last_assigned = crr.cr_effective_date,
    contractor_renewals join
    contractor on
    contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no,
    route_description left outer join
    standard_frequency on
    route_description.sf_key = standard_frequency.sf_key left outer join
    route_freq_point_type on
    route_description.rfpd_id = route_freq_point_type.rfpt_id left outer join
    route_freq_verbs on
    route_description.rfv_id = route_freq_verbs.rfv_id left outer join
    route_freq_verbs as route_freq_verbs_2 on
*/
    route_description.rfv_id_2 = route_freq_verbs_2.rfv_id where
    contract.contract_no = @inContract order by
    standard_frequency.sf_description asc,
    route_description.rf_delivery_days asc,
    route_description.rd_sequence asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [odps].[od_rps_ir348detail](@startdate datetime,@enddate datetime)
as
begin
  begin transaction
  delete from t_ir348
  insert into t_ir348(contractor_supplier_no,start_date)
    select contractor_renewals.contractor_supplier_no,
      contractor_renewals.cr_effective_date from
      rd.contract_renewals,
      rd.contractor_renewals,
      rd.contract where
      (contractor_renewals.contract_no = contract_renewals.contract_no) and
      --and(contractor_renewals.contract_seq_number=contract_renewals.contract_seq_number)
      (contract.contract_no = contract_renewals.contract_no) and
      --and(contract_renewals.contract_seq_number=contract.con_active_sequence
      --or exists(select p.contract_seq_number from payment as p where p.contractor_supplier_no=contractor_renewals.contractor_supplier_no and p.contract_no=contract.contract_no and p.invoice_date between @startdate and @enddate))
      (((contract_renewals.con_start_date <= @enddate) and
      (contract.con_date_terminated is null or contract.con_date_terminated >= @startdate or datediff(day,contract.con_date_terminated,@startdate) < 32 or contract.con_date_terminated between @startdate and @enddate)) or
      exists(select contractor_supplier_no from payment where invoice_date between @startdate and @enddate)) and
      contractor_renewals.cr_effective_date = 
      (select max(cr_effective_date) from rd.contractor_renewals as cr2 where
        cr2.contractor_supplier_no = contractor_renewals.contractor_supplier_no)
      group by contractor_renewals.contractor_supplier_no,cr_effective_date
  commit transaction
  select dtl='DTL','0' + 
    (case when len(c_ird_no) = 0 or c_ird_no is null then '00000000' else c_ird_no
    end),
    Employee_Full_Name=left((case when len(c_initials) > 0 then c_initials + ' '
    else '' end) + c_surname_company,20),
    tax_code=(case when len(c_ird_no) = 0 or c_ird_no is null then 'ND' else 'WT' end),
    start_date=case when (select min(cr2.cr_effective_date) from rd.contractor_renewals as cr2 where cr2.contractor_supplier_no = contractor.contractor_supplier_no) between @startdate and @enddate then
      convert(char,(select min(cr2.cr_effective_date) from rd.contractor_renewals as cr2 where cr2.contractor_supplier_no = contractor.contractor_supplier_no),112)
    else
      null
    end,
    end_date=case when (select max(end_date) from t_ir348 where contractor_supplier_no = contractor.contractor_supplier_no) between @startdate and @enddate then convert(char,(select max(end_date) from t_ir348 where contractor_supplier_no = contractor.contractor_supplier_no),112)
    else '' end,Gross_Earnings=(select convert(decimal(10),isnull(round(sum(payment_component.pc_amount),0)*100,0)) from
      payment,payment_component,payment_component_type,payment_component_group where
      payment_component.invoice_id = payment.invoice_id and payment_component.pct_id = payment_component_type.pct_id and
      payment_component_group.pcg_id = payment_component_type.pcg_id and(payment_component_group.pcg_short_code in('GP','OGP')) and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      (payment.invoice_date between @startdate and @enddate)),
    Not_Liable=(case when NZ_Post_Employee is null or NZ_Post_Employee = 'N' then convert(decimal(10),(select convert(decimal(10),isnull(round(sum(payment_component.pc_amount),0)*100,0)) from
      payment,payment_component,payment_component_type,payment_component_group where
      payment_component.invoice_id = payment.invoice_id and payment_component.pct_id = payment_component_type.pct_id and
      payment_component_group.pcg_id = payment_component_type.pcg_id and(payment_component_group.pcg_short_code in('GP','OGP')) and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      (payment.invoice_date between @startdate and @enddate))) else 0 end),
    Lump_sum=0,
    Total_PAYE=(select isnull(convert(decimal(10),round(sum(payment_component.pc_amount)*-100,0)),0) from
      payment,payment_component,payment_component_type where
      payment_component.invoice_id = payment.invoice_id and payment_component.pct_id = payment_component_type.pct_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment_component_type.pct_description like 'Withholding tax%' and(payment.invoice_date between @startdate and @enddate)),
    CS_Deductions=0,CS_DeductionCode='',
    SL_Deductions=0,Family_Assistance=0 from
    rd.contractor where
    contractor.contractor_supplier_no = any(select contractor_supplier_no from t_ir348) and
    ((select convert(decimal(10),isnull(round(sum(payment_component.pc_amount),0)*100,0)) from
      payment,payment_component,payment_component_type,payment_component_group where
      payment_component.invoice_id = payment.invoice_id and payment_component.pct_id = payment_component_type.pct_id and
      payment_component_group.pcg_id = payment_component_type.pcg_id and(payment_component_group.pcg_short_code in('GP','OGP')) and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      (payment.invoice_date between @startdate and @enddate)) >= 0 and (select isnull(convert(decimal(10),round(sum(payment_component.pc_amount)*-100,0)),0) from
      payment,payment_component,payment_component_type where
      payment_component.invoice_id = payment.invoice_id and payment_component.pct_id = payment_component_type.pct_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment_component_type.pct_description like 'Withholding tax%' and(payment.invoice_date between @startdate and @enddate)) >= 0) order by
    c_surname_company asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [odps].[od_rps_ir348detail_Exception](@startdate datetime,@enddate datetime)
as
begin
 begin transaction
  delete from t_ir348
  insert into t_ir348(contractor_supplier_no,start_date)
    select contractor_renewals.contractor_supplier_no,
      contractor_renewals.cr_effective_date from
      rd.contract_renewals,
      rd.contractor_renewals,
      rd.contract where
      (contractor_renewals.contract_no = contract_renewals.contract_no) and
      (contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number) and
      (contract.contract_no = contract_renewals.contract_no) and
      (contract_renewals.contract_seq_number = contract.con_active_sequence or
      exists(select p.contract_seq_number from payment as p where p.contractor_supplier_no = contractor_renewals.contractor_supplier_no and p.contract_no = contract.contract_no and p.invoice_date between @startdate and @enddate)) and
      (((contract_renewals.con_start_date <= @enddate) and
      (contract.con_date_terminated is null or contract.con_date_terminated >= @startdate or datediff(day,contract.con_date_terminated,'1999-2-21') < 32 or contract.con_date_terminated between @startdate and @enddate)) or
      exists(select contractor_supplier_no from payment where invoice_date between @startdate and @enddate)) and
      contractor_renewals.cr_effective_date = 
      (select max(cr_effective_date) from rd.contractor_renewals as cr2 where
        cr2.contractor_supplier_no = contractor_renewals.contractor_supplier_no)
      group by contractor_renewals.contractor_supplier_no,cr_effective_date
  commit transaction
  select dtl='DTL','0' + 
    (case when len(c_ird_no) = 0 or c_ird_no is null then '00000000' else c_ird_no
    end),
    Employee_Full_Name=left((case when len(c_initials) > 0 then c_initials + ' '
    else '' end) + c_surname_company,20),
    tax_code=(case when len(c_ird_no) = 0 or c_ird_no is null then 'ND' else 'M' end),
    start_date=case when (select min(cr2.cr_effective_date) from rd.contractor_renewals as cr2 where cr2.contractor_supplier_no = contractor.contractor_supplier_no) between @startdate and @enddate then
      convert(char,(select min(cr2.cr_effective_date) from rd.contractor_renewals as cr2 where cr2.contractor_supplier_no = contractor.contractor_supplier_no),112)
    else
      null
    end,
    end_date=case when (select max(end_date) from t_ir348 where contractor_supplier_no = contractor.contractor_supplier_no) between @startdate and @enddate then convert(char,(select max(end_date) from t_ir348 where contractor_supplier_no = contractor.contractor_supplier_no),112)
    else '' end,Gross_Earnings=(select convert(decimal(10),isnull(round(sum(payment_component.pc_amount),0)*100,0)) from
      payment,payment_component,payment_component_type,payment_component_group where
      payment_component.invoice_id = payment.invoice_id and payment_component.pct_id = payment_component_type.pct_id and
      payment_component_group.pcg_id = payment_component_type.pcg_id and(payment_component_group.pcg_short_code in('GP','OGP')) and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      (payment.invoice_date between @startdate and @enddate)),
    Not_Liable=(case when NZ_Post_Employee is null or NZ_Post_Employee = 'N' then convert(decimal(10),(select convert(decimal(10),isnull(round(sum(payment_component.pc_amount),0)*100,0)) from
      payment,payment_component,payment_component_type,payment_component_group where
      payment_component.invoice_id = payment.invoice_id and payment_component.pct_id = payment_component_type.pct_id and
      payment_component_group.pcg_id = payment_component_type.pcg_id and(payment_component_group.pcg_short_code in('GP','OGP')) and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      (payment.invoice_date between @startdate and @enddate))) else 0 end),
    Lump_sum=0,
    Total_PAYE=(select isnull(convert(decimal(10),round(sum(payment_component.pc_amount)*-100,0)),0) from
      payment,payment_component,payment_component_type where
      payment_component.invoice_id = payment.invoice_id and payment_component.pct_id = payment_component_type.pct_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment_component_type.pct_description like 'Withholding tax%' and(payment.invoice_date between @startdate and @enddate)),
    CS_Deductions=0,CS_DeductionCode='',
    SL_Deductions=0,Family_Assistance=0 from
    rd.contractor where
    contractor.contractor_supplier_no = any(select contractor_supplier_no from t_ir348) and
    ((select convert(decimal(10),isnull(round(sum(payment_component.pc_amount),0)*100,0)) from
      payment,payment_component,payment_component_type,payment_component_group where
      payment_component.invoice_id = payment.invoice_id and payment_component.pct_id = payment_component_type.pct_id and
      payment_component_group.pcg_id = payment_component_type.pcg_id and(payment_component_group.pcg_short_code in('GP','OGP')) and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      (payment.invoice_date between @startdate and @enddate)) < 0 or (select isnull(convert(decimal(10),round(sum(payment_component.pc_amount)*-100,0)),0) from
      payment,payment_component,payment_component_type where
      payment_component.invoice_id = payment.invoice_id and payment_component.pct_id = payment_component_type.pct_id and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment_component_type.pct_description like 'Withholding tax%' and(payment.invoice_date between @startdate and @enddate)) < 0) order by
    c_surname_company asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContAdjustments : 
--

--
-- Definition for stored procedure sp_GetContAdjustments : 
--

CREATE procedure [rd].[sp_GetContAdjustments](@in_Contract int,@in_Sequence int)
as
begin
  select ca_key,
    contract_no,
    contract_seq_number,
    ca_date_occured,
    ca_reason,
    ca_date_paid,
    ca_amount,
    ca_confirmed,pct_id from
    contract_adjustments where
    contract_no = @in_Contract and
    contract_seq_number = @in_Sequence order by ca_date_occured desc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContAdjustmentsOdps : 
--

--
-- Definition for stored procedure sp_GetContAdjustmentsOdps : 
--

CREATE procedure [rd].[sp_GetContAdjustmentsOdps](@in_Contract int,@in_Sequence int)
as
begin
  select ca_key,
    contract_no,
    contract_seq_number,
    ca_date_occured,
    ca_reason,
    ca_date_paid,
    ca_amount,
    ca_confirmed,
    pct_id from
    contract_adjustments where
    contract_no = @in_Contract and
    contract_seq_number = @in_Sequence order by ca_date_occured desc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetPaymentExtract : 
--

CREATE procedure [rd].[sp_GetPaymentExtract](
@inPayPeriod datetime)
as
begin
  create table #tmp_payment_process(
    contract_no int null,
    contract_seq_number int null,
    con_old_mail_service_no char(6) null,
    contract_title char(60) null,
    contractor_supplier_no int null,
    contractor_title char(10) null,
    contractor_surname_company char(40) null,
    contractor_firstnames char(40) null,
    contractor_initials char(10) null,
    payment_type char(15) null,
    payment_description char(40) null,
    payment_effective_date datetime null,
    payment_amount decimal(10,2) null)
  
  
  declare @dPayStartDate datetime
  declare @dPayEndDate datetime
  declare @dLastPayStartDate datetime
  declare @dLastPayEndDate datetime
  select @dPayEndDate=@inPayPeriod
  select @dLastPayEndDate=dateadd(Month,-1,@inPayPeriod)
  select @dPayStartDate=dateadd(Day,1,@dLastPayEndDate)
  select @dLastPayStartDate=dateadd(Month,-1,@dPayStartDate)
  delete from #tmp_payment_process
  insert into #tmp_payment_process(contract_no,
    contract_seq_number,
    con_old_mail_service_no,
    contract_title,
    contractor_supplier_no,
    contractor_title,
    contractor_surname_company,
    contractor_firstnames,
    contractor_initials,
    payment_type,
    payment_description,
    payment_effective_date,
    payment_amount)
    select contract.contract_no,
      contract_renewals.contract_seq_number,
      contract.con_old_mail_service_no,
      contract.con_title,
      contractor.contractor_supplier_no,
      contractor.c_title,
      contractor.c_surname_company,
      contractor.c_first_names,
      contractor.c_initials,'Allowances',
      allowance_type.alt_description,
      contract_allowance.ca_effective_date,
      contract_allowance.ca_annual_amount 
    from contract 
      join contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number and
      contract.con_date_terminated is null 
      join contract_allowance on
      contract.contract_no = contract_allowance.contract_no and
      contract_allowance.ca_effective_date < @dPayStartDate and
      contract_allowance.ca_paid_to_date is null
      join allowance_type on
      contract_allowance.alt_key = allowance_type.alt_key
      join  contractor_renewals on
      contract_renewals.contract_no = contractor_renewals.contract_no and
      contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number and
      contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date
      join contractor on
      contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no
  update contract_allowance set
    contract_allowance.ca_paid_to_date = @dPayEndDate where
    contract_allowance.ca_effective_date < @dPayStartDate
  insert into #tmp_payment_process(contract_no,
    contract_seq_number,
    con_old_mail_service_no,
    contract_title,
    contractor_supplier_no,
    contractor_title,
    contractor_surname_company,
    contractor_firstnames,
    contractor_initials,
    payment_type,
    payment_description,
    payment_effective_date,
    payment_amount)
    select contract.contract_no,
      contract_renewals.contract_seq_number,
      contract.con_old_mail_service_no,
      contract.con_title,
      contractor.contractor_supplier_no,
      contractor.c_title,
      contractor.c_surname_company,
      contractor.c_first_names,
      contractor.c_initials,'Adjustments',
      contract_adjustments.ca_reason,
      contract_adjustments.ca_date_occured,
      contract_adjustments.ca_amount 
    from contract 
      join contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number and
      contract.con_date_terminated is null 
      join contract_adjustments on
      contract.contract_no = contract_adjustments.contract_no and
      contract_adjustments.ca_date_occured <= @dPayEndDate and
      contract_adjustments.ca_date_paid is null and
      contract_adjustments.ca_confirmed = 'Y'
      join contractor_renewals on
      contract_renewals.contract_no = contractor_renewals.contract_no and
      contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number and
      contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date
      join  contractor on
      contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no
  update contract_adjustments set
    ca_date_paid = @dPayEndDate where
    contract_adjustments.ca_date_occured <= @dPayEndDate and
    contract_adjustments.ca_date_paid is null and
    contract_adjustments.ca_confirmed = 'Y'
  insert into #tmp_payment_process(contract_no,
    contract_seq_number,
    con_old_mail_service_no,
    contract_title,
    contractor_supplier_no,
    contractor_title,
    contractor_surname_company,
    contractor_firstnames,
    contractor_initials,
    payment_type,
    payment_description,
    payment_effective_date,
    payment_amount)
    select contract.contract_no,
      contract_renewals.contract_seq_number,
      contract.con_old_mail_service_no,
      contract.con_title,
      contractor.contractor_supplier_no,
      contractor.c_title,
      contractor.c_surname_company,
      contractor.c_first_names,
      contractor.c_initials,'Extensions',
      null,
      frequency_adjustments.fd_effective_date,
      frequency_adjustments.fd_amount_to_pay 
    from contract 
      join contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number and
      contract.con_date_terminated is null 
      join  frequency_adjustments on
      contract.contract_no = frequency_adjustments.contract_no and
      frequency_adjustments.fd_effective_date < @dPayStartDate and
      frequency_adjustments.fd_paid_to_date is null and
      frequency_adjustments.fd_confirmed = 'Y'
      join contractor_renewals on
      contract_renewals.contract_no = contractor_renewals.contract_no and
      contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number and
      contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date
      join contractor on
      contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no
  update frequency_adjustments set
    fd_paid_to_date = @dPayStartDate where
    fd_confirmed = 'Y' and
    fd_effective_date < @dPayStartDate
  commit transaction
  select contract_no,
    contract_seq_number,
    con_old_mail_service_no,
    contract_title,
    contractor_supplier_no,
    contractor_title,
    contractor_surname_company,
    contractor_firstnames,
    contractor_initials,
    payment_type,
    payment_description,
    payment_effective_date,
    payment_amount from
    #tmp_payment_process
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[temp_LoadContractAdjustments] as
begin
  declare @ll_NextKey integer
  update temp_Contract_Adjustments set
    contract_seq_number = (select con_active_sequence from contract as c where c.contract_no = temp_Contract_Adjustments.contract_no)
  select @ll_NextKey = next_value 
    from Id_Codes where
    sequence_name = 'ContractAdjust'
  insert into contract_adjustments(ca_key,
    contract_no,
    contract_seq_number,
    ca_date_occured,
    ca_reason,
    ca_amount,
    ca_confirmed)
    select ROW_NUMBER() OVER (ORDER BY contract_no ASC) + @ll_NextKey,  --! was number(*)+ @ll_NextKey in ASA
      contract_no,
      contract_seq_number,
      ca_date_occured,
      ca_reason,
      ca_amount,'Y' from
      temp_Contract_Adjustments
  update id_codes set
    next_value = (select max(ca_key)+1 from contract_adjustments) where
    sequence_name = 'ContractAdjust'
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure loadContractAdjustments : 
--

CREATE procedure [rd].[loadContractAdjustments] as
begin
  declare @ll_NextKey int,
  @li_keyseq int,
  @li_contract_no int,
  @ld_date_occured datetime,
  @ln_amount numeric(10,2),
  @ls_reason char(40),
  @li_seq_number int,
  @li_inserts int,
  @li_skipped int,
  @li_errors int,
  @ln_amount_inserted numeric(10,2)
  declare tempCA_crsr cursor for select contract_no,
      ca_date_occured,
      ca_amount,
      ca_reason,
      contract_seq_number from
      rd.temp_Contract_Adjustments for read only
  select @li_keyseq=0
  select @li_inserts=0
  select @li_skipped=0
  select @li_errors=0
  select @ln_amount_inserted=0.0
  begin transaction
  update temp_Contract_Adjustments set
    contract_seq_number = (select con_active_sequence from
      rd.contract as c where
      c.contract_no = temp_Contract_Adjustments.contract_no)
  commit transaction
  begin transaction
  select @ll_NextKey = next_value 
    from rd.Id_Codes where
    sequence_name = 'ContractAdjust'
  commit transaction
  open tempCA_crsr
  /* Watcom only
  copyloop:
  */
  begin transaction
    while 1=1 
    begin
      fetch next from tempCA_crsr into @li_contract_no,@ld_date_occured,@ln_amount,@ls_reason,@li_seq_number
      if @@fetch_status <> 0
        break
        /* Watcom only
        copyloop
        */
      if exists(select 1 from rd.contract_adjustments where
          contract_no = @li_contract_no and
          ca_date_occured = @ld_date_occured and
          ca_reason = @ls_reason and
          ca_amount = @ln_amount)
        select @li_skipped=@li_skipped+1
      else
        begin
          select @li_keyseq=@li_inserts+@ll_NextKey+1
          insert into rd.contract_adjustments(ca_key,
            contract_no,contract_seq_number,ca_date_occured,ca_reason,ca_amount,ca_confirmed) values(
            @li_keyseq,@li_contract_no,@li_seq_number,@ld_date_occured,@ls_reason,@ln_amount,'Y')
          if @@error <> 0
            select @li_errors=@li_errors+1
          else
            begin
              select @li_inserts=@li_inserts+1
              select @ln_amount_inserted=@ln_amount_inserted+@ln_amount
            end
        end
    end
  commit transaction
  begin transaction
  update rd.id_codes set
    next_value = (select max(ca_key)+1 from
      rd.contract_adjustments) where
    sequence_name = 'ContractAdjust'
  commit transaction
  begin transaction
  update rd.ca_load_results set
    rows_inserted = @li_inserts,
    rows_skipped = @li_skipped,
    row_errors = @li_errors,
    amount_inserted = @ln_amount_inserted,
    load_date = getdate() where
    load_name = 'ContractAdjust'
  commit transaction
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Contract_Payments : 
--

CREATE procedure [rd].[sp_Contract_Payments](@inContract int,@inRenewal int)
as
begin
  select contract_renewals.con_renewal_payment_value,'Renewal Price',
    1 from
    contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inRenewal union
  select sum(contract_allowance.ca_annual_amount),
    allowance_type.alt_description,
    2 from
    contract_allowance join
    allowance_type on
    contract_allowance.alt_key = allowance_type.alt_key where
    contract_allowance.contract_no = @inContract
    group by allowance_type.alt_description union
  select sum(contract_adjustments.ca_amount),'Contract Adjustments',
    3 from
    contract_renewals join
    contract on
    contract_renewals.contract_no = contract.contract_no join
    contract_adjustments on
    contract_renewals.contract_no = contract_adjustments.contract_no and
    contract_renewals.contract_seq_number = contract_adjustments.contract_seq_number where
    contract_adjustments.ca_confirmed = 'Y' and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inRenewal union
  select sum(frequency_adjustments.fd_adjustment_amount),'Extensions',
    4 from
    contract_renewals join
    contract on
    contract_renewals.contract_no = contract.contract_no join
    frequency_adjustments on
    contract_renewals.contract_no = frequency_adjustments.contract_no and
    contract_renewals.contract_seq_number = frequency_adjustments.contract_seq_number where
    frequency_adjustments.fd_confirmed = 'Y' and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inRenewal
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_PaymentProcess : 
--

CREATE procedure [rd].[sp_PaymentProcess](@inPayPeriod datetime)
as
begin
  declare @dPayStartDate datetime,
  @dPayEndDate datetime,
  @dLastPayStartDate datetime,
  @dLastPayEndDate datetime
  select @dPayEndDate=@inPayPeriod
  select @dLastPayEndDate=datediff(month,@inPayPeriod,-1)
  select @dPayStartDate=datediff(day,@dLastPayEndDate,1)
  select @dLastPayStartDate=datediff(month,@dPayStartDate,-1)
  update contract_adjustments set
    ca_date_paid = @dPayEndDate where
    contract_adjustments.ca_date_paid is null and
    contract_adjustments.ca_confirmed = 'Y' and
    contract_adjustments.ca_date_occured between @dPayStartDate and @dPayEndDate
  update frequency_adjustments set
    fd_paid_to_date = @dPayEndDate where
    frequency_adjustments.fd_paid_to_date is null and
    frequency_adjustments.fd_confirmed = 'Y' and
    frequency_adjustments.fd_effective_date < @dPayStartDate
  update contract_allowance set
    ca_paid_to_date = @dPayEndDate
  select contract.contract_no,
    cr.contract_seq_number,
    contract.con_title,
    contractor.contractor_supplier_no,
    contractor_name=contractor.c_surname_company + case when contractor.c_first_names is null then case when contractor.c_initials is null then '' else ', ' + contractor.c_initials end else ', ' + contractor.c_first_names end ,
    con_renewal_payment_value=(cr.con_renewal_payment_value)/12,
    adjustments=(select sum(contract_adjustments.ca_amount) from
      contract_adjustments where
      cr.contract_no = contract_adjustments.contract_no and
      cr.contract_seq_number = contract_adjustments.contract_seq_number and
      contract_adjustments.ca_date_paid = @dPayEndDate and
      contract_adjustments.ca_confirmed = 'Y' and
      contract_adjustments.ca_date_occured between @dPayStartDate and @dPayEndDate),
    oldextn=(select sum(frequency_adjustments.fd_amount_to_pay) from
      frequency_adjustments where
      frequency_adjustments.contract_no = cr.contract_no and
      frequency_adjustments.contract_seq_number = cr.contract_seq_number and
      frequency_adjustments.fd_paid_to_date is not null and
      frequency_adjustments.fd_paid_to_date < @dPayEndDate and
      frequency_adjustments.fd_confirmed = 'Y')/12,
    newextn=(select sum(frequency_adjustments.fd_amount_to_pay) from
      frequency_adjustments where
      frequency_adjustments.contract_no = cr.contract_no and
      frequency_adjustments.contract_seq_number = cr.contract_seq_number and
      frequency_adjustments.fd_paid_to_date = @dPayEndDate and
      frequency_adjustments.fd_confirmed = 'Y' and
      frequency_adjustments.fd_effective_date < @dPayStartDate)/12,
    allowances=(select sum(contract_allowance.ca_annual_amount) from
      contract_allowance where
      contract_allowance.contract_no = contract.contract_no)/12,
    piecerates=(select sum(piece_rate_delivery.prd_cost) from
      piece_rate_delivery where
      piece_rate_delivery.contract_no = contract.contract_no) from
    contract join
    contract_renewals as cr on
    contract.contract_no = cr.contract_no and
    contract.con_active_sequence = cr.contract_seq_number
	 join  contractor_renewals on
    (cr.contract_no = contractor_renewals.contract_no and
    cr.contract_seq_number = contractor_renewals.contract_seq_number and
    cr.con_date_last_assigned = contractor_renewals.cr_effective_date/*,0*/)
    join contractor on contractor_renewals.contractor_supplier_no=contractor.contractor_supplier_no
  commit transaction
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Extension_Deliverytime : 
--

CREATE procedure [rd].[sp_Extension_Deliverytime]
as
begin
  select del_hours_variables.dhv_travelling_speed,
    del_hours_variables.dhr_seconds_customer from
    rd.del_hours_variables
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_Invoice_pay_piecerate_detailxp : 
--

CREATE procedure [odps].[OD_RPS_Invoice_pay_piecerate_detailxp](@invoiceid int,@contractno int,@contractorno int,@payperiod_start datetime,@payperiod_end datetime)
as
begin
  declare @v_contract_no int,
  @v_cr_effective_date datetime,
  @v_contractor_start datetime,
  @v_contractor_end datetime
  --Cursor retrieves contractor start and end dates
  -- SR#4465 PBY 18-01-2003 Subselect will returns multiple rows if there are more than 1 contractors
  -- within the same renewal period.  Added a MIN function to always retrieve the oldest
  -- next contractor''s contract start date
  --
  -- TJB  SR4667  June05
  -- Fix bug where these dates weren''t selected when a contractor had two contracts
  -- with different sequence numbers, and the one being searched for wasn''t the max() one.
  -- Dropped use of cursor (see the select below the 'fetch').
  --
  --Find out if there are more than one contractors in the payperiod
  select @v_contract_no=count(contract_no) 
    from odps.payment where
    contract_no = @contractno and
    payment.POTS = 'N' and
    invoice_date = @payperiod_end
  --If there are more than one contract then the contract has changed hands, go in here
  if @v_contract_no > 1
    begin
      -- open vc_contract_list;
      -- fetch next vc_contract_list into v_contractor_start,v_contractor_end;
      select @v_contractor_start=
        (select rd.date(MIN(cr.cr_effective_date)-1) from
          rd.contractor_renewals as cr where
          cr.contract_no = contract.contract_no and
          cr.contract_seq_number = contract.con_active_sequence and
          cr.cr_effective_date > contractor_renewals.cr_effective_date) 
        from rd.contract,
        rd.contractor_renewals where
        contract.contract_no = @contractno and
        contractor_renewals.contract_no = contract.contract_no and
        contractor_renewals.contractor_supplier_no = @contractorno and
        contractor_renewals.contract_seq_number = 
        (select max(cr2.contract_seq_number) from
          rd.contractor_renewals as cr2 where
          cr2.contract_no = @contractno and
          cr2.contractor_supplier_no = @contractorno) and
        (contract.con_date_terminated is null or
        contract.con_date_terminated > @payperiod_end or
        datediff(day,contract.con_date_terminated,@payperiod_start) < 32 or
        contract.con_date_terminated between @payperiod_start and @payperiod_end) order by
        contractor_renewals.cr_effective_date asc
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-8)
        end
      if @v_contractor_end is null
        select @v_contractor_end=rd.date(rd.today()+30)
      select t_invoice_piecerates3.invoice_id,
        t_invoice_piecerates3.prd_date,
        t_invoice_piecerates3.prt_code,
        t_invoice_piecerates3.prd_quantity,
        t_invoice_piecerates3.rate,
        t_invoice_piecerates3.cost from
        t_invoice_piecerates3 where
        t_invoice_piecerates3.invoice_id = @invoiceid and
        t_invoice_piecerates3.prd_date between @v_contractor_start and @v_contractor_end order by
        t_invoice_piecerates3.prd_date asc,
        t_invoice_piecerates3.prt_code asc
    end
  else
    select t_invoice_piecerates3.invoice_id,
      t_invoice_piecerates3.prd_date,
      t_invoice_piecerates3.prt_code,
      t_invoice_piecerates3.prd_quantity,
      t_invoice_piecerates3.rate,
      t_invoice_piecerates3.cost from
      t_invoice_piecerates3 where
      t_invoice_piecerates3.invoice_id = @invoiceid order by
      t_invoice_piecerates3.prd_date asc,
      t_invoice_piecerates3.prt_code asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_IR66ES_old : 
--

CREATE procedure [odps].[OD_RPS_IR66ES_old](@sdate datetime,@edate datetime)
as
select contractor.c_surname_company,
  contractor.c_first_names,
  contractor.c_initials,
  StartDate=case when contractor_renewals.cr_effective_date >= @sdate and contractor_renewals.cr_effective_date <= @edate then
    contractor_renewals.cr_effective_date
  else
    null
  end,
  EndDate=(select dateadd(day,-1,min(cr.cr_effective_date)) from
    rd.contractor_renewals as cr where
    cr.contract_no = contractor_renewals.contract_no and
    cr.contract_seq_number = contractor_renewals.contract_seq_number and
    cr.cr_effective_date > contractor_renewals.cr_effective_date),
  TaxCategory=case when contractor.c_witholding_tax_certificate is null or contractor.c_witholding_tax_certificate = 'N' then 'W' else 'N' end,
  c_ird_no from
  rd.contractor_renewals,
  rd.contractor where
  contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no and
  contractor_renewals.cr_effective_date between @sdate and @edate








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_SearchForContractor](@in_ContractorSupplierNo int,@in_ContractNo int,@in_ct_key int,@in_region_id int,@in_c_surname_company varchar(40),@in_c_first_names varchar(40),@in_c_phone_day varchar(11))
as
begin
  select c.contractor_supplier_no,
    contractor_name=c.c_surname_company + case when c.c_first_names is null then case when c.c_initials is null then '' else ', ' + c.c_initials end else ', ' + c.c_first_names end,
    (select top 1 cr_effective_date from contractor_renewals where contractor_supplier_no = c.contractor_supplier_no) from
    contractor as c where
    (@in_ContractorSupplierNo = 0 or c.contractor_supplier_no = @in_ContractorSupplierNo) and
    (@in_ContractNo = 0 or(select count(*) from
      contractor_renewals where
      contract_no = @in_ContractNo and
      contractor_supplier_no = c.contractor_supplier_no) > 0) and
    (@in_ct_key = 0 or(select count(*) from
      types_for_contractor where
      ct_key = @in_ct_key and
      contractor_supplier_no = c.contractor_supplier_no) > 0) and
    (@in_region_id = 0 or(select count(*) from
      contractor_renewals as cr,
      contract as con,
      outlet as o where
      c.contractor_supplier_no = cr.contractor_supplier_no and
      cr.contract_no = con.contract_no and
      con.con_base_office = o.outlet_id and
      o.region_id = @in_region_id) > 0) and
    (@in_c_surname_company = '' or c_surname_company like @in_c_surname_company + '%') and
    (@in_c_first_names = '' or c_first_names like @in_c_first_names + '%') and
    (@in_c_phone_day = '' or c_phone_day like @in_c_phone_day + '%') order by contractor_name asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function getContractorStart : 
--

CREATE function [rd].[getContractorStart](@con_no int,@contractor_no int)
returns datetime
as
begin
  declare @start_date datetime
  -- TJB SR4623 29 June 2004
  -- 'max' returns the most recent contract establishment date, for those cases
  -- where a contractor gives up a contract then takes it up again.
  select @start_date = max(cr_effective_date) 
    from contractor_renewals where
    contract_no = @con_no and
    contractor_supplier_no = @contractor_no
  return @start_date
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_contractor_labels : 
--

CREATE procedure [rd].[sp_contractor_labels](@inregion int,@incontractor char(40),@incontracttype int,@inrengroup int,@inoutlet int,@incontracts int,@incontractflag char(1))
as
begin
  select distinct contractor.c_title,
    contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_initials,
    contractor.c_address,Label='Rural Delivery Owner Driver' from
    contract_renewals left outer join contractor_renewals on
    contract_renewals.contract_no = contractor_renewals.contract_no and
    contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number and
    contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date,
    contractor left outer join types_for_contractor on contractor.contractor_supplier_no = types_for_contractor.contractor_supplier_no,
    contract,
    outlet where
    (contractor.contractor_supplier_no = contractor_renewals.contractor_supplier_no) and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contractor_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.con_base_office = outlet.outlet_id) and
    ((outlet.region_id = @inregion and
    @inregion is not null) or
    (@inregion is null)) and
    ((contractor.c_surname_company like @incontractor + '%' and
    @incontractor is not null) or
    (@incontractor is null)) and
    ((types_for_contractor.ct_key = @incontracttype and
    @incontracttype is not null) or
    (@incontracttype is null)) and
    ((contract.rg_code = @inrengroup and
    @inrengroup is not null) or
    (@inrengroup is null)) and
    ((outlet.outlet_id = @inoutlet and
    @inoutlet is not null) or
    (@inoutlet is null)) and
    ((contract.contract_no in(@incontracts) and
    @incontractflag = 'Y') or
    (@incontractflag = 'N')) and
    contract.con_date_terminated is null
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function getContractorEnd : 
--

CREATE function [rd].[getContractorEnd](
@con_no int,
@contractor_no int)
returns datetime
as
begin
  declare @end_date datetime
  declare @curr_effective datetime
  declare @active_seq int
  -- get the effective date of this contractor
  select @curr_effective=max(cr_effective_date)
    from contractor_renewals where
    contract_no = @con_no and
    contractor_supplier_no = @contractor_no
  -- get the min cr_effective date for this contract where they are larger than the curr
  select @end_date=isnull(min(cr_effective_date),dateadd(year,100,convert(datetime,convert(varchar(100),getdate(),101))))
    from contractor_renewals where
    contract_no = @con_no and
    contractor_supplier_no <> @contractor_no and
    cr_effective_date > @curr_effective
  -- modify the date - so take one day off
  select @end_date=dateadd(day,-1,@end_date)
  return @end_date
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure OD_RPS_IR13_Interface_Detail : 
--

CREATE procedure [odps].[OD_RPS_IR13_Interface_Detail](@StartDate datetime,@EndDate datetime)
as
begin
  select distinct Owner_Driver_IRD_Number=odps.OD_MiscF_ParseIRDNo(contractor.c_ird_no),
    Owner_Driver_name=contractor.c_surname_company + isnull(', ' + contractor.c_first_names,''),
    Owner_Driver_Address=contractor.c_address,
    Owner_Driver_GST_Number=contractor.c_gst_number,
    Contract_ID=p1.contract_no,
    tax=(select abs(sum(pc_amount)) from
      payment as p,
      payment_component,
      payment_component_type,
      payment_component_group where
      payment_component.pct_id = payment_component_type.pct_id and
      payment_component_group.pcg_id = payment_component_type.pcg_id and
      payment_component_group.pcg_Short_code = 'TAX' and
      p.invoice_id = payment_component.invoice_id and
      p.contractor_supplier_no = contractor.contractor_supplier_no and
      p.invoice_date between @StartDate and @EndDate),
    gross_pay=(select abs(sum(pc_amount)) from
      payment as p,
      payment_component,
      payment_component_type,
      payment_component_group where
      payment_component.pct_id = payment_component_type.pct_id and
      payment_component_group.pcg_id = payment_component_type.pcg_id and
      payment_component_group.pcg_Short_code in('GP','OGP') and
      p.invoice_id = payment_component.invoice_id and
      p.contractor_supplier_no = contractor.contractor_supplier_no and
      p.invoice_date between @StartDate and @EndDate),
    start_date=case when (select min(contractor_renewals.cr_effective_date) from
      rd.contractor_renewals where
      (contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no) and
      contractor_renewals.cr_effective_date <= @EndDate) < @StartDate then
      @StartDate
    else
      (select min(contractor_renewals.cr_effective_date) from
        rd.contractor_renewals where
        (contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no) and
        contractor_renewals.cr_effective_date <= @EndDate)
    end,
    end_date=case when (select distinct 1 from
      rd.contractor_renewals,
      rd.contract_renewals,
      rd.contractor where
      (contract_renewals.contract_no = contractor_renewals.contract_no) and
      (contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number) and
      (contractor.contractor_supplier_no = contractor_renewals.contractor_supplier_no) and
      (contract_renewals.con_expiry_date is null or contract_renewals.con_expiry_date > @EndDate)) = 1 then
      @EndDate
    else
      (select max(contract_renewals.con_expiry_date) from
        rd.contractor_renewals,
        rd.contract_renewals where
        (contract_renewals.contract_no = contractor_renewals.contract_no) and
        (contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number) and
        (contractor.contractor_supplier_no = contractor_renewals.contractor_supplier_no) and
        (contract_renewals.con_expiry_date < @EndDate))
    end from
    rd.contractor,payment as p1 where
    p1.contractor_supplier_no = contractor.contractor_supplier_no and
    p1.invoice_date between @StartDate and @EndDate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_IR66ES : 
--

CREATE procedure [odps].[OD_RPS_IR66ES](@sdate datetime,@edate datetime)
as
begin
  select distinct contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_initials,
    StartDate=contractor_renewals.cr_effective_date,
    EndDate=(select dateadd(day,-1,min(cr.cr_effective_date)) from
      rd.contractor_renewals as cr where
      cr.contract_no = contract_renewals.contract_no and
      cr.contract_seq_number = contract_renewals.contract_seq_number and
      cr.cr_effective_date > contractor_renewals.cr_effective_date),
    TaxCategory=case contractor.c_witholding_tax_certificate when null then 'N' else case contractor.c_witholding_tax_certificate when 'N' then 'W' else 'N' end end,
    c_ird_no from
    rd.contractor,
    rd.contract_renewals,
    rd.contractor_renewals,
    rd.contract where
    contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no and
    (contractor_renewals.contract_no = contract_renewals.contract_no) and
    (contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number) and
    (contract.contract_no = contract_renewals.contract_no) and
    (contract.con_active_sequence = contract_renewals.contract_seq_number) and
    ((contractor_renewals.cr_effective_date between @sdate and @edate) or
    ((select dateadd(day,-1,min(cr.cr_effective_date)) from
      rd.contractor_renewals as cr where
      cr.contract_no = contract_renewals.contract_no and
      cr.contract_seq_number = contract_renewals.contract_seq_number and
      cr.cr_effective_date > contractor_renewals.cr_effective_date) between @sdate and @edate)) and
    not contractor.contractor_supplier_no = 
    any(select contractor2.contractor_supplier_no from
      rd.contract as contract2,
      rd.contract_renewals as contract_renewals2,
      rd.contractor as contractor2,
      rd.contractor_renewals as contractor_renewals2 where
      (contractor_renewals2.contractor_supplier_no = contractor2.contractor_supplier_no) and
      (contractor_renewals2.contract_no = contract_renewals2.contract_no) and
      (contractor_renewals2.contract_seq_number = contract_renewals2.contract_seq_number) and
      (contract2.con_active_sequence = contract_renewals2.contract_seq_number) and
      (contract2.contract_no = contract_renewals2.contract_no) and
      (contractor_renewals2.cr_effective_date = contract_renewals2.con_date_last_assigned) and
      (contractor2.contractor_supplier_no = contractor.contractor_supplier_no) and
      (contract2.con_date_terminated is null) and
      (contractor_renewals2.cr_effective_date < contractor_renewals.cr_effective_date or contractor_renewals2.cr_effective_date > (select dateadd(day,-1,min(cr.cr_effective_date)) from
      rd.contractor_renewals as cr where
      cr.contract_no = contract_renewals.contract_no and
      cr.contract_seq_number = contract_renewals.contract_seq_number and
      cr.cr_effective_date > contractor_renewals.cr_effective_date)))
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_Invoice_pay_piecerate_detailkm : 
--

CREATE procedure [odps].[OD_RPS_Invoice_pay_piecerate_detailkm](@invoiceid int,@contractno int,@contractorno int,@payperiod_start datetime,@payperiod_end datetime)
as
begin
  declare @v_contract_no int,
  @v_cr_effective_date datetime,
  @v_contractor_start datetime,
  @v_contractor_end datetime
  --Cursor retrieves contractor start and end dates
  -- SR#4465 PBY 18-01-2003 Subselect will returns multiple rows if there are more than 1 contractors
  -- within the same renewal period.  Added a MIN function to always retrieve the oldest
  -- next contractor''s contract start date
  --
  -- TJB  SR4667  June05
  -- Fix bug where these dates weren''t selected when a contractor had two contracts
  -- with different sequence numbers, and the one being searched for wasn''t the max() one.
  -- Dropped use of cursor (see the select below the 'fetch').
  --
  --Find out if there are more than one contractors in the payperiod
  select @v_contract_no=count(contract_no) 
    from odps.payment where
    contract_no = @contractno and
    payment.POTS = 'N' and
    invoice_date = @payperiod_end
  --If there are more than one contract then the contract has changed hands, go in here
  if @v_contract_no > 1
    begin
      --  open vc_contract_list;
      --  fetch next vc_contract_list into v_contractor_start, v_contractor_end;
      select @v_contractor_start=
        (select rd.date(MIN(cr.cr_effective_date)-1) from
          rd.contractor_renewals as cr where
          cr.contract_no = contract.contract_no and
          cr.contract_seq_number = contract.con_active_sequence and
          cr.cr_effective_date > contractor_renewals.cr_effective_date) 
		from rd.contract,
        rd.contractor_renewals where
        contract.contract_no = @contractno and
        contractor_renewals.contract_no = contract.contract_no and
        contractor_renewals.contractor_supplier_no = @contractorno and
        contractor_renewals.contract_seq_number = 
        (select max(cr2.contract_seq_number) from
          rd.contractor_renewals as cr2 where
          cr2.contract_no = @contractno and
          cr2.contractor_supplier_no = @contractorno) and
        (contract.con_date_terminated is null or
        contract.con_date_terminated > @payperiod_end or
        datediff(day,contract.con_date_terminated,@payperiod_start) < 32 or
        contract.con_date_terminated between @payperiod_start and @payperiod_end) order by
        contractor_renewals.cr_effective_date asc
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-8)
        end
      if @v_contractor_end is null
        select @v_contractor_end=rd.date(rd.today()+30)
      select t_invoice_piecerates.invoice_id,
        t_invoice_piecerates.prd_date,
        t_invoice_piecerates.prt_code,
        t_invoice_piecerates.prd_quantity,
        t_invoice_piecerates.rate,
        t_invoice_piecerates.cost from
        t_invoice_piecerates where
        t_invoice_piecerates.invoice_id = @invoiceid and
        t_invoice_piecerates.prd_date between @v_contractor_start and @v_contractor_end order by
        t_invoice_piecerates.prd_date asc,
        t_invoice_piecerates.prt_code asc
    end
  else
    select t_invoice_piecerates.invoice_id,
	  t_invoice_piecerates.prd_date,
      t_invoice_piecerates.prt_code,
      t_invoice_piecerates.prd_quantity,
      t_invoice_piecerates.rate,
      t_invoice_piecerates.cost from
      t_invoice_piecerates where
      t_invoice_piecerates.invoice_id = @invoiceid order by
      t_invoice_piecerates.prd_date asc,
      t_invoice_piecerates.prt_code asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure new_pots : 
--

CREATE procedure -- Tim Chan 26/05/2003
-- Initial version - will insert new payment, payment_component entries and rur
[odps].[new_pots](@name char(40),@ird_no char(10),@con_no int,@vendor_id char(10),@supplier_no int,@gross numeric(10,2),@tax numeric(10,2),@gst numeric(10,2),@net numeric(10,2),@invoice_number int,@input_date datetime)
as
begin
  declare @li_return_value int,
  @cont_seq int, -- the contract sequence number
  @invoice_id_ int, -- the new invoice number for the payment
  -- declare invoice_no_ int; -- no idea what this is at the moment
  @tax_rate numeric(4,2),
  @invoice_date_ datetime,
  @pr_id_ int,
  @pr_date_ int,
  @contractor_check int,
  @pc_comment char(400),
  @pc_id_ int,
  @tax_ numeric(10,2),
  @gst_ numeric(10,2)
  -- start with a positive return on the return value
  select @li_return_value=1
  -------------------------------------------------------------------------------
  -- insert entry into payment_runs
  -- get new pr_id value
  select @pr_id_ = max(pr.pr_id)+1 from payment_runs as pr
  -- get the next invoice date (the 20th of the month)
  if day(@input_date) <= 20
    -- set the invoice_date to the 20th of this month
    select @invoice_date_=rd.ymd(year(@input_date),month(@input_date),20)
  else
    -- set the invoice_date to the 20th of next month
    select @invoice_date_=rd.ymd(year(@input_date),month(@input_date)+1,20)
  -- put together the pr_date from the invoice_date
  select @pr_date_=convert(int,@invoice_date_)
  insert into payment_runs(pr_id,
    pr_date,gl_posted,pr_ap_posted,pr_contract_no,POTS) values(
    @pr_id_,@pr_date_,'N','N',@con_no,'Y')
  if @@error <> 0 /* <> was < */
    select @li_return_value=-1
  -------------------------------------------------------------------------------
  -- insert entry into payment
  -- get the contract sequenc number from the contractor_renewals table 
  -- max for contractor and contract_no
  select @cont_seq=max(contract_seq_number) 
    from rd.contractor_renewals as con where
    con.contract_no = @con_no and
    con.contractor_supplier_no = @supplier_no
  -- if couldn''t validate a contract sequence number then return failure
  if @cont_seq is null or @cont_seq < 1
    begin
      select @li_return_value=-1
      return @li_return_value
    end
  -- make sure the contract_no and the supplier number match
  select @contractor_check=count(*) 
    from rd.contractor_renewals as cr where
    cr.contractor_supplier_no = @supplier_no and
    cr.contract_no = @con_no
  -- if the count was not higher than  0 - return failure
  if @contractor_check < 1
    select @li_return_value=-1
  -- get the tax rate
  select @tax_rate = cont.c_tax_rate 
    from rd.contractor as cont where
    cont.contractor_supplier_no = @supplier_no
  -- if no tax rate - then set to 0
  if @tax_rate is null
    select @tax_rate=0
  -- get the new payment invoice number
  select @invoice_id_ = max(pay.invoice_id)+1 
    from payment as pay
  -- do insert into payment table
  insert into payment(contractor_supplier_no,
    contract_no,contract_seq_number,invoice_id,pr_id,invoice_date,
    witholding_tax_rate_applied,invoice_no,POTS) values(
    @supplier_no,@con_no,@cont_seq,@invoice_id_,@pr_id_,@invoice_date_,@tax_rate,@invoice_number,'Y')
  -- check for error
  if @@error <> 0 /* <> was < */
    select @li_return_value=-1
  -----------------------------------------------------------------------------------
  -- do inserts into payment_component
  select @pc_id_ = max(pc_id)+1 
    from payment_component
  --** insert the gross **--
  insert into payment_component(pc_id,
    pct_id,invoice_id,pc_amount,comments) values(
    @pc_id_,2,@invoice_id_,@gross,'Payment val(prorata=1.0000000')
  -- check for error
  if @@error <> 0 /* <> was < */
    select @li_return_value=-1
  --** insert the tax **--
  select @pc_id_=@pc_id_+1
  -- will reverse gst regardless
  select @tax_=@tax*-1
  insert into payment_component(pc_id,
    pct_id,invoice_id,pc_amount,comments,misc_string,misc_decimal) values(
    @pc_id_,8,@invoice_id_,@tax_,'Withholding tax - '+convert(varchar,@tax_rate)+'%','Tax rate applied',(@tax_rate/100)*-1)
  -- check for error
  if @@error <> 0 /* <> was < */
    select @li_return_value=-1
  --** insert the gst **--
  select @pc_id_=@pc_id_+1
  -- will reverse gst regardless
  select @gst_=@gst*-1
  insert into payment_component(pc_id,
    pct_id,invoice_id,pc_amount,comments,misc_string,misc_decimal) values(
    @pc_id_,10,@invoice_id_,@gst_,'GST - 12.50% which is standard','GST rate applied',.125)
  -- check for error
  if @@error <> 0 /* <> was < */
    select @li_return_value=-1
  if @li_return_value = -1
    rollback transaction
  return @li_return_value
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_BLF_GetContractorNo : 
--

CREATE function [odps].[OD_BLF_GetContractorNo](@incontract_no int,@inSequence_no int,@EffDate datetime)
returns int
as
begin
  declare @contractor int
  if @inSequence_no = 0
    begin
      select @contractor = min(contractor_renewals.contractor_supplier_no) 
        from rd.contractor_renewals,
        rd.contract,
        rd.contract_renewals where
        contract_renewals.contract_no = contract.contract_no and
        contract_renewals.contract_no = contractor_renewals.contract_no and
        contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number and
        contract.con_active_sequence = contract_renewals.contract_seq_number and
        contract.contract_no = @inContract_No and
        contractor_renewals.cr_effective_date = (select max(cr_effective_date) from
          rd.contractor_renewals as cr where
          cr.cr_effective_date <= @effdate and
          cr.contract_no = @inContract_no)
      if @@error <> 0 /* <> was < */ or @@error = -1 or @@rowcount = 0 /* was @@error =100 */
        return(-1)
    end
  else
    begin
      select @contractor = min(contractor_renewals.contractor_supplier_no) 
        from rd.contractor_renewals where
        contractor_renewals.contract_no = @inContract_no and
        contractor_renewals.contract_seq_number = @inSequence_no and
        contractor_renewals.cr_effective_date = (select max(cr_effective_date) from
          rd.contractor_renewals as cr where
          cr.cr_effective_date <= @effdate and
          cr.contract_no = @inContract_no)
      if @@error <> 0
        return(-1)
    end
  return(@contractor)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_AuditContractsOwnerDriver : 
--

CREATE procedure [odps].[OD_RPS_AuditContractsOwnerDriver](@sdate datetime,@edate datetime)
as
select contractor_renewals.contract_no,
  contractor.c_surname_company,
  contractor.c_first_names,
  contractor.c_initials,'New Contractor',
  contract_renewals.con_start_date,
  contract_renewals.con_expiry_date from
  rd.contractor_renewals,rd.contract_renewals,rd.contractor where
  contractor_renewals.contract_no = contract_renewals.contract_no and
  contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number and
  contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no and
  contractor_renewals.cr_effective_date between @sdate and @edate union
select contractor_renewals.contract_no,
  contractor.c_surname_company,
  contractor.c_first_names,
  contractor.c_initials,Status='New Contract',
  contract_renewals.con_start_date,
  contract_renewals.con_expiry_date from
  rd.contractor_renewals,rd.contract_renewals,rd.contractor where
  contractor_renewals.contract_no = contract_renewals.contract_no and
  contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number and
  contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no and
  contract_renewals.con_start_date between @sdate and @edate union
select contractor_renewals.contract_no,
  contractor.c_surname_company,
  contractor.c_first_names,
  contractor.c_initials,Status='Contract Terminated',
  contract_renewals.con_start_date,
  contract_renewals.con_expiry_date from
  rd.contractor_renewals,rd.contract_renewals,rd.contract,rd.contractor where
  contractor_renewals.contract_no = contract_renewals.contract_no and
  contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number and
  contract_renewals.contract_no = contract.contract_no and
  contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no and
  contract.con_date_terminated between @sdate and @edate








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure ps_serviceplan : 
--

CREATE procedure [rd].[ps_serviceplan](@inRegion int,@inYearStart datetime,@inMonthEnd datetime,@outYTDRenNo int output,@outYTDOutNo int output,@outYTDRenVal decimal(12,2) output,@outYTDOutVal decimal(12,2) output,@outMonRenNo int output,@outMonOutNo int output,@outMonRenVal decimal(12,2) output,@outMonOutVal decimal(12,2) output,@outYTDRenTrans int output,@outMonthRenTrans int output,@outYTDConCancelled int output,@outMonthConCancelled int output) as
begin
  declare @dMonthStart datetime
  select @dMonthStart=rd.ymd(year(@inMonthEnd),month(@inMonthEnd),1)
  select @outYTDRenNo = sum(case when contract_renewals.con_acceptance_flag = 'Y' then 1 else 0 end),
    @outYTDOutNo = sum(case when  contract_renewals.con_acceptance_flag <> 'Y' then 1 else 0 end),
    @outMonRenNo = sum(case when  contract_renewals.con_acceptance_flag = 'Y' and contract_renewals.con_start_date >= @dMonthStart then 1 else 0 end),
    @outMonOutNo = sum(case when  contract_renewals.con_acceptance_flag <> 'Y' and contract_renewals.con_start_date >= @dMonthStart then 1 else 0 end),
    @outYTDRenVal = sum(case when  contract_renewals.con_acceptance_flag = 'Y' then contract_renewals.con_renewal_payment_value else 0 end),
    @outYTDOutVal = sum(case when  contract_renewals.con_acceptance_flag <> 'Y' then contract_renewals.con_renewal_payment_value else 0 end),
    @outMonRenVal = sum(case when  contract_renewals.con_acceptance_flag = 'Y' and contract_renewals.con_start_date >= @dMonthStart then contract_renewals.con_renewal_payment_value else 0 end),
    @outMonOutVal = sum(case when  contract_renewals.con_acceptance_flag <> 'Y' and contract_renewals.con_start_date >= @dMonthStart then contract_renewals.con_renewal_payment_value else 0 end) 
     from contract join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) join
    contract_renewals on
    contract.contract_no = contract_renewals.contract_no where
    (contract.con_date_terminated is null or
    contract.con_date_terminated > @inYearStart) and
    contract_renewals.contract_seq_number = (select max(contract_seq_number) from contract_renewals where contract_no = contract.contract_no) and
    contract_renewals.con_start_date between @inYearStart and @inMonthEnd
  select @outYTDRenTrans = count(*),
    @outMonthRenTrans = sum(case when contractor_renewals.cr_effective_date between @dMonthStart and @inMonthEnd then 1 else 0 end)
     from contractor_renewals where
    contractor_renewals.cr_effective_date between @inYearStart and @inMonthEnd
  select @outYTDConCancelled = count(*),
    @outMonthConCancelled = sum(case when contract.con_date_terminated between @dMonthStart and @inMonthEnd then 1 else 0 end)
     from contract where
    contract.con_date_terminated between @inYearStart and @inMonthEnd
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_schedule_B : 
--

CREATE procedure [rd].[sp_schedule_B](
@incontract int,
@inSequence int)
as
begin
  select contract_no=contract_renewals.contract_no,
    contract_seq_number=contract_renewals.contract_seq_number,
    con_renewal_payment_value=contract_renewals.con_renewal_payment_value,
    con_title=contract.con_title,
    gst_number=contractor.c_gst_number,
    piece_rate_pr_rate=piece_rate.pr_rate,
    piece_rate_type_prt_description=piece_rate_type.prt_description,
    piece_rate_supplier_prs_description=piece_rate_supplier.prs_description,
    piece_rate_type_prt_code=piece_rate_type.prt_code from
    contract_renewals,
    contract,
    contractor_renewals,
    contractor,
    piece_rate,
    piece_rate_type,
    piece_rate_supplier where
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_no = contractor_renewals.contract_no) and
    (contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number) and
    (contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date) and
    (contractor.contractor_supplier_no = contractor_renewals.contractor_supplier_no) and
    (contract_renewals.con_rg_code_at_renewal = piece_rate.rg_code) and
    (contract_renewals.con_rates_effective_date = piece_rate.pr_effective_date) and
    (piece_rate_type.prt_key = piece_rate.prt_key) and
    (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
    ((contract_renewals.contract_no = @inContract) and
    (contract_renewals.contract_seq_number = @inSequence) and
    (piece_rate.pr_active_status = 'Y') and
    (piece_rate_type.prt_print_on_schedule = 'Y'))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function maxSeqContractor : 
--

CREATE function [rd].[maxSeqContractor](@con_no int,@contractor_no int)
returns int
as
begin
  declare @max_seq int,
  @active_seq int
  select @max_seq = max(crn.contract_seq_number) 
    from contractor_renewals as crn join contract_renewals as cr on crn.contract_no = cr.contract_no and crn.contract_seq_number = cr.contract_seq_number where
    crn.contract_no = @con_no and
    crn.contractor_supplier_no = @contractor_no and
    -- TWC - 14/10/2003 don''t return seq for pending
    cr.con_acceptance_flag = 'Y'
  select @active_seq = con_active_sequence 
    from contract as con where
    con.contract_no = @con_no
  if @max_seq > @active_seq
    select @max_seq=@active_seq
  return @max_seq
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractorsRegion : 
--

--
-- Definition for stored procedure sp_GetContractorsRegion : 
--

CREATE procedure [rd].[sp_GetContractorsRegion](@in_Contractor int,@in_Region int)
as
begin
  select out_count=count(*) from
    outlet as o,
    contract as c,
    contractor_renewals as cr where
    cr.contract_no = c.contract_no and
    c.con_base_office = o.outlet_id and
    cr.contractor_supplier_no = @in_Contractor and
    o.region_id = @in_Region
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function ownerwithcellPercent : 
--

CREATE function [rd].[ownerwithcellPercent](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns float
as
begin
  declare @i_cell_num float,
  @i_total float,
  @d_percentage float
  select @i_cell_num = count(cont.contractor_supplier_no) 
    from towncity as tc join address as addr on tc.tc_id = addr.tc_id join contract as con on addr.contract_no = con.contract_no,
contractor_renewals as cr join contractor as cont on cr.contractor_supplier_no = cont.contractor_supplier_no where
    (@inRegion = 0 or @inRegion is null or tc.region_id = @inRegion) and
    (@inOutlet = 0 or @inOutlet is null or con.con_lodgement_office = @inOutlet) and
    (@inContractType = 0 or @inContractType is null or con.con_base_cont_type = @inContractType) and
    (@inRenGroup = 0 or @inRenGroup is null or con.rg_code = @inRenGroup) and
    con.contract_no = cr.contract_no and
    cr.contract_seq_number = (select max(cr1.contract_seq_number) from contractor_renewals as cr1 where cr1.contract_no = cr.contract_no) and
    cont.c_mobile is not null
  select @i_total = count(cont.contractor_supplier_no) 
    from towncity as tc join address as addr on tc.tc_id = addr.tc_id join contract as con on addr.contract_no = con.contract_no,
contractor_renewals as cr join contractor as cont on cr.contractor_supplier_no = cont.contractor_supplier_no where
    con.contract_no = cr.contract_no and
    cr.contract_seq_number = (select max(cr1.contract_seq_number) from contractor_renewals as cr1 where cr1.contract_no = cr.contract_no) and
    (@inRegion = 0 or @inRegion is null or tc.region_id = @inRegion) and
    (@inOutlet = 0 or @inOutlet is null or con.con_lodgement_office = @inOutlet) and
    (@inContractType = 0 or @inContractType is null or con.con_base_cont_type = @inContractType) and
    (@inRenGroup = 0 or @inRenGroup is null or con.rg_code = @inRenGroup)
  if @i_total <> 0
    begin
      select @d_percentage=(@i_cell_num/@i_total)*100
      select @d_percentage=round(@d_percentage,2)
    end
  else
    select @d_percentage=0
  return round(@d_percentage,2)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractorsContracts : 
--

--
-- Definition for stored procedure sp_GetContractorsContracts : 
--

CREATE procedure [rd].[sp_GetContractorsContracts](@in_Contractor int)
as
begin
  select distinct
    c.contract_no,
    c.con_title from
    contract as c,
    contractor_renewals as cr,
    contract_renewals as conr where
    c.contract_no = cr.contract_no and
    cr.contractor_supplier_no = @in_Contractor and
    conr.contract_no = c.contract_no and
    conr.contract_seq_number = cr.contract_seq_number and
    cr.cr_effective_date = (select max(cr_effective_date) from contractor_renewals where contract_no = c.contract_no and contract_seq_number = conr.contract_seq_number) order by
    c.con_title asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure insert_PTDs : 
--

CREATE procedure [rd].[insert_PTDs](@con_no int,@amount numeric(6,2),@in_description varchar(200)= 'Other - Uniform deduction Dec 03',@in_reference varchar(200))
-- TJB 5-Aug-2004
-- Added in_description and in_reference as optional parameters.  
as -- Default values are as originally hard-coded.
begin
  declare @max_ded_id int,
  @contractor_id int,
  @pct int
if @in_reference is null select @in_reference =convert(varchar(200),@con_no)
  -- always use the pct_id 6
  select @pct=6
  select @max_ded_id = max(ded_id)+1 
    from odps.post_tax_deductions
  -- get the contractor id
  select @contractor_id = cr.contractor_supplier_no 
    from contractor_renewals as cr where
    cr.contract_no = @con_no and
    cr.contract_seq_number = (select max(cr1.contract_seq_number) from
      contractor_renewals as cr1 where
      cr1.contract_no = @con_no) and
    cr.cr_effective_date = (select max(cr2.cr_effective_date) from
      contractor_renewals as cr2 where
      cr2.contract_no = @con_no)
  insert into odps.post_tax_deductions( --ded_id,
    pct_id,ded_description,ded_reference,ded_type_period,ded_default_minimum,ded_start_balance,contractor_supplier_no) values(
    --@max_ded_id,
@pct,@in_description,@in_reference,'M',@amount,@amount,@contractor_id)
  if @@error <> 0 /* <> was < */
    return-1
  return 1
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_GetRenewals : 
--

CREATE procedure [rd].[sp_GetRenewals](
@in_Contract int)
as
begin
  select c.contract_no,c.contract_seq_number,c.con_start_date,
    c.con_expiry_date, c.con_acceptance_flag,
    (select cntr.c_surname_company + (case when isnull(cntr.c_first_names,'')='' then '' else ', ' end )+ isnull(cntr.c_first_names,'')
     from contractor as cntr join contractor_renewals as cr on cntr.contractor_supplier_no=cr.contractor_supplier_no
     where cr.contract_no = c.contract_no and cr.contract_seq_number = c.contract_seq_number 
           and cr.cr_effective_date = (select max(cr2.cr_effective_date) 
                              from contractor_renewals as cr2 
                              where cr.contract_no = cr2.contract_no and
                                    cr.contract_seq_number = cr2.contract_seq_number))
  from contract_renewals as c 
  where c.contract_no = @in_Contract 
  order by c.contract_seq_number desc
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_Contractor](@inContract int,@inRenewal int)
as
begin
  select contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_address,
    contractor.c_phone_night 
    from
/*    contractor as con join contractor_renewals as corr on con.contractor_supplier_no = corr.contractor_supplier_no,
    corr join contract_renewals as cotr on  */
    contractor  join contractor_renewals  on contractor.contractor_supplier_no = contractor_renewals.contractor_supplier_no
	 join contract_renewals on 
    contractor_renewals.contract_no = contract_renewals.contract_no and
    contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number and
    contractor_renewals.cr_effective_date = contract_renewals.con_date_last_assigned and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inRenewal
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Contractor32 : 
--

CREATE procedure  [rd].[sp_Contractor32](@inContract int,@inRenewal int)
as
begin
  select contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_address,
    contractor.c_phone_night,
    contractor.c_phone_day from
    contractor join
    contractor_renewals on
    contractor.contractor_supplier_no = contractor_renewals.contractor_supplier_no
    join
    contract_renewals on
    contractor_renewals.contract_no = contract_renewals.contract_no and
    contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number and
    contractor_renewals.cr_effective_date = contract_renewals.con_date_last_assigned and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inRenewal
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [odps].[OD_RPS_Pay_Summary_ctype](@sdate datetime,@edate datetime,@inregion int,@inctype char(63))
as
begin
  begin TRANSACTION
  -- TJB  SR4684  June-2006
  -- Added ParcelPost
  --
  -- 18/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
  -- sql code.  Used the corresponding payment_component_type.prs_key instead.
  declare @l_region_id int,
  @l_supplier_no int,
  @l_contract_no int,
  @l_contract_seq int,
  @l_invoice_id int,
  @l_ct_key int,
  @l_contractor_supplier_no int,
  @l_contract_seq_no int,
  @l_region_name char(40),
  @l_contract_type char(40),
  @l_co_surname char(52),
  @l_standard numeric(18,2),
  @l_allowance numeric(18,2),
  @l_extension numeric(18,2),
  @l_contract_adjustment numeric(18,2),
  @l_Adpost numeric(18,2),
  @l_CourierPost numeric(18,2),
  @l_Skyroad numeric(18,2),
  @l_ParcelPost numeric(18,2),
  @l_GST_value numeric(18,2),
  @l_wtax_value numeric(18,2),
  @l_adj_notax numeric(18,2),
  @cmd char(1280)
  declare c1 cursor for select region_name,
      region_id,
      contractor_supplier_no,
      contract_no,
      contract_seq_number,
      invoice_id,
      ct_key,
      co_surname,
      contract_type from
      odps.t_pay_summary_contracts
  delete from odps.t_pay_summary_contracts
  --select @cmd='insert into odps.t_pay_summary_contracts'+' select distinct(select region.rgn_name from rd.region'+' where region.region_id = outlet.region_id),'+' outlet.region_id,'+' payment.contractor_supplier_no,'+' payment.contract_no,'+' payment.contract_seq_number,'+' payment.invoice_id,'+' contract.con_base_cont_type,'+' contractor.c_surname_company + isnull(contractor.c_initials,''''),'+' contract_type.contract_type'+' from rd.contract,'+' rd.outlet,'+' rd.contractor,'+' rd.contractor_renewals,'+' rd.contract_type,'+' odps.payment'+' where contract.con_base_office = outlet.outlet_id'+' and contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no'+' and contract.contract_no = contractor_renewals.contract_no'+' and contract.con_base_cont_type in ('+
--    @inctype+')'+' and contract_type.ct_key = contract.con_base_cont_type'+' and ( ( outlet.region_id = '+CONVERT(varchar,@inregion) + 'and '+CONVERT(varchar,@inregion)+' > 0) or ('+CONVERT(varchar,@inregion)+' = 0) )'+' and payment.contract_no = contractor_renewals.contract_no'+' and payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no'+' and payment.contract_seq_number = contractor_renewals.contract_seq_number'+' and payment.invoice_date between '+''''+CONVERT(varchar,@sdate)+''''+' and '+''''+CONVERT(varchar,@edate)+''''
  select @cmd='insert into odps.t_pay_summary_contracts'+' select distinct(select region.rgn_name from rd.region'+' where region.region_id = outlet.region_id),'+' outlet.region_id,'+' payment.contractor_supplier_no,'+' payment.contract_no,'+' payment.contract_seq_number,'+' payment.invoice_id,'+' contract.con_base_cont_type,'+' contractor.c_surname_company + (case when contractor.c_initials is  null then '''' else '',''+ contractor.c_initials end),'+' contract_type.contract_type'+' from rd.contract,'+' rd.outlet,'+' rd.contractor,'+' rd.contractor_renewals,'+' rd.contract_type,'+' odps.payment'+' where contract.con_base_office = outlet.outlet_id'+' and contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no'+' and contract.contract_no = contractor_renewals.contract_no'+' and contract.con_base_cont_type in ('+
    @inctype+')'+' and contract_type.ct_key = contract.con_base_cont_type'+' and ( ( outlet.region_id = '+CONVERT(varchar,@inregion) + 'and '+CONVERT(varchar,@inregion)+' > 0) or ('+CONVERT(varchar,@inregion)+' = 0) )'+' and payment.contract_no = contractor_renewals.contract_no'+' and payment.contractor_supplier_no = contractor_renewals.contractor_supplier_no'+' and payment.contract_seq_number = contractor_renewals.contract_seq_number'+' and payment.invoice_date between '+''''+CONVERT(varchar,@sdate)+''''+' and '+''''+CONVERT(varchar,@edate)+''''
  execute(@cmd)
  delete from odps.t_pay_summary
  open c1
  if @@error <> 0
    begin
      rollback transaction
	  close c1
      return(-1)
    end
  /* Watcom only
  MAINLOOP98:
  */while 1=1 
    begin
      fetch next from c1 into @l_region_name,
        @l_region_id,
        @l_supplier_no,
        @l_contract_no,
        @l_contract_seq,
        @l_invoice_id,
        @l_ct_key,
        @l_co_surname,
        @l_contract_type 
      --!if sqlcode < 0
      --!if sqlstate = '02000'
		if @@FETCH_STATUS <> 0
        BEGIN
        break
        END
        /* Watcom only
        MAINLOOP98
        */
      select @l_standard = isnull(sum(pc_amount),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        (payment_component_type.pct_description like 'Contract payment value%' or
        payment_component_type.pct_description like 'Frequency Adjustment%') and
        left(payment_component.comments,6) <> 'Arrear' and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      select @l_allowance = isnull(sum(pc_amount),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        payment_component_type.pct_description like 'Contract allowance%' and
        left(payment_component.comments,6) <> 'Arrear' and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      select @l_extension = isnull(sum(pc_amount),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        left(payment_component.comments,6) = 'Arrear' and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      select @l_Skyroad = isnull(sum(pc_amount),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        payment_component_type.prs_key = 3 and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      select @l_contract_adjustment = isnull(sum(pc_amount),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        payment_component_type.pct_description like 'Contract Adjustment%' and
        left(payment_component.comments,6) <> 'Arrear' and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      select @l_Adpost = isnull(sum(pc_amount),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        payment_component_type.prs_key = 1 and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      select @l_CourierPost = isnull(sum(pc_amount),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        payment_component_type.prs_key = 2 and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      select @l_ParcelPost = isnull(sum(pc_amount),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        payment_component_type.prs_key = 4 and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      select @l_GST_value = isnull(sum(pc_amount*-1),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        payment_component_type.pct_description like 'GST%' and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      select @l_wtax_value = isnull(sum(pc_amount*-1),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        payment_component_type.pct_description like 'Withholding Tax%' and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      select @l_adj_notax = isnull(sum(pc_amount*-1),0) 
        from odps.payment,odps.payment_component,odps.payment_component_type where
        payment.invoice_id = @l_invoice_id and
        payment_component.invoice_id = payment.invoice_id and
        payment_component_type.pct_id = payment_component.pct_id and
        payment_component_type.pct_description like 'Post-Tax Adjustments%' and
        payment.contractor_supplier_no = @l_supplier_no and
        payment.contract_no = @l_contract_no and
        payment.contract_seq_number = @l_contract_seq
      insert into odps.t_pay_summary(region,
        contract_no,name,
        m_standard,m_allowance,m_extension,m_contract_adjustment,
        m_Adpost,m_CourierPost,m_GST_value,m_wtax_value,m_adj_notax,
        contract_type,m_ParcelPost,m_Skyroad) values(
        @l_region_name,@l_contract_no,@l_co_surname,
        @l_standard,@l_allowance,@l_extension,@l_contract_adjustment,
        @l_Adpost,@l_CourierPost,@l_GST_value,@l_wtax_value,@l_adj_notax,
        @l_contract_type,@l_ParcelPost,@l_Skyroad)
 
    end
  close c1
  DEALLOCATE c1
  commit transaction
  select* from odps.t_pay_summary
end







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_FixedAssetTypes : 
--

CREATE procedure [rd].[sp_DDDW_FixedAssetTypes]
as
begin
  select fat_id,
    fat_description from
    fixed_asset_type
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContract : 
--

--
-- Definition for stored procedure sp_GetContract : 
--

CREATE procedure [rd].[sp_GetContract](@in_Contract int)
as
begin
  select contract.contract_no,
    contract.rg_code,
    contract.con_old_mail_service_no,
    contract.con_title,
    contract.con_rd_paper_file_text,
    contract.con_rcm_paper_file_text,
    contract.con_base_office,
    con_base_office_name=(select outlet.o_name from outlet where outlet.outlet_id = contract.con_base_office),
    region_id=(select outlet.region_id from outlet where outlet_id = contract.con_base_office),
    contract.con_lodgement_office,
    con_lodgement_office_name=(select outlet.o_name from outlet where outlet.outlet_id = contract.con_lodgement_office),
    contract.con_active_sequence,
    contract.con_base_cont_type,
    contract.con_rd_ref_text,
    contract.con_last_service_review,
    contract.con_last_delivery_check,
    contract.con_last_work_msrmnt_check,
    contract.con_lngth_sealed_road,
    contract.con_lngth_unsealed_road,
    contract.con_date_terminated from
    contract where
    contract.contract_no = @in_Contract
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContract32 : 
--

--
-- Definition for stored procedure sp_GetContract32 : 
--

CREATE procedure [rd].[sp_GetContract32](@in_Contract int)
as
begin
  select contract.contract_no,
    contract.rg_code,
    contract.con_old_mail_service_no,
    contract.con_title,
    contract.con_rd_paper_file_text,
    contract.con_rcm_paper_file_text,
    contract.con_base_office,
    con_base_office_name=(select outlet.o_name from outlet where outlet.outlet_id = contract.con_base_office),
    region_id=(select outlet.region_id from outlet where outlet_id = contract.con_base_office),
    contract.con_lodgement_office,
    con_lodgement_office_name=(select outlet.o_name from outlet where outlet.outlet_id = contract.con_lodgement_office),
    contract.con_active_sequence,
    contract.con_base_cont_type,
    contract.con_rd_ref_text,
    contract.con_last_service_review,
    contract.con_last_delivery_check,
    contract.con_last_work_msrmnt_check,
    contract.con_lngth_sealed_road,
    contract.con_lngth_unsealed_road,
    contract.con_date_terminated,'','' from
    contract where
    contract.contract_no = @in_Contract
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRegionOutletContracts : 
--

CREATE procedure [rd].[sp_GetRegionOutletContracts](
@Inregion int,
@inOutlet int,
@inContract int)
as
begin
  select contract.contract_no,
    contract.con_title from
    contract,
    outlet where
    (contract.con_base_office = outlet.outlet_id) and
    (contract.con_active_sequence is not null) and
    ((contract.contract_no = @incontract and
    @incontract > 0) or
    (contract.con_base_office = @inoutlet and
    @inoutlet > 0 and
    @incontract = 0) or
    (outlet.region_id = @inregion and
    @inregion > 0 and
    @inoutlet = 0) or
    (@inRegion = 0 and @inoutlet = 0 and @incontract = 0)) union
  select 0,'<All Contracts>' 
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_SearchForContract : 
--

CREATE procedure [rd].[sp_SearchForContract](@in_Region int,@in_Contract int,@in_ContractTitle char(60),@in_ConMSN char(6),@in_LastServiceStart datetime,@in_LastServiceEnd datetime,@in_LastDelStart datetime,@in_LastDelEnd datetime,@in_LastWorkStart datetime,@in_LastWorkEnd datetime)
as
begin
  select distinct contract_no,
    con_title from
    contract where
    (contract_no = @in_Contract or @in_Contract = 0) and
    (con_old_mail_service_no like @in_ConMSN + '%' or
    @in_ConMSN = '') and
    (con_title like @in_ContractTitle + '%') and
    (con_last_service_review between @in_LastServiceStart and @in_LastServiceEnd or
    (@in_LastServiceStart = '1900-01-01' and con_last_service_review is null)) and
    (con_last_delivery_check between @in_LastDelStart and @in_LastDelEnd or
    (@in_LastDelStart = '1900-01-01' and con_last_delivery_check is null)) and
    (con_last_work_msrmnt_check between @in_LastWorkStart and @in_LastWorkEnd or
    (@in_LastWorkStart = '1900-01-01' and con_last_work_msrmnt_check is null)) and
    (@in_Region = 0 or con_base_office = any(select outlet_id from outlet where region_id = @in_Region)) order by
    con_title asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Extension_CustCount : 
--

CREATE procedure [rd].[sp_Extension_CustCount](@inContract int,@inRegion int,@inType char(1))
as
begin
  if @intype = '1'
    select cnt=count(*) from
      contract as c,
      outlet as o where
      c.contract_no = @inContract and
      o.outlet_id = c.con_lodgement_office and
      o.region_id = @inregion
  else
    select count(*) from
      contract as c where
      c.contract_no = @inContract
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_DDDW_region_contracts : 
--

CREATE procedure [rd].[sp_DDDW_region_contracts](@region int,@outlet int)
as
begin
  select contract.contract_no,
    contract.con_title from
    contract,
    outlet where
    (contract.con_base_office = outlet.outlet_id) and
    ((outlet.region_id = @region and
    @region <> -1) or
    (@region = -1)) and
    ((outlet.outlet_id = @outlet and
    @outlet <> -1) or
    (@outlet = -1)) union
  select-1,'<All>'  order by
    2 asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_outlet_labels : 
--

CREATE procedure [rd].[sp_outlet_labels](@in_Region int,@in_phyFlag int)
as
begin
  -- TJB SR4647  Feb 2005
  -- Added the 'distinct' and additional conditions to return 
  -- only outlets that are the base office of at least one 
  -- non-terminated 'Rural Delivery' contract.
  -- TJB  SR4647 part2  June 2005
  -- Added in_phyFlag: Use physical address if available if = 1
  if @in_phyFlag = 0
    -- This is the original query: use the postal address omly
    select distinct
      o.o_name,
      o.o_address,
      o.o_manager,
      ot.ot_outlet_type from
      rd.outlet as o,
      rd.outlet_type as ot,
      rd.contract as c,
      rd.types_for_contract as tc,
      rd.contract_type as ct where
      (o.region_id = @in_Region or @in_Region = 0) and
      o.o_name <> 'Non-RD Dummy' and
      ot.ot_code = o.ot_code and
      c.con_base_office = o.outlet_id and
      con_date_terminated is null and
      tc.contract_no = c.contract_no and
      tc.ct_key = 1 -- Rural Delivery Contracts only
  else
    -- This query has been added (TJB June05)
    -- Use the physical address if there is one, otherwise the postal address
    -- (otherwise the queries are identical)
    select distinct
      o.o_name,
      case when o.o_phy_address is null then o.o_address else (case when o.o_phy_address = '' then
        o.o_address
      else o.o_phy_address
      end) end ,o.o_manager,
      ot.ot_outlet_type from
      rd.outlet as o,
      rd.outlet_type as ot,
      rd.contract as c,
      rd.types_for_contract as tc,
      rd.contract_type as ct where
      (o.region_id = @in_Region or @in_Region = 0) and
      o.o_name <> 'Non-RD Dummy' and
      ot.ot_code = o.ot_code and
      c.con_base_office = o.outlet_id and
      con_date_terminated is null and
      tc.contract_no = c.contract_no and
      tc.ct_key = 1 -- Rural Delivery Contracts only
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_SearchForContract2 : 
--

CREATE procedure [rd].[sp_SearchForContract2](@in_Region int,@in_Contract int,@in_ContractTitle char(60),@in_ConMSN char(6),@in_LastServiceStart datetime,@in_LastServiceEnd datetime,@in_LastDelStart datetime,@in_LastDelEnd datetime,@in_LastWorkStart datetime,@in_LastWorkEnd datetime)
as
begin
  select distinct contract_no,
    con_title,con_date_terminated from
    contract where
    (contract_no = @in_Contract or @in_Contract = 0) and
    (con_old_mail_service_no like @in_ConMSN + '%' or
    @in_ConMSN = '') and
    (con_title like @in_ContractTitle + '%') and
    ((con_last_service_review
    between(case when ((@in_LastServiceStart is null) and (@in_LastServiceEnd is not null)) then (cast('1900-1-1' as datetime)) else @in_LastServiceStart
    end)
    and(case when @in_LastServiceEnd is null and @in_LastServiceStart is not null then getdate() else @in_LastServiceEnd end)) or
    (@in_LastServiceStart is null and @in_LastServiceEnd is null)) and
    ((con_last_delivery_check
    between(case when (@in_LastDelStart is null)and (@in_LastDelEnd is not null) then (cast('1900-1-1' as datetime)) else @in_LastDelStart
    end)
    and(case when @in_LastDelEnd is null and @in_LastDelStart is not null then getdate() else @in_LastDelEnd end)) or
    (@in_LastDelStart is null and @in_LastDelEnd is null)) and
    ((con_last_work_msrmnt_check
    between(case when @in_LastWorkStart is null and @in_LastWorkEnd is not null then (cast('1900-1-1' as datetime)) else @in_LastWorkStart
    end)
    and(case when @in_LastWorkEnd is null and @in_LastWorkStart is not null then getdate() else @in_LastWorkEnd end)) or
    (@in_LastWorkStart is null and @in_LastWorkEnd is null)) and
    (@in_Region = 0 or con_base_office = any(select outlet_id from outlet where region_id = @in_Region)) order by
    con_title asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_vehiclesum_age : 
--

CREATE procedure [rd].[sp_vehiclesum_age](@inRegion int,@inOutlet int)
as
begin
  declare @nAgeUpto5Years int,
  @nAge5To10Years int,
  @nAgeOver10Years int,
  @nAgeUnknown int
  select @nAgeUpto5Years = Count(distinct vehicle.vehicle_number)
    from outlet join contract as con on
    outlet.outlet_id = con.con_base_office
	 join contract_renewals as conr on
    con.contract_no = conr.contract_no and
    con.con_active_sequence = conr.contract_seq_number
	 join contract_vehical on
    conr.contract_no = contract_vehical.contract_no and
    conr.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A'
	 join vehicle on contract_vehical.vehicle_number = vehicle.vehicle_number where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (year(rd.today())-vehicle.v_vehicle_year) < 5
  select @nAge5To10Years = Count(distinct vehicle.vehicle_number)
    from outlet join contract as con on
    outlet.outlet_id = con.con_base_office
	 join contract_renewals on
    con.contract_no = contract_renewals.contract_no and
    con.con_active_sequence = contract_renewals.contract_seq_number
	 join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A'
	 join vehicle on contract_vehical.vehicle_number = vehicle.vehicle_number where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (year(rd.today())-vehicle.v_vehicle_year) >= 5 and
    (year(rd.today())-vehicle.v_vehicle_year) < 10
  select @nAgeOver10Years = Count(distinct vehicle.vehicle_number)
    from outlet join contract as con on
    outlet.outlet_id = con.con_base_office
	 join contract_renewals on
    con.contract_no = contract_renewals.contract_no and
    con.con_active_sequence = contract_renewals.contract_seq_number
	 join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A'
	 join
    vehicle on contract_vehical.vehicle_number =vehicle.vehicle_number  where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (year(rd.today())-vehicle.v_vehicle_year) >= 10
  select @nAgeUnknown = Count(distinct vehicle.vehicle_number)
    from outlet join contract as con on
    outlet.outlet_id = con.con_base_office
	 join contract_renewals on
    con.contract_no = contract_renewals.contract_no and
    con.con_active_sequence = contract_renewals.contract_seq_number
	 join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A'
	 join
    vehicle on contract_vehical.vehicle_number = vehicle.vehicle_number where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    vehicle.v_vehicle_year is null
  select @nAgeUpto5Years,
    @nAge5To10Years,
    @nAgeOver10Years,
    @nAgeUnknown 
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_vehiclesum_vehicletype : 
--

CREATE procedure [rd].[sp_vehiclesum_vehicletype](@inRegion int,@inOutlet int)
as
begin
  select vehicle_type.vt_description,
    (select Count(distinct vehicle.vehicle_number) from
      outlet join contract on
      outlet.outlet_id = contract.con_base_office,
      contract  as con join contract_renewals on
      con.contract_no = contract_renewals.contract_no and
      con.con_active_sequence = contract_renewals.contract_seq_number,
      contract_renewals as cr join contract_vehical on
      cr.contract_no = contract_vehical.contract_no and
      cr.contract_seq_number = contract_vehical.contract_seq_number and
      contract_vehical.cv_vehical_status = 'A',
      contract_vehical as cv  join vehicle on cv.vehicle_number = vehicle.vehicle_number
where
      (outlet.region_id = @inRegion or @inRegion = 0) and
      (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
      vehicle.vt_key = vehicle_type.vt_key) from
    vehicle_type
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_SearchForContract3](@in_Region int,@in_Contract int,@in_ContractTitle varchar(60),@in_ConMSN varchar(6),@in_LastServiceStart datetime,@in_LastServiceEnd datetime,@in_LastDelStart datetime,@in_LastDelEnd datetime,@in_LastWorkStart datetime,@in_LastWorkEnd datetime,@in_ContractType int)
as
begin
  select distinct contract_no,
    con_title,con_date_terminated from
    contract where
    (contract_no = @in_Contract or @in_Contract = 0) 
and
	(con_base_cont_type = @in_ContractType or @in_ContractType = 0) 
and
    (con_old_mail_service_no like @in_ConMSN + '%' or @in_ConMSN = '') 
and
    (con_title like @in_ContractTitle + '%') 
and
    ((con_last_service_review between(case when ((@in_LastServiceStart is null) and (@in_LastServiceEnd is not null)) then (cast('1900-1-1' as datetime)) else @in_LastServiceStart end) and (case when (@in_LastServiceEnd is null and @in_LastServiceStart is not null) then getdate() else @in_LastServiceEnd end)) or (@in_LastServiceStart is null and @in_LastServiceEnd is null)) 
and
    ((con_last_delivery_check between(case when (@in_LastDelStart is null)and (@in_LastDelEnd is not null) then (cast('1900-1-1' as datetime)) else @in_LastDelStart end) and(case when @in_LastDelEnd is null and @in_LastDelStart is not null then getdate() else @in_LastDelEnd end)) or (@in_LastDelStart is null and @in_LastDelEnd is null)) 
and 
	((con_last_work_msrmnt_check between(case when @in_LastWorkStart is null and @in_LastWorkEnd is not null then (cast('1900-1-1' as datetime)) else @in_LastWorkStart end) and(case when @in_LastWorkEnd is null and @in_LastWorkStart is not null then getdate() else @in_LastWorkEnd end)) or (@in_LastWorkStart is null and @in_LastWorkEnd is null)) 
and
    (@in_Region = 0 or con_base_office = any(select outlet_id from outlet where region_id = @in_Region)) 
order by con_title asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_DDDW_Outlets : 
--

CREATE procedure [rd].[sp_DDDW_Outlets](@regid int)
as
begin select outlet_id,o_name from outlet where((region_id = @regid and @regid is not null and @regid <> -1) or(1 = 1 and @regid = -1)) union select-1,'<All>'  order by 2 asc end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_vehiclesum_fuel : 
--

CREATE procedure [rd].[sp_vehiclesum_fuel](
@region int,
@outlet int)
as
begin
  select fuel_type.ft_description,
    count(vehicle.vehicle_number) 
  from  
    contract_renewals left outer join contract on contract_renewals.contract_no=contract.contract_no,
    contract_vehical left outer join contract_renewals cr2 on 
    contract_vehical.contract_no=cr2.contract_no 
    and contract_vehical.contract_seq_number=cr2.contract_seq_number,
    contract c2 left outer join outlet on 
    c2.con_lodgement_office=outlet.outlet_id and c2.con_base_office=outlet.outlet_id,
    FUEL_TYPE left outer join vehicle on FUEL_TYPE.ft_key=vehicle.ft_key,
    VEHICLE v2 left outer join CONTRACT_VEHICAL  cv2 on v2.vehicle_number=cv2.vehicle_number
where
    ((outlet.region_id = @region and @region <> -1) or
    (@region = -1)) and ((outlet.outlet_id = @outlet and
    @outlet <> -1) or  (@outlet = -1))
    group by fuel_type.ft_description union
  select 'TOTAL',
    count(distinct vehicle.vehicle_number) 
 from
    contract_renewals left outer join contract on contract_renewals.contract_no=contract.contract_no,
    contract_vehical left outer join contract_renewals  cr2 on 
    contract_vehical.contract_no=cr2.contract_no 
    and contract_vehical.contract_seq_number=cr2.contract_seq_number,
    contract c2 left outer join outlet on 
    c2.con_lodgement_office=outlet.outlet_id and c2.con_base_office=outlet.outlet_id,
    FUEL_TYPE left outer join vehicle on FUEL_TYPE.ft_key=vehicle.ft_key,
    VEHICLE v2 left outer join CONTRACT_VEHICAL cv2 on v2.vehicle_number=cv2.vehicle_number
where
    ((outlet.region_id = @region and  @region <> -1) or
    (@region = -1)) and ((outlet.outlet_id = @outlet and
    @outlet <> -1) or(@outlet = -1))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_vehiclesum_capacity : 
--

CREATE procedure [rd].[sp_vehiclesum_capacity](
@inRegion int,
@inOutlet int)
as
begin
  declare @nUpto2Litres int
  declare @nAt2Litres int
  declare @nOver2Litres int
  declare @nUnknown int
  select @nUpto2Litres=Count(distinct vehicle.vehicle_number) 
  from
    outlet join contract on outlet.outlet_id = contract.con_base_office,
    contract c2 join contract_renewals on
    c2.contract_no = contract_renewals.contract_no and
    c2.con_active_sequence = contract_renewals.contract_seq_number,
    contract_renewals cr2 join contract_vehical on
    cr2.contract_no = contract_vehical.contract_no and
    cr2.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A',
    contract_vehical cv2 join vehicle on cv2.vehicle_number=vehicle.vehicle_number
  where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    vehicle.v_vehicle_cc_rating < 2000
  select @nAt2Litres=Count(distinct vehicle.vehicle_number)  
  from  
    outlet join contract on outlet.outlet_id = contract.con_base_office,
    contract c2 join contract_renewals on
    c2.contract_no = contract_renewals.contract_no and
    c2.con_active_sequence = contract_renewals.contract_seq_number,
    contract_renewals cr2 join contract_vehical on
    cr2.contract_no = contract_vehical.contract_no and
    cr2.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A',
    contract_vehical cv2 join vehicle on cv2.vehicle_number=vehicle.vehicle_number
where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    vehicle.v_vehicle_cc_rating = 2000
  select @nOver2Litres=Count(distinct vehicle.vehicle_number)  
  from  
    outlet join contract on outlet.outlet_id = contract.con_base_office,
    contract c2 join contract_renewals on
    c2.contract_no = contract_renewals.contract_no and
    c2.con_active_sequence = contract_renewals.contract_seq_number,
    contract_renewals cr2 join contract_vehical on
    cr2.contract_no = contract_vehical.contract_no and
    cr2.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A',
    contract_vehical cv2 join vehicle on cv2.vehicle_number=vehicle.vehicle_number
where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    vehicle.v_vehicle_cc_rating > 2000
  select @nUnknown=Count(distinct vehicle.vehicle_number)  
  from 
    outlet join contract on outlet.outlet_id = contract.con_base_office,
    contract c2 join contract_renewals on
    c2.contract_no = contract_renewals.contract_no and
    c2.con_active_sequence = contract_renewals.contract_seq_number,
    contract_renewals cr2 join contract_vehical on
    cr2.contract_no = contract_vehical.contract_no and
    cr2.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A',
    contract_vehical cv2 join vehicle on cv2.vehicle_number=vehicle.vehicle_number
where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    vehicle.v_vehicle_cc_rating is null
  select @nUpto2Litres,
    @nAt2Litres,
    @nOver2Litres,
    @nUnknown 
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetMailCarried : 
--

CREATE procedure [rd].[sp_GetMailCarried](
@inContract int,
@inSFKey int,
@inDeliveryDays char(7))
as
begin
  select sf_key,
    contract_no,
    mc_sequence_no,
    rf_delivery_days,
    mc_dispatch_carried,
    mc_uplift_time,
    mc_uplift_outlet,
    mc_uplift_outlet_name=(select o_name from outlet where outlet_id = mc_uplift_outlet),
    mc_set_down_time,
    mc_set_down_outlet,
    mc_set_down_outlet_name=(select o_name from outlet where outlet_id = mc_set_down_outlet),
    mc_disbanded_date,
    0,
    0,
    mc_set_down_next_day 
  from  mail_carried 
  where
    contract_no = @inContract and
    sf_key = @inSFKey and
    rf_delivery_days = @inDeliveryDays
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_vehiclesum_fueltype : 
--

CREATE procedure [rd].[sp_vehiclesum_fueltype](
@inRegion int,
@inOutlet int)
as
begin
  select fuel_type.ft_description,
    (select Count(distinct vehicle.vehicle_number) 
  from
      outlet join contract on outlet.outlet_id = contract.con_base_office,
      contract c2 join contract_renewals on
      c2.contract_no = contract_renewals.contract_no and
      c2.con_active_sequence = contract_renewals.contract_seq_number,
      contract_renewals cr2 join contract_vehical on
      cr2.contract_no = contract_vehical.contract_no and
      cr2.contract_seq_number = contract_vehical.contract_seq_number and
      contract_vehical.cv_vehical_status = 'A',
      contract_vehical cv2  join vehicle  on cv2.vehicle_number=vehicle.vehicle_number
  where
      (outlet.region_id = @inRegion or @inRegion = 0) and
      (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
      vehicle.ft_key = fuel_type.ft_key) from
    fuel_type
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_QS_Outlets : 
--

CREATE procedure [rd].[sp_QS_Outlets](@in_Region int,@in_Outlet varchar(40))
-- TJB SR4579
as -- Added lookup/return of outlet type
begin
  --  select outlet_id,
  --    o_name
  --    from outlet
  --    where(in_Region=0 or outlet.region_id=in_Region)
  --    and o_name like in_Outlet||'%' order by o_name asc
  select outlet_id,
    o_name,
    ot_outlet_type from
    outlet,outlet_type where
    (@in_Region = 0 or outlet.region_id = @in_Region) and
    o_name like @in_Outlet + '%' and
    outlet.ot_code = outlet_type.ot_code order by
    o_name asc
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Extension_CustCount2 : 
--

CREATE procedure [rd].[sp_Extension_CustCount2](@inContract int,@inComponentId int,@inUIUserId char(20))
as
begin
  select count(*) from
    contract as c,
    outlet as o where
    c.contract_no = @inContract and
    o.outlet_id = c.con_lodgement_office and
    exists(select rds_user_rights.region_id from
      rds_user_rights,
      rds_user_id,
      rds_user_id_group where
      rds_user_id.ui_id = rds_user_id_group.ui_id and
      rds_user_id_group.ug_id = rds_user_rights.ug_id and
      (rds_user_rights.rur_create = 'Y') and
      (rds_user_id.ui_userid = @inUIUserId) and
      (rds_user_rights.rc_id = @inComponentId) and
      (o.region_id = rds_user_rights.region_id or
      (rds_user_rights.region_id = 0 and o.region_id = 
      (select rds_user.region_id from
        rds_user where
        rds_user.u_id = rds_user_id.u_id)) or
      (rds_user_rights.region_id = 0 and-1 = 
      (select rds_user.region_id from
        rds_user where
        rds_user.u_id = rds_user_id.u_id))))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function VolRegionV2 : 
--

CREATE function [rd].[VolRegionV2](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns int
as
begin
  declare @iReturn int,
  @iTotal decimal(12,2),
  @iTotalExtn int
  select @iReturn=0
  select @iTotal = sum(isnull(contract_renewals.con_volume_at_renewal,0)) 
    from contract,
    contract_renewals,
    outlet,
    types_for_contract where
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.con_base_office = outlet.outlet_id) and
    (types_for_contract.contract_no = contract.contract_no) and
    ((contract.con_date_terminated is null)) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @iTotalExtn = sum(isnull(frequency_distances.fd_volume,0)) 
    from contract,
    frequency_distances,
    route_frequency,
    rate_days,
    contract_renewals,
    outlet,
    types_for_contract where
    (contract.contract_no = frequency_distances.contract_no) and
    (route_frequency.contract_no = frequency_distances.contract_no) and
    (route_frequency.sf_key = frequency_distances.sf_key) and
    (route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days) and
    (route_frequency.sf_key = rate_days.sf_key) and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (rate_days.rr_rates_effective_date = contract_renewals.con_rates_effective_date) and
    (contract.con_base_office = outlet.outlet_id) and
    (types_for_contract.contract_no = contract.contract_no) and
    ((contract.con_date_terminated is null) and
    (frequency_distances.fd_effective_date >= contract_renewals.con_start_date)) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @iReturn=isnull(@iTotal,0)+isnull(@iTotalExtn,0)
  if @iReturn = 0
    select @iReturn=null
  return @iReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function NZPRegion : 
--

CREATE function [rd].[NZPRegion](@inRegion int,@inOutlet int,@inRenGroup int)
returns decimal(10,2)
as
begin
  declare @dReturn decimal(10,2),
  @dTotal decimal(10,2)
  select @dTotal = sum(isnull(contract_renewals.con_renewal_payment_value,0))
    from contract_renewals join
    "contract" as aa on
    contract_renewals.contract_no = aa.contract_no and
    contract_renewals.contract_seq_number = aa.con_active_sequence,
    "contract" join
    outlet on
    "contract".con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    "contract".con_date_terminated is null and
    (contract_renewals.contract_no = "contract".contract_no) and
    (contract_renewals.contract_seq_number = "contract".con_active_sequence) and
    ("contract".rg_code = @inRenGroup or @inRenGroup = 0)
  select @dReturn=isnull(@dTotal,0)
  select @dTotal = sum(isnull(frequency_adjustments.fd_amount_to_pay,0))
    from contract_renewals join
    "contract" as aa on
    contract_renewals.contract_no = aa.contract_no and
    contract_renewals.contract_seq_number = aa.con_active_sequence join
    frequency_adjustments on
    contract_renewals.contract_no = frequency_adjustments.contract_no and
    contract_renewals.contract_seq_number = frequency_adjustments.contract_seq_number and
    frequency_adjustments.fd_confirmed = 'Y',
    "contract" join
    outlet on
    "contract".con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    "contract".con_date_terminated is null and
    (contract_renewals.contract_no = "contract".contract_no) and
    (contract_renewals.contract_seq_number = "contract".con_active_sequence) and
    ("contract".rg_code = @inRenGroup or @inRenGroup = 0)
  select @dReturn=@dReturn+isnull(@dTotal,0)
  select @dTotal = sum(isnull(contract_allowance.ca_annual_amount,0))
    from contract_renewals join
    "contract" as aa on
    contract_renewals.contract_no = aa.contract_no and
    contract_renewals.contract_seq_number = aa.con_active_sequence join
    contract_allowance on
    contract_renewals.contract_no = contract_allowance.contract_no,
    "contract" join
    outlet on
    "contract".con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    "contract".con_date_terminated is null and
    (contract_renewals.contract_no = "contract".contract_no) and
    (contract_renewals.contract_seq_number = "contract".con_active_sequence) and
    ("contract".rg_code = @inRenGroup or @inRenGroup = 0)
  select @dReturn=@dReturn+isnull(@dTotal,0)
  if @dReturn = 0
    select @dReturn=null
  return @dReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_contract : 
--

CREATE procedure [rd].[sp_DDDW_contract](@outletid int,@rgcode int,@conttype int,@regionid int)
as
begin
  select contract.contract_no,
    contract.con_title from contract left outer join renewal_group on contract.rg_code = renewal_group.rg_code
    left outer join types_for_contract on contract.contract_no = types_for_contract.contract_no,
    outlet where contract.con_base_office = outlet.outlet_id and((contract.rg_code = @rgcode and @rgcode is not null and @rgcode <> -1) or(1 = 1 and @rgcode = -1)) and((outlet.outlet_id = @outletid and @outletid is not null and @outletid <> -1) or(1 = 1 and @outletid = -1)) and((outlet.region_id = @regionid and @regionid is not null and @regionid <> -1) or(1 = 1 and @regionid = -1)) and((types_for_contract.ct_key = @conttype and @conttype is not null and @conttype <> -1) or(1 = 1 and @conttype = -1)) order by contract.con_title asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function NZPAllowance : 
--

CREATE function [rd].[NZPAllowance](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns decimal(10,2)
as
begin
  declare @dTotal decimal(10,2)
  select @dTotal = sum(isnull(contract_allowance.ca_annual_amount,0)) 
    from contract_allowance,
    contract,
    contract_renewals,
    outlet where
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_no = contract_allowance.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (outlet.outlet_id = contract.con_base_office) and
    (contract.con_date_terminated is null) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  return @dTotal
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_FindContractsForProc2001 : 
--

CREATE procedure [rd].[sp_FindContractsForProc2001](@in_Region int,@in_RgCode int,@in_Contract int)
as
begin
  select contract.contract_no,
    contract.con_active_sequence,
    max_sequence=contract_renewals.contract_seq_number,
    contract.con_title,
    con_acceptance_flag from
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id join
    contract_renewals on
    (contract.contract_no = contract_renewals.contract_no and
    contract_renewals.contract_seq_number = (select max(contract_seq_number) from
      contract_renewals where
      contract_renewals.contract_no = contract.contract_no)/*--By HYang,0*/) where
    (contract.contract_no = @in_Contract or @in_Contract is null) and
    contract.con_date_terminated is null and
    (contract.rg_code = @in_RgCode or @in_RgCode is null) and
    (outlet.region_id = @in_Region or @in_Region is null) and
    (contract_renewals.contract_seq_number > contract.con_active_sequence or
    contract.con_active_sequence is null or
    contract_renewals.con_rates_effective_date < (select max(nvr_rates_effective_date) from
      non_vehicle_rate where
      rg_code = (select rg_code from contract as c where c.contract_no = contract_renewals.contract_no))) order by
    contract.contract_no asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE FUNCTION [rd].[PickupVolumes](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
RETURNS numeric(12,2)
AS
BEGIN
  declare @dReturn numeric(12,2),
  @dTotal numeric(12,2)
--  create table #avg_temp(
--    inward_avg float null,
--    con_num int null,
--    )
  /* Watcom only
    local temporary table avg_temp(
    inward_avg double null,
    con_num int null,
    ) on commit delete rows
  */ -- take average - to avoid contracts with more than one entry being recorded twice
select @dTotal = sum(inward_avg) from 
(
    select 
inward_avg = avg((isnull(ac.ac_w2_inward_mail,0)+isnull(ac.ac_w1_inward_mail,0))*ac.ac_scale_factor),
con_num = ac.contract_no 
from
      artical_count as ac,contract as con join contract_renewals as cr on con.contract_no = cr.contract_no,outlet as outl where
      ac.contract_no = con.contract_no and
      ac.contract_seq_number = con.con_active_sequence and
      cr.contract_seq_number = con.con_active_sequence and
      con.con_date_terminated is null and
      cr.con_expiry_date > rd.today() and
      con.con_base_office = outl.outlet_id and
      (outl.outlet_id = @inOutlet or @inOutlet = 0) and
      (outl.region_id = @inRegion or @inRegion = 0) and
      ((con.con_base_cont_type = @inContractType and @inContractType > 0) or(@inContractType = 0 or @inContractType is null)) and
      (con.rg_code = @inRenGroup or @inRenGroup = 0)
      group by ac.contract_no
) as avt
 where
    avt.con_num is not null
  select @dReturn=isnull(@dTotal,0)
  return @dReturn

END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_myp_month_expenditure_total : 
--

--
-- Definition for user-defined function f_myp_month_expenditure_total : 
--

CREATE function [rd].[f_myp_month_expenditure_total](@region int,@outlet int,@contract int,@mo int,@yr int)
returns decimal
as
begin
  declare @decAmount decimal
  select @decAmount=sum(isnull(piece_rate_delivery.prd_quantity,0)*isnull(piece_rate.pr_rate,0)) from
    piece_rate,
    piece_rate_delivery,
    piece_rate_supplier,
    piece_rate_type,
    contract,
    outlet,
    renewal_group where
    (piece_rate.prt_key = piece_rate_delivery.prt_key) and
    (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
    (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
    (piece_rate_type.prt_key = piece_rate.prt_key) and
    (contract.contract_no = piece_rate_delivery.contract_no) and
    (outlet.outlet_id = contract.con_base_office) and
    (renewal_group.rg_code = contract.rg_code) and
    (renewal_group.rg_code = piece_rate.rg_code) and
    (month(piece_rate_delivery.prd_date) = @mo) and
    (year(piece_rate_delivery.prd_date) = @yr) and
    ((outlet.region_id = -1 and
    -1 <> -1) or
    (-1 = -1)) and
    ((outlet.outlet_id = -1 and
    -1 <> -1) or
    (-1 = -1)) and
    ((contract.contract_no = -1 and
    -1 <> -1) or
    (-1 = -1))
  return(@decAmount)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure ps_Renewal_Information : 
--

CREATE procedure [rd].[ps_Renewal_Information](@inRegion int,@inYearStart datetime,@inMonthEnd datetime,@outYTDDelHours decimal(12,2) output,@outYTDSortHours decimal(12,2) output,@outYTDDistance decimal(12,2) output,@outMonthDelHours decimal(12,2) output,@outMonthSortHours decimal(12,2) output,@outMonthDistance decimal(12,2) output) 
as
begin
  declare @decRenewalDelHours decimal(12,2),
  @decExtnDelHours decimal(12,2),
  @decRenewalDistance decimal(12,2),
  @decExtnDistance decimal(12,2),
  @decRenewalSortHours decimal(12,2),
  @decExtnSortHours decimal(12,2),
  @dMonthStart datetime
  select @dMonthStart=rd.ymd(year(@inMonthEnd),month(@inMonthEnd),1)
  select @decRenewalDelHours = sum(contract_renewals.con_del_hrs_week_at_renewal),
		 @decRenewalSortHours = sum(contract_renewals.con_processing_hours_per_week),
		 @decRenewalDistance = sum(contract_renewals.con_distance_at_renewal) 
     from contract_renewals join 
    contract on
    contract_renewals.contract_no = contract.contract_no and
    contract_renewals.contract_seq_number = contract.con_active_sequence and
    (contract.con_date_terminated is null or
    contract.con_date_terminated > @inYearStart) join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0)

  select @decExtnDelHours = sum(frequency_distances.fd_delivery_hrs_per_week),
@decExtnSortHours = sum(frequency_distances.fd_processing_hrs_week),
@decExtnDistance = sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum) 
     from frequency_distances join
    contract on
    frequency_distances.contract_no = contract.contract_no and
    (contract.con_date_terminated is null or
    contract.con_date_terminated > @inYearStart) join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) join
    contract_renewals on
    contract.contract_no = contract_renewals.contract_no and
    contract.con_active_sequence = contract_renewals.contract_seq_number,
    rate_days where
    frequency_distances.sf_key = rate_days.sf_key and
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
    fd_effective_date between @inYearStart and @inMonthEnd
  select @outYTDDelHours=isnull(@decRenewalDelHours,0)+isnull(@decExtnDelHours,0)
  select @outYTDSortHours=isnull(@decRenewalSortHours,0)+isnull(@decExtnSortHours,0)
  select @outYTDDistance=isnull(@decRenewalDistance,0)+isnull(@decExtnDistance,0)
  select @decExtnDelHours = sum(frequency_distances.fd_delivery_hrs_per_week),
	@decExtnSortHours = sum(frequency_distances.fd_processing_hrs_week),
	@decExtnDistance = sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum)
     from frequency_distances join
    contract on
    frequency_distances.contract_no = contract.contract_no and
    (contract.con_date_terminated is null or
    contract.con_date_terminated > @inYearStart) join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) join
    contract_renewals on
    contract.contract_no = contract_renewals.contract_no and
    contract.con_active_sequence = contract_renewals.contract_seq_number,
    rate_days where
    frequency_distances.sf_key = rate_days.sf_key and
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
    fd_effective_date between @inYearStart and @inMonthEnd
  select @outMonthDelHours=isnull(@decExtnDelHours,0)
  select @outMonthSortHours=isnull(@decExtnSortHours,0)
  select @outMonthDistance=isnull(@decExtnDistance,0)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function RDBagsRegion : 
--

CREATE function [rd].[RDBagsRegion](@inRegion int,@inOutlet int,@inRenGroup int)
returns int
as
begin
  declare @iReturn int,
  @iTotal int
  select @iTotal = sum(isnull(contract_renewals.con_no_rural_private_bags_at_renewal,0)) 
    from contract_renewals join
    contract on
    contract_renewals.contract_no = contract.contract_no and
    contract_renewals.contract_seq_number = contract.con_active_sequence join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    contract.contract_no = any(select types_for_contract.contract_no from
      types_for_contract join
      contract_type on contract_type.ct_key = types_for_contract.ct_key where 
      contract_type.ct_rd_ref_mandatory = 'Y') and
    contract.con_date_terminated is null and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @iReturn=@iReturn+isnull(@iTotal,0)
  select @iReturn=isnull(@iTotal,0)
  select @iTotal = sum(isnull(frequency_distances.fd_no_rural_bags,0)) 
    from contract_renewals join
    contract on
    contract_renewals.contract_no = contract.contract_no and
    contract_renewals.contract_seq_number = contract.con_active_sequence join
    frequency_distances on
    contract_renewals.contract_no = frequency_distances.contract_no and
    contract_renewals.con_start_date <= frequency_distances.fd_effective_date join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    contract.contract_no = any(select types_for_contract.contract_no from
      types_for_contract join 
      contract_type on  contract_type.ct_key = types_for_contract.ct_key where
      contract_type.ct_rd_ref_mandatory = 'Y') and
    contract.con_date_terminated is null and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @iReturn=@iReturn+isnull(@iTotal,0)
  if @iReturn = 0
    select @iReturn=null
  return @iReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure ps_count_articles : 
--

CREATE procedure [rd].[ps_count_articles](@inRegion int,@inYearStart datetime,@inMonthEnd datetime,@outLetters int output,@outSmallParcels int output,@outLargeParcels int output,@outExtnLetters int output,@outExtnSmallParcels int output,@outExtnLargeParcels int output) 
as
begin
  -- TJB  SR4684  June 2006
  -- Reformatted for legibility
  declare @iTotLetters decimal(12),
  @iTotSmallPar decimal(12),
  @iTotLargePar decimal(12),
  @iVolume decimal(12),
  @iExtnVolume decimal(12),
  @fLetters real,
  @fSmallPar real,
  @fLargePar real,
  @dMonthStart datetime,
  @dEndLastFinYear datetime,
  @decMonths decimal(10,5),
  @iExtnLetters decimal(12),
  @iExtnSmallParcels decimal(12),
  @iExtnLargeParcels decimal(12)
  /* Watcom only
  err_notfound exception for sqlstate value '02000'
  */
  select @iTotLetters=sum((isnull(ac_w1_medium_letters,0)+
    isnull(ac_w1_other_envelopes,0)+
    isnull(ac_w2_medium_letters,0)+
    isnull(ac_w2_other_envelopes,0))*
    ac_scale_factor),
    @iTotSmallPar=sum((isnull(ac_w1_small_parcels,0)+
    isnull(ac_w2_small_parcels,0))*
    ac_scale_factor),
    @iTotLargePar=sum((isnull(ac_w1_large_parcels,0)+
    isnull(ac_w2_large_parcels,0))*
    ac_scale_factor)
     from artical_count join contract on
    artical_count.contract_no = contract.contract_no and
    artical_count.contract_seq_number = contract.con_active_sequence and
    (contract.con_date_terminated is null or
    contract.con_date_terminated > @inYearStart) join outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) where
    artical_count.contract_seq_number is not null
  select @iVolume=isnull(@iTotLetters,0)+
    isnull(@iTotSmallPar,0)+
    isnull(@iTotLargePar,0)
  select @fLetters=@iTotLetters/@iVolume
  select @fSmallPar=@iTotSmallPar/@iVolume
  select @fLargePar=@iTotLargePar/@iVolume
  select @iVolume = sum(contract_renewals.con_volume_at_renewal) 
    from contract_renewals join contract on
    contract_renewals.contract_no = contract.contract_no and
    contract_renewals.contract_seq_number = contract.con_active_sequence and
    (contract.con_date_terminated is null or
    contract.con_date_terminated > @inYearStart) join outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0)
  select @iExtnVolume = sum(fd_volume) 
    from frequency_distances join contract on
    frequency_distances.contract_no = contract.contract_no and
    (contract.con_date_terminated is null or
    contract.con_date_terminated > @inYearStart) join outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) where
    fd_effective_date between @inYearStart and @inMonthEnd
  select @dEndLastFinYear=rd.ymd(year(@inYearStart),3,1)
  select @decMonths=datediff(month,@dEndLastFinYear,@inMonthEnd)
  select @decMonths=@decMonths/12
  select @iVolume=((isnull(@iVolume,0)+isnull(@iExtnVolume,0)))*@decMonths
  select @outLetters=@iVolume*@fLetters
  select @outSmallParcels=@iVolume*@fSmallPar
  select @outLargeParcels=@iVolume*@fLargePar
  select @dMonthStart=rd.ymd(year(@inMonthEnd),month(@inMonthEnd),1)
  select @iVolume = sum(fd_volume)
    from frequency_distances join contract on
    frequency_distances.contract_no = contract.contract_no and
    (contract.con_date_terminated is null or
    contract.con_date_terminated > @inYearStart) join outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) where
    fd_effective_date between @dMonthStart and @inMonthEnd
  select @outExtnLetters=@iVolume*@fLetters
  select @outExtnSmallParcels=@iVolume*@fSmallPar
  select @outExtnLargeParcels=@iVolume*@fLargePar
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_DDDW_rb_contract : 
--

CREATE procedure [rd].[sp_DDDW_rb_contract](@regionid int,@outletid int,@rgcode int,@conttype int,@sfkey int)
as
begin select contract.contract_no,contract.con_title 
from contract left outer join renewal_group on contract.rg_code = renewal_group.rg_code
left outer join types_for_contract on contract.contract_no = types_for_contract.contract_no
left outer join route_frequency on contract.contract_no = route_frequency.contract_no,outlet 
where contract.con_base_office = outlet.outlet_id 
and((contract.rg_code = @rgcode and @rgcode is not null and @rgcode <> -1) 
or(1 = 1 and @rgcode = -1)) and((outlet.outlet_id = @outletid 
and @outletid is not null and @outletid <> -1) or(1 = 1 and @outletid = -1)) 
and((outlet.region_id = @regionid and @regionid is not null and @regionid <> -1) 
or(1 = 1 and @regionid = -1)) and((types_for_contract.ct_key = @conttype 
and @conttype is not null and @conttype <> -1) or(1 = 1 and @conttype = -1)) 
and((route_frequency.sf_key = @sfkey and @sfkey is not null and @sfkey <> -1)
 or(@sfkey = -1)) union select-1,'<All>'  order by 2 asc end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_report_search : 
--

CREATE procedure [rd].[sp_report_search](@inRegion int,@inOutlet int,@inRGCode int,@inSFKey int,@inCTKey int)
as
begin
  select distinct contract.contract_no,
    contract.con_active_sequence,
    con_title from
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id join
    types_for_contract on
    contract.contract_no = types_for_contract.contract_no join
    route_frequency on
    contract.contract_no = route_frequency.contract_no where
    (outlet.region_id = @inRegion or @inRegion is null) and
    (outlet.outlet_id = @inOutlet or @inOutlet is null) and
    (contract.rg_code = @inRGCode or @inRGCode is null) and
    (route_frequency.sf_key = @inSFKey or @inSFKey is null) and
    (types_for_contract.ct_key = @inCTKey or @inCTKey is null) and
    contract.con_active_sequence is not null and
    (contract.con_date_terminated is null or
    contract.con_date_terminated >= getdate()) order by
    contract.con_title asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_myp_month_item_exp_total : 
--

CREATE function [rd].[f_myp_month_item_exp_total](@region int,@outlet int,@contract int,@mo int,@yr int,@prs int,@prt int)
returns decimal
as
begin
  declare @decAmount decimal
  select @decAmount=sum(isnull(piece_rate_delivery.prd_quantity,0)*isnull(piece_rate.pr_rate,0)) from
    piece_rate,
    piece_rate_delivery,
    piece_rate_supplier,
    piece_rate_type,
    contract,
    outlet,
    renewal_group where
    (piece_rate.prt_key = piece_rate_delivery.prt_key) and
    (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
    (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
    (piece_rate_type.prt_key = piece_rate.prt_key) and
    (contract.contract_no = piece_rate_delivery.contract_no) and
    (outlet.outlet_id = contract.con_base_office) and
    (renewal_group.rg_code = contract.rg_code) and
    (renewal_group.rg_code = piece_rate.rg_code) and
    (month(piece_rate_delivery.prd_date) = @mo) and
    (year(piece_rate_delivery.prd_date) = @yr) and
    ((outlet.region_id = -1 and
    -1 <> -1) or
    (-1 = -1)) and
    ((outlet.outlet_id = -1 and
    -1 <> -1) or
    (-1 = -1)) and
    ((contract.contract_no = -1 and
    -1 <> -1) or
    (-1 = -1))
  return(@decAmount)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function CoreContract : 
--

--
-- Definition for user-defined function CoreContract : 
--

CREATE function  [rd].[CoreContract](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns decimal(10,2)
as
begin
  declare @dReturn decimal(10,2),
  @dTotal decimal(10,2)
  select @dTotal = sum(isnull(contract_renewals.con_renewal_payment_value,0))
    from  contract INNER JOIN
    contract_renewals ON contract.contract_no = contract_renewals.contract_no INNER JOIN
    outlet ON contract.con_base_office = outlet.outlet_id INNER JOIN
    types_for_contract ON contract.contract_no = types_for_contract.contract_no where
--    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
--    (contract.con_base_office = outlet.outlet_id) and
--    (types_for_contract.contract_no = contract.contract_no) and
    ((contract.con_date_terminated is null)) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @dReturn=isnull(@dTotal,0)
  select @dTotal = sum(isnull(frequency_adjustments.fd_amount_to_pay,0))
    from  contract INNER JOIN
    contract_renewals ON contract.contract_no = contract_renewals.contract_no INNER JOIN
    outlet ON contract.con_base_office = outlet.outlet_id INNER JOIN
    frequency_adjustments ON contract.contract_no = frequency_adjustments.contract_no where
--    (contract_renewals.contract_no = contract.contract_no) and
--    (contract_renewals.contract_no = frequency_adjustments.contract_no) and
    (contract_renewals.contract_seq_number = frequency_adjustments.contract_seq_number) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
--    (outlet.outlet_id = contract.con_base_office) and
    (frequency_adjustments.fd_confirmed = 'Y') and
    (contract.con_date_terminated is null) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @dReturn=@dReturn+isnull(@dTotal,0)
  return @dReturn
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRenewalRatesWithRegion2001 : 
--

CREATE procedure [rd].[sp_GetRenewalRatesWithRegion2001](@inregion int)
as
begin
  if @inregion > 0
    select distinct non_vehicle_rate.rg_code,
      non_vehicle_rate.nvr_rates_effective_date,
      non_vehicle_rate.nvr_frozen_indicator from
      contract,
      outlet,
      non_vehicle_rate where
      outlet.outlet_id = contract.con_lodgement_office and
      contract.rg_code = non_vehicle_rate.rg_code and
      outlet.region_id = @inregion order by
      non_vehicle_rate.nvr_rates_effective_date asc
  else
    select distinct non_vehicle_rate.rg_code,
      non_vehicle_rate.nvr_rates_effective_date,
      non_vehicle_rate.nvr_frozen_indicator from
      non_vehicle_rate order by
      2 asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRegionArticalCounts : 
--

CREATE procedure [rd].[sp_GetRegionArticalCounts](
@in_Region int,
@in_RenewalGroup int,
@in_Period datetime)
as
begin
  select artical_count.contract_no,
    artical_count.ac_start_week_period,
    artical_count.ac_w1_medium_letters,
    artical_count.ac_w1_other_envelopes,
    artical_count.ac_w1_small_parcels,
    artical_count.ac_w1_large_parcels,
    artical_count.ac_w1_inward_mail,
    artical_count.ac_w2_medium_letters,
    artical_count.ac_w2_other_envelopes,
    artical_count.ac_w2_small_parcels,
    artical_count.ac_w2_large_parcels,
    artical_count.ac_w2_inward_mail,'U'
 from
    artical_count join contract on artical_count.contract_no=contract.contract_no join outlet as fk_base_office
    on contract.con_lodgement_office=fk_base_office.outlet_id   
where
    fk_base_office.region_id = @in_Region and
    contract.rg_code = @in_RenewalGroup and
    (contract.con_date_terminated is null or contract.con_date_terminated > @in_Period) and
    artical_count.ac_start_week_period = @in_Period union
  select contract.contract_no,
    @in_Period,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,'A' from
    contract join outlet as fk_base_office on contract.con_lodgement_office=fk_base_office.outlet_id
 where
    fk_base_office.region_id = @in_Region and
    (contract.con_date_terminated is null or contract.con_date_terminated > @in_Period) and
    contract.rg_code = @in_RenewalGroup and
    0 = (select count(*) from
      artical_count where
      artical_count.contract_no = contract.contract_no and
      (contract.con_date_terminated is null or contract.con_date_terminated > @in_Period) and
      artical_count.ac_start_week_period = @in_Period)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_myp_month_item_total : 
--

CREATE function [rd].[f_myp_month_item_total](@region int,@outlet int,@contract int,@mo int,@yr int,@prs int,@prt int)
returns decimal
as
begin
  declare @decAmount decimal
  select @decAmount=sum(isnull(piece_rate_delivery.prd_quantity,0)) from
    piece_rate,
    piece_rate_delivery,
    piece_rate_supplier,
    piece_rate_type,
    contract,
    outlet,
    renewal_group where
    (piece_rate.prt_key = piece_rate_delivery.prt_key) and
    (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
    (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
    (piece_rate_type.prt_key = piece_rate.prt_key) and
    (contract.contract_no = piece_rate_delivery.contract_no) and
    (outlet.outlet_id = contract.con_base_office) and
    (renewal_group.rg_code = contract.rg_code) and
    (renewal_group.rg_code = piece_rate.rg_code) and
    (month(piece_rate_delivery.prd_date) = @mo) and
    (year(piece_rate_delivery.prd_date) = @yr) and
    (piece_rate_type.prt_key = @prt) and
    (piece_rate_supplier.prs_key = @prs) and
    ((outlet.region_id = -1 and
    -1 <> -1) or
    (-1 = -1)) and
    ((outlet.outlet_id = -1 and
    -1 <> -1) or
    (-1 = -1)) and
    ((contract.contract_no = -1 and
    -1 <> -1) or
    (-1 = -1))
  return(@decAmount)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function AnnualVolume : 
--

--
-- Definition for user-defined function AnnualVolume : 
--

CREATE function [rd].[AnnualVolume](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns decimal(12,2)
as
begin
  declare @dReturn decimal(12,2),
  @dTotal decimal(12,2)
  select @dTotal=sum(contract_renewals.con_volume_at_renewal) 
    from contract,
    contract_renewals,
    outlet,
    types_for_contract where
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.con_base_office = outlet.outlet_id) and
    (types_for_contract.contract_no = contract.contract_no) and
    ((contract.con_date_terminated is null)) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @dReturn=isnull(@dTotal,0)
  select @dTotal=sum(frequency_distances.fd_volume)
    from contract,
    frequency_distances,
    route_frequency,
    rate_days,
    contract_renewals,
    outlet,
    types_for_contract where
    (contract.contract_no = frequency_distances.contract_no) and
    (route_frequency.contract_no = frequency_distances.contract_no) and
    (route_frequency.sf_key = frequency_distances.sf_key) and
    (route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days) and
    (route_frequency.sf_key = rate_days.sf_key) and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (rate_days.rr_rates_effective_date = contract_renewals.con_rates_effective_date) and
    (contract.con_base_office = outlet.outlet_id) and
    (types_for_contract.contract_no = contract.contract_no) and
    ((contract.con_date_terminated is null) and
    (frequency_distances.fd_effective_date >= contract_renewals.con_start_date)) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @dReturn=@dReturn+isnull(@dTotal,0)
  return @dReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_myp_month_total : 
--

CREATE function [rd].[f_myp_month_total](@region int,@outlet int,@contract int,@mo int,@yr int)
returns decimal
as
begin
  declare @decAmount decimal
  select @decAmount=sum(isnull(piece_rate_delivery.prd_quantity,0)) from
    piece_rate,
    piece_rate_delivery,
    piece_rate_supplier,
    piece_rate_type,
    contract,
    outlet,
    renewal_group where
    piece_rate.prt_key = piece_rate_delivery.prt_key and
    piece_rate_supplier.prs_key = piece_rate_type.prs_key and
    piece_rate_type.prt_key = piece_rate_delivery.prt_key and
    piece_rate_type.prt_key = piece_rate.prt_key and
    contract.contract_no = piece_rate_delivery.contract_no and
    outlet.outlet_id = contract.con_base_office and
    renewal_group.rg_code = contract.rg_code and
    renewal_group.rg_code = piece_rate.rg_code and
    month(piece_rate_delivery.prd_date) = @mo and
    year(piece_rate_delivery.prd_date) = @yr and
    ((outlet.region_id = -1 and @region <> -1) or
    (@region = -1)) and
    ((outlet.outlet_id = -1 and
    @outlet <> -1) or
    (@outlet = -1)) and
    ((contract.contract_no = -1 and
    @contract <> -1) or
    (@contract = -1))
  return(@decAmount)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE function [rd].[VolRegion](@inRegion int,@inOutlet int,@inRenGroup int)
returns int
as
begin
  declare @iReturn int,
  @iTotal decimal(12,2),
  @iTotalExtn int
  select @iReturn=0
  select @iTotal = sum(isnull(contract_renewals.con_volume_at_renewal,0))
    from contract_renewals join
    contract as con on
    contract_renewals.contract_no = con.contract_no and
    contract_renewals.contract_seq_number = con.con_active_sequence,
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    contract.contract_no = any(select types_for_contract.contract_no from
      types_for_contract join
      contract_type ON types_for_contract.ct_key = contract_type.ct_key where
      contract_type.ct_rd_ref_mandatory = 'Y') and
    contract.con_date_terminated is null and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @iTotalExtn = sum(isnull(frequency_distances.fd_volume,0))  
    from contract_renewals join
    contract as con on
    contract_renewals.contract_no = con.contract_no and
    contract_renewals.contract_seq_number = con.con_active_sequence join
    frequency_distances on
    contract_renewals.contract_no = frequency_distances.contract_no and
    contract_renewals.con_start_date <= frequency_distances.fd_effective_date,
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    contract.contract_no = any(select types_for_contract.contract_no from
      types_for_contract join
      contract_type ON types_for_contract.ct_key = contract_type.ct_key where
      contract_type.ct_rd_ref_mandatory = 'Y') and
    contract.con_date_terminated is null and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @iReturn=isnull(@iTotal,0)+isnull(@iTotalExtn,0)
  if @iReturn = 0
    select @iReturn=null
  return @iReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractsForWhatIf : 
--

--
-- Definition for stored procedure sp_GetContractsForWhatIf : 
--

CREATE procedure [rd].[sp_GetContractsForWhatIf](@inRegion int,@inRGCode int)
as
begin
  select contract.contract_no,
    contract.con_title,
    max(contract_renewals.contract_seq_number) from
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id join
    contract_renewals on
    contract.contract_no = contract_renewals.contract_no where
    (contract.rg_code = @inRGCode or @inRGCode = 0) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (con_date_terminated is null or con_date_terminated > getdate())
    group by contract.contract_no,contract.con_title order by
    contract.contract_no asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_myp_year_total : 
--

CREATE function [rd].[f_myp_year_total](@region int,@outlet int,@contract int)
returns decimal
as
begin
  declare @decAmount decimal
  select @decAmount=  sum(isnull(piece_rate_delivery.prd_quantity,0)) from
    piece_rate,
    piece_rate_delivery,
    piece_rate_supplier,
    piece_rate_type,
    contract,
    outlet,
    renewal_group where
    (piece_rate.prt_key = piece_rate_delivery.prt_key) and
    (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
    (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
    (piece_rate_type.prt_key = piece_rate.prt_key) and
    (contract.contract_no = piece_rate_delivery.contract_no) and
    (outlet.outlet_id = contract.con_base_office) and
    (renewal_group.rg_code = contract.rg_code) and
    (renewal_group.rg_code = piece_rate.rg_code) and
    (month(piece_rate_delivery.prd_date) = month(getdate())) and  --! month(getdate()) was 'mo'
    (year(piece_rate_delivery.prd_date) = year(getdate())) and   --! year(getdate()) was 'yr'
    ((outlet.region_id = -1 and
    -1 <> -1) or
    (-1 = -1)) and
    ((outlet.outlet_id = -1 and
    -1 <> -1) or
    (-1 = -1)) and
    ((contract.contract_no = -1 and
    -1 <> -1) or
    (-1 = -1))
  return(@decAmount)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractODPS : 
--

--
-- Definition for stored procedure sp_GetContractODPS : 
--

CREATE procedure [rd].[sp_GetContractODPS](@in_Contract int)
-- TJB SR4579: Add lookup and return of base and lodgment outlet type values
as --    (con_base_office_type and con_lodgment_office_type)
begin
  select contract.contract_no,
    contract.rg_code,
    contract.con_old_mail_service_no,
    contract.con_title,
    contract.con_rd_paper_file_text,
    contract.con_rcm_paper_file_text,
    contract.con_base_office,
    con_base_office_name=(select outlet.o_name from outlet where outlet.outlet_id = contract.con_base_office),
    region_id=(select outlet.region_id from outlet where outlet_id = contract.con_base_office),
    contract.con_lodgement_office,
    con_lodgement_office_name=(select outlet.o_name from outlet where outlet.outlet_id = contract.con_lodgement_office),
    contract.con_active_sequence,
    contract.con_base_cont_type,
    contract.con_rd_ref_text,
    contract.con_last_service_review,
    contract.con_last_delivery_check,
    contract.con_last_work_msrmnt_check,
    contract.con_lngth_sealed_road,
    contract.con_lngth_unsealed_road,
    contract.con_date_terminated,'','',
    ac_id,
    message_for_invoice,
    PBU_ID,
    con_base_office_type=(select ot.ot_outlet_type from outlet_type as ot,outlet as o where
      o.outlet_id = contract.con_base_office and o.ot_code = ot.ot_code),
    con_lodgement_office_type=(select ot.ot_outlet_type from outlet_type as ot,outlet as o where
      o.outlet_id = contract.con_lodgement_office and o.ot_code = ot.ot_code) from
    contract where
    contract.contract_no = @in_Contract
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function AnnualDistance : 
--

-- SQL Manager 2005 for SQL Server (2.5.0.1)
-- ---------------------------------------
-- Host      : 10.32.1.130
-- Database  : NZDB
-- Version   : Microsoft SQL Server  9.00.1399.06


--
-- Definition for user-defined function AnnualDistance : 
--

CREATE function [rd].[AnnualDistance](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns int
as
begin
  declare @dReturn decimal(12,2)
  declare @dTotal decimal(12,2)
  select  @dTotal=sum(contract_renewals.con_distance_at_renewal)
    from contract,
    contract_renewals,
    outlet,
    types_for_contract where
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.con_base_office = outlet.outlet_id) and
    (types_for_contract.contract_no = contract.contract_no) and
    ((contract.con_date_terminated is null)) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @dReturn=isnull(@dTotal,0)
  select @dTotal=sum(frequency_distances.fd_distance*rate_days.rtd_days_per_annum)  
    from contract,
    frequency_distances,
    route_frequency,
    rate_days,
    contract_renewals,
    outlet,
    types_for_contract where
    (contract.contract_no = frequency_distances.contract_no) and
    (route_frequency.contract_no = frequency_distances.contract_no) and
    (route_frequency.sf_key = frequency_distances.sf_key) and
    (route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days) and
    (route_frequency.sf_key = rate_days.sf_key) and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (rate_days.rr_rates_effective_date = contract_renewals.con_rates_effective_date) and
    (contract.con_base_office = outlet.outlet_id) and
    (types_for_contract.contract_no = contract.contract_no) and
    ((contract.con_date_terminated is null) and
    (frequency_distances.fd_effective_date >= contract_renewals.con_start_date)) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @dReturn=@dReturn+isnull(@dTotal,0)
  return @dReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function CustsRegion : 
--

CREATE function [rd].[CustsRegion](@inRegion int,@inOutlet int,@inRenGroup int)
returns int
as
begin
  declare @iReturn integer,
  @iTotal integer
  select @iTotal = sum(iSnull(contract_renewals.con_no_customers_at_renewal,0))+
    sum(isnull(contract_renewals.con_no_cmb_custs_at_renewal,0)) 
    from contract_renewals join
    contract as aa on
    contract_renewals.contract_no = aa.contract_no and
    contract_renewals.contract_seq_number = aa.con_active_sequence,
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    contract.contract_no = any(select types_for_contract.contract_no from
      types_for_contract join
      contract_type on types_for_contract.ct_key = contract_type.ct_key 
		where
      contract_type.ct_rd_ref_mandatory = 'Y') and
    contract.con_date_terminated is null and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @iReturn=@iReturn+iSnull(@iTotal,0)
  select @iReturn=iSnull(@iTotal,0)
  select @iTotal = sum(isnull(frequency_distances.fd_no_of_boxes,0))+
    sum(isnull(frequency_distances.fd_no_cmb_customers,0))
    from contract_renewals join
    contract as aa on
    contract_renewals.contract_no = aa.contract_no and
    contract_renewals.contract_seq_number = aa.con_active_sequence join
    frequency_distances on
    contract_renewals.contract_no = frequency_distances.contract_no and
    contract_renewals.con_start_date <= frequency_distances.fd_effective_date,
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    contract.contract_no = any(select types_for_contract.contract_no from
      types_for_contract join
      contract_type on types_for_contract.ct_key = contract_type.ct_key where
      contract_type.ct_rd_ref_mandatory = 'Y') and
    contract.con_date_terminated is null and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @iReturn=@iReturn+isnull(@iTotal,0)
  if @iReturn = 0
    select @iReturn=null
  return @iReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function CustsRegionV2 : 
--

--
-- Definition for user-defined function CustsRegionV2 : 
--

CREATE function [rd].[CustsRegionV2](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns int
as
begin
  declare @iReturn integer,
  @iTotal integer
  select @iReturn=0
  select @iTotal=Count(rds_customer.cust_id)
    from
    address,
    contract,
    contract_renewals,
    customer_address_moves,
    outlet,
    rds_customer,
    types_for_contract where
    (contract.contract_no = address.contract_no) and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (customer_address_moves.adr_id = address.adr_id) and
    (rds_customer.cust_id = customer_address_moves.cust_id) and
    (types_for_contract.contract_no = contract.contract_no) and
    (contract.con_base_office = outlet.outlet_id) and
    ((rds_customer.master_cust_id is null) and
    (customer_address_moves.move_out_date is null) and
    (contract.con_date_terminated is null) and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or(@inContractType = 0 or @inContractType is null)) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0))
  select @iReturn=isnull(@iTotal,0)
  return @iReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function UnitCost : 
--

CREATE function [rd].[UnitCost](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns decimal(10,2)
as
begin
  declare @dTotal decimal(10,2)
  select @dTotal = sum(isnull(contract_allowance.ca_annual_amount,0)) 
    from contract_renewals join
    contract as con on
    contract_renewals.contract_no = con.contract_no and
    contract_renewals.contract_seq_number = con.con_active_sequence join
    contract_allowance on
    contract_renewals.contract_no = contract_allowance.contract_no,
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    contract.con_date_terminated is null and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  return @dTotal
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function DayDistRegionV2 : 
--

CREATE function [rd].[DayDistRegionV2](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns decimal(10,2)
as
begin
  /* declare
  Watcom only
  err_notfound exception for sqlstate value '02000'
  */
  declare cur_getdistance  cursor for  select sum(route_frequency.rf_distance*rate_days.rtd_days_per_annum)/max(rate_days.rtd_days_per_annum) from
      contract join
      outlet on
      contract.con_base_office = outlet.outlet_id and
      (outlet.region_id = @inRegion or @inRegion = 0) and
      (outlet.outlet_id = @inOutlet or @inOutlet = 0) join
      contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number join
      route_frequency on
      contract.contract_no = route_frequency.contract_no and
      route_frequency.rf_active = 'Y'
	  join rate_days on
      route_frequency.sf_key = rate_days.sf_key where
      contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
      contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
      ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
      (@inContractType = 0 or @inContractType is null)) and
      contract.con_date_terminated is null and
      (contract_renewals.contract_no = contract.contract_no) and
      (contract_renewals.contract_seq_number = contract.con_active_sequence) and
      (contract.rg_code = @inRenGroup or @inRenGroup = 0)
      group by contract.contract_no,contract_renewals.contract_seq_number
   declare @dDailyDistance decimal(10,2)
   declare @dTotalDailyDistance decimal(10,2)
  select @dTotalDailyDistance=0
  open cur_getdistance
  /* Watcom only
  CursorLoop:
  */while 1=1 
    begin
      fetch next  from cur_GetDistance into @dDailyDistance
      if @@fetch_status <0
        break

     /* if sqlstate = err_notfound
        break
        /* Watcom only
        CursorLoop
        */
*/
      if @dDailyDistance is not null
        select @dTotalDailyDistance=@dTotalDailyDistance+@dDailyDistance
    end
  close cur_GetDistance
  return @dTotalDailyDistance
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function DayDistRegion : 
--

CREATE function [rd].[DayDistRegion](@inRegion int,@inOutlet int,@inRenGroup int)
returns decimal(10,2)
as
begin
	/*  
		declare err_notfound exception for sqlstate value '02000'
	*/
	declare cur_getdistance cursor for 
		select sum(route_frequency.rf_distance*rate_days.rtd_days_per_annum)/max(rate_days.rtd_days_per_annum) from
      (contract join
      outlet on
      contract.con_base_office = outlet.outlet_id and
      (outlet.region_id = @inRegion or @inRegion = 0) and
      (outlet.outlet_id = @inOutlet or @inOutlet = 0) join
      contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number join
      route_frequency  as aa on
      contract.contract_no = aa.contract_no and
      aa.rf_active = 'Y'),
      route_frequency join
      rate_days on
      route_frequency.sf_key = rate_days.sf_key where
      contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
      contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
      contract.contract_no = any(select types_for_contract.contract_no from
        types_for_contract join
		contract_type on types_for_contract.ct_key = contract_type.ct_key 
		where
        contract_type.ct_rd_ref_mandatory = 'Y') and
      contract.con_date_terminated is null and
      (contract_renewals.contract_no = contract.contract_no) and
      (contract_renewals.contract_seq_number = contract.con_active_sequence) and
      (contract.rg_code = @inRenGroup or @inRenGroup = 0)
      group by contract.contract_no,contract_renewals.contract_seq_number
  declare @dDailyDistance decimal(10,2)
  declare @dTotalDailyDistance decimal(10,2)
  select @dTotalDailyDistance=0
  open cur_getdistance
  /* Watcom only
  CursorLoop:
  */while 1=1 
    begin
      fetch next from  cur_GetDistance into @dDailyDistance
      if @@fetch_status < 0
        break
        /* Watcom only
        CursorLoop
        */
      if @dDailyDistance is not null
        select @dTotalDailyDistance=@dTotalDailyDistance+@dDailyDistance
    end
  close cur_GetDistance
  return @dTotalDailyDistance
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRenewalRatesWihtRegion : 
--

CREATE procedure [rd].[sp_GetRenewalRatesWihtRegion](
@inregion int)
as
begin
  if @inregion > 0
    select distinct renewal_rate.rg_code,
      renewal_rate.rr_rates_effective_date,
      renewal_rate.rr_frozen_indicator from
      contract,
      outlet,
      renewal_rate where
      (outlet.outlet_id = contract.con_lodgement_office) and
      (contract.rg_code = renewal_rate.rg_code) and
      (outlet.region_id = @inregion) order by
      renewal_rate.rr_rates_effective_date asc
  else
    select distinct renewal_rate.rg_code,
      renewal_rate.rr_rates_effective_date,
      renewal_rate.rr_frozen_indicator from
      renewal_rate order by
      renewal_rate.rr_rates_effective_date asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_FindContractsForProc_paul : 
--

CREATE procedure [rd].[sp_FindContractsForProc_paul](@in_Region int,@in_RgCode int,@in_Contract int)
as
begin
  select contract.contract_no,
    contract.con_active_sequence,
    max_sequence=contract_renewals.contract_seq_number,
    contract.con_title,
    con_acceptance_flag from
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id join
    contract_renewals on
    (contract.contract_no = contract_renewals.contract_no and
    contract_renewals.contract_seq_number = (select max(contract_seq_number) from
      contract_renewals where
      contract_renewals.contract_no = contract.contract_no)/*--by HYang,0*/) where
    (contract.contract_no = @in_Contract or @in_Contract is null) and
    (contract.rg_code = @in_RgCode or @in_RgCode is null) and
    (outlet.region_id = @in_Region or @in_Region is null) and
    (contract_renewals.contract_seq_number > contract.con_active_sequence or
    contract.con_active_sequence is null or
    contract_renewals.con_rates_effective_date < 
    (select max(rr_rates_effective_date) from
      renewal_rate where
      rg_code = (select rg_code from contract as c where c.contract_no = contract_renewals.contract_no))) and
    contract_renewals.contract_seq_number <> isnull(contract.con_active_sequence,0)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_FindContractsForProc_old : 
--

CREATE procedure [rd].[sp_FindContractsForProc_old](@in_Region int,@in_RgCode int,@in_Contract int)
as
begin
  select contract.contract_no,
    contract.con_active_sequence,
    max_sequence=contract_renewals.contract_seq_number,
    contract.con_title,
    con_acceptance_flag from
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id join
    contract_renewals on
    (contract.contract_no = contract_renewals.contract_no and
    contract_renewals.contract_seq_number = (select max(contract_seq_number) from
      contract_renewals where
      contract_renewals.contract_no = contract.contract_no)) where
    (contract.contract_no = @in_Contract or @in_Contract is null) and
    (contract.rg_code = @in_RgCode or @in_RgCode is null) and
    (outlet.region_id = @in_Region or @in_Region is null) and
    (contract_renewals.contract_seq_number > contract.con_active_sequence or
    contract.con_active_sequence is null or
    contract_renewals.con_rates_effective_date < 
    (select max(rr_rates_effective_date) from
      renewal_rate where
      rg_code = (select rg_code from contract as c where
        c.contract_no = contract_renewals.contract_no)))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_FindContractsForProc : 
--

CREATE procedure [rd].[sp_FindContractsForProc](@in_Region int,@in_RgCode int,@in_Contract int)
as
begin
  select contract.contract_no,
    contract.con_active_sequence,
    max_sequence=contract_renewals.contract_seq_number,
    contract.con_title,
    con_acceptance_flag from
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id join
    contract_renewals on
    (contract.contract_no = contract_renewals.contract_no and
    contract_renewals.contract_seq_number = (select max(contract_seq_number) from
      contract_renewals where
      contract_renewals.contract_no = contract.contract_no)/*,0*/) where
    (contract.contract_no = @in_Contract or @in_Contract is null) and
    (contract.rg_code = @in_RgCode or @in_RgCode is null) and
    (outlet.region_id = @in_Region or @in_Region is null) and
    (contract_renewals.contract_seq_number > contract.con_active_sequence or
    contract.con_active_sequence is null or
    contract_renewals.con_rates_effective_date < 
    (select max(rr_rates_effective_date) from
      renewal_rate where
      rg_code = (select rg_code from contract as c where
        c.contract_no = contract_renewals.contract_no)))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_FindContractsForProc2 : 
--

CREATE procedure [rd].[sp_FindContractsForProc2](@in_Region int,@in_RgCode int,@in_Contract int)
as
begin
  select contract.contract_no,
    contract.con_active_sequence,
    max_sequence=contract_renewals.contract_seq_number,
    contract.con_title,
    con_acceptance_flag from
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id join
    contract_renewals on
    (contract.contract_no = contract_renewals.contract_no and
    contract_renewals.contract_seq_number = (select max(contract_seq_number) from
      contract_renewals where
      contract_renewals.contract_no = contract.contract_no)/*--By HYang,0*/) where
    (contract.contract_no = @in_Contract or @in_Contract is null) and
    contract.con_date_terminated is null and
    (contract.rg_code = @in_RgCode or @in_RgCode is null) and
    (outlet.region_id = @in_Region or @in_Region is null) and
    (contract_renewals.contract_seq_number > contract.con_active_sequence or
    contract.con_active_sequence is null or
    contract_renewals.con_rates_effective_date < (select max(rr_rates_effective_date) from
      renewal_rate where
      rg_code = (select rg_code from contract as c where c.contract_no = contract_renewals.contract_no)))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetTypesForContractor : 
--

CREATE procedure [rd].[sp_GetTypesForContractor](@in_Contractor int)
as
begin
  select contractor_supplier_no,
    types_for_contractor.ct_key from
    types_for_contractor join contract_type on types_for_contractor.ct_key=contract_type.ct_key where
    contractor_supplier_no = @in_contractor order by
    contract_type asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Occupation : 
--

CREATE procedure [rd].[sp_Occupation]
as
begin
  select occupation.occupation_id,
    occupation.occupation_description from
    occupation order by
    occupation.occupation_description asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_occupation_list : 
--

CREATE procedure -- Tim Chan 24/03/2003
-- This is a new procedure written as part of the resolution to service request 4474_01
-- 
[rd].[sp_occupation_list]
as
begin
  select occ.occupation_description,occ.occupation_id from
    occupation as occ order by
    occ.occupation_description asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[f_update_customers98v2]
as
begin
  declare @vcust_id int,
  @vcust_rd_number char(45),
  @vcust_mail_town char(45),
  @vcust_surname_company char(45),
  @vcust_initials char(45),
  @vcust_title char(45),
  @vcust_property_identification char(45),
  @vcust_mailing_address_no char(45),
  @vcust_mailing_address_road char(45),
  @vcust_mailing_address_locality char(45),
  @vcust_phone_day char(45),
  @vcust_phone_night char(45),
  @vcust_phone_mobile char,
  @vcust_occupations char(45),
  @vcust_other_occupation char(45),
  @vcust_interests char(45),
  @vccust_other_interests char(45),
  @vcust_dir_listing_ind char(45),
  @vcust_survey98_timestamp datetime,
  @audit_cust_rd_number char(40),
  @audit_cust_mail_town char(45),
  @iTemp int,
  @iCNT int
  declare c1 cursor for select customer_survey98.cust_id,
      customer_survey98.cust_rd_number,
      customer_survey98.cust_mail_town,
      customer_survey98.cust_surname_company,
      customer_survey98.cust_initials,
      customer_survey98.cust_title,
      customer_survey98.cust_property_identification,
      customer_survey98.cust_mailing_address_no,
      customer_survey98.cust_mailing_address_road,
      customer_survey98.cust_mailing_address_locality,
      customer_survey98.cust_phone_day,
      customer_survey98.cust_phone_night,
      customer_survey98.cust_occupations,
      customer_survey98.cust_other_occupation,
      customer_survey98.cust_interests,
      customer_survey98.cust_dir_listing_ind,
      cust_mobile from
      customer_survey98 where
      exists(select customer.cust_id from customer where customer.cust_id = customer_survey98.cust_id) order by
      cust_id asc
  open c1
  if @@error <> 0
    begin
      rollback transaction
      return(-1)
    end
  /* Watcom only
  MAINLOOP98:
  */while 1=1 
    begin
      fetch next from c1 into @vcust_id,@vcust_rd_number,@vcust_mail_town,@vcust_surname_company,@vcust_initials,@vcust_title,
        @vcust_property_identification,@vcust_mailing_address_no,@vcust_mailing_address_road,@vcust_mailing_address_locality,
        @vcust_phone_day,@vcust_phone_night,@vcust_occupations,@vcust_other_occupation,@vcust_interests,
        @vcust_dir_listing_ind,@vcust_phone_mobile
      if @@error <> 0
        begin
          rollback transaction
          return(-1)
        end
      if @@fetch_status <0
        break
        /* Watcom only
        MAINLOOP98
        */
      select @audit_cust_rd_number = cust_rd_number,@audit_cust_mail_town = cust_mail_town,@vcust_survey98_timestamp = cust_survey98_timestamp from customer where cust_id = @vcust_id
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-2)
        end
      if @vcust_survey98_timestamp is null
        begin
          update customer set cust_survey98_timestamp = @vcust_survey98_timestamp where
            cust_id = @vcust_id
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-3)
            end
        end
      if left(@vcust_rd_number,3) = 'RD '
        select @vcust_rd_number=right(@vcust_rd_number,case when len(rd.trim(@vcust_rd_number)) >=3 then len(rd.trim(@vcust_rd_number)) else 3 end-3)
      if left(@vcust_rd_number,2) = 'RD'
        select @vcust_rd_number=right(@vcust_rd_number,len(rd.trim(@vcust_rd_number))-2)
      if(@audit_cust_rd_number <> @vcust_rd_number) and(@audit_cust_mail_town <> @vcust_mail_town)
        begin
          insert into customer_survey98_transfers(cust_id,
            cust_rd_number_old,
            cust_mail_town_old,
            cust_rd_number_new,
            cust_mail_town_new) values(@vcust_id,
            @audit_cust_rd_number,
            @audit_cust_mail_town,
            @vcust_rd_number,
            @vcust_mail_town)
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-4)
            end
        end
      update customer set
        cust_rd_number = (case when @vcust_rd_number is not null then @vcust_rd_number else cust_rd_number end),
        cust_mail_town = (case when @vcust_mail_town is not null then @vcust_mail_town else cust_mail_town end),
        cust_surname_company = (case when @vcust_surname_company is not null then @vcust_surname_company else cust_surname_company end),
        cust_initials = (case when @vcust_initials is not null then @vcust_initials else cust_initials end),
        cust_title = (case when @vcust_title is not null then @vcust_title else cust_title end),
        cust_property_identification = (case when @vcust_property_identification is not null then @vcust_property_identification else cust_property_identification end),
        cust_mailing_address_no = (case when @vcust_mailing_address_no is not null then @vcust_mailing_address_no else cust_mailing_address_no end),
        cust_mailing_address_road = (case when @vcust_mailing_address_road is not null then @vcust_mailing_address_road else cust_mailing_address_road end),
        cust_mailing_address_locality = (case when @vcust_mailing_address_locality is not null then @vcust_mailing_address_locality else cust_mailing_address_locality end),
        cust_phone_day = (case when @vcust_phone_day is not null then @vcust_phone_day else cust_phone_day end),
        cust_phone_night = (case when @vcust_phone_night is not null then @vcust_phone_night else cust_phone_night end),
        cust_phone_mobile = (case when @vcust_phone_mobile is not null then @vcust_phone_mobile else cust_phone_mobile end),
        cust_dir_listing_ind = (case when @vcust_dir_listing_ind is not null then @vcust_dir_listing_ind else cust_dir_listing_ind end) where
        cust_id = @vcust_id
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-5)
        end
      select @vcust_interests=rd.trim(@vcust_interests)
      select @iTemp=1
      /* Watcom only
      whileloop:
      */while 1=1 
        begin
          if len(substring(@vcust_interests,@iTemp,1)) > 0
            if substring(@vcust_interests,@iTemp,1) = '1'
              begin
                insert into customer_interest(cust_id,interest_id) select @vcust_id,@iTemp where not exists(select c.cust_id from customer_interest as c where c.cust_id = @vcust_id and c.interest_id = @itemp)
                if @@error <> 0 /* <> was < */
                  begin
                    rollback transaction
                    return(-6)
                  end
              end
          else
            break
            /* Watcom only
            whileloop
            */
          select @iTemp=@iTemp+1
        end
      select @vcust_occupations=rd.trim(@vcust_occupations)
      select @iTemp=0
      /* Watcom only
      whileloop2:
      */while 1=1 
        begin
          select @iTemp=@iTemp+1
          if len(substring(@vcust_occupations,@iTemp,1)) > 0
            if substring(@vcust_occupations,@iTemp,1) = '1'
              if @iTemp <> 10
                begin
                  if @iTemp = 11
                    select @icnt = count(c.cust_id) from customer_occupation as c where c.cust_id = @vcust_id and c.occupation_id = 10
                  else
                    select @icnt = count(c.cust_id) from customer_occupation as c where c.cust_id = @vcust_id and c.occupation_id = @itemp
                  if @@error <> 0 /* <> was < */
                    begin
                      rollback transaction
                      return(-68)
                    end
                  if @icnt = 0
                    if @iTemp = 11
                      insert into customer_occupation(cust_id,occupation_id) values(@vcust_id,10)
                    else
                      insert into customer_occupation(cust_id,occupation_id) values(@vcust_id,@iTemp)
                  if @@error <> 0 /* <> was < */
                    begin
                      rollback transaction
                      return(-7)
                    end
                end
          else
            break
            /* Watcom only
            whileloop2
            */
        end
      if len(@vcust_other_occupation) > 0
        begin
          select @iTemp=0
          select @iTemp = occupation_id from occupation where soundex(occupation_description) = soundex(@vcust_other_occupation)
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-74)
            end
          if @iTemp > 0
            begin
              insert into customer_occupation(cust_id,occupation_id) select @vcust_id,@iTemp where not exists(select c.cust_id from customer_occupation as c where c.cust_id = @vcust_id and c.occupation_id = @itemp)
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-71)
                end
            end
          else
            begin
              insert into occupation(occupation_id,occupation_description) values(null,@vcust_other_occupation)
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-72)
                end
              select @iTemp = occupation_id from occupation where occupation_description = @vcust_other_occupation
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-75)
                end
              insert into customer_occupation(cust_id,occupation_id) select @vcust_id,@iTemp 
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-73)
                end
            end
        end
    end
  close c1
  commit transaction
  return(1)
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[f_update_customers98]
as
begin
  declare @vcust_id int,
  @vcust_rd_number char(45),
  @vcust_mail_town char(45),
  @vcust_surname_company char(45),
  @vcust_initials char(45),
  @vcust_title char(45),
  @vcust_property_identification char(45),
  @vcust_mailing_address_no char(45),
  @vcust_mailing_address_road char(45),
  @vcust_mailing_address_locality char(45),
  @vcust_phone_day char(45),
  @vcust_phone_night char(45),
  @vcust_occupations char(45),
  @vcust_other_occupation char(45),
  @vcust_interests char(45),
  @vccust_other_interests char(45),
  @vcust_dir_listing_ind char(45),
  @vcust_survey98_timestamp datetime,
  @audit_cust_rd_number char(40),
  @audit_cust_mail_town char(45),
  @iTemp int
  declare c1 cursor for select customer_survey98.cust_id,
      customer_survey98.cust_rd_number,
      customer_survey98.cust_mail_town,
      customer_survey98.cust_surname_company,
      customer_survey98.cust_initials,
      customer_survey98.cust_title,
      customer_survey98.cust_property_identification,
      customer_survey98.cust_mailing_address_no,
      customer_survey98.cust_mailing_address_road,
      customer_survey98.cust_mailing_address_locality,
      customer_survey98.cust_phone_day,
      customer_survey98.cust_phone_night,
      customer_survey98.cust_occupations,
      customer_survey98.cust_other_occupation,
      customer_survey98.cust_interests,
      customer_survey98.cust_other_interests,
      customer_survey98.cust_dir_listing_ind from
      customer_survey98
  open c1
  if @@error <> 0
    begin
      rollback transaction
      return(-1)
    end
  /* Watcom only
  MAINLOOP98:
  */while 1=1 
    begin
      fetch next from c1 into @vcust_id,@vcust_rd_number,@vcust_mail_town,@vcust_surname_company,@vcust_initials,@vcust_title,
        @vcust_property_identification,@vcust_mailing_address_no,@vcust_mailing_address_road,@vcust_mailing_address_locality,
        @vcust_phone_day,@vcust_phone_night,@vcust_occupations,@vcust_other_occupation,@vcust_interests,@vccust_other_interests,
        @vcust_dir_listing_ind
      if @@error <> 0
        begin
          rollback transaction
          return(-1)
        end
      if @@fetch_status <0
        break
        /* Watcom only
        MAINLOOP98
        */
      select @audit_cust_rd_number = cust_rd_number,@audit_cust_mail_town = cust_mail_town,@vcust_survey98_timestamp = cust_survey98_timestamp from customer where cust_id = @vcust_id
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-2)
        end
      if @vcust_survey98_timestamp is null
        begin
          update customer set cust_survey98_timestamp = @vcust_survey98_timestamp where
            cust_id = @vcust_id
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-3)
            end
        end
      if left(@vcust_rd_number,3) = 'RD '
        select @vcust_rd_number=right(@vcust_rd_number,case when len(rd.trim(@vcust_rd_number)) >=3 then len(rd.trim(@vcust_rd_number)) else 3 end -3)
      if left(@vcust_rd_number,2) = 'RD'
        select @vcust_rd_number=right(@vcust_rd_number,len(rd.trim(@vcust_rd_number))-2)
      if(@audit_cust_rd_number <> @vcust_rd_number) and(@audit_cust_mail_town <> @vcust_mail_town)
        begin
          insert into customer_survey98_transfers(cust_id,
            cust_rd_number_old,
            cust_mail_town_old,
            cust_rd_number_new,
            cust_mail_town_new) values(
            @vcust_rd_number,
            @audit_cust_rd_number,
            @audit_cust_mail_town,
            @vcust_rd_number,
            @vcust_mail_town)
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-4)
            end
        end
      update customer set
        cust_rd_number = (case when len(@vcust_rd_number) > 0 then @vcust_rd_number else cust_rd_number end),
        cust_mail_town = (case when len(@vcust_mail_town) > 0 then @vcust_mail_town else cust_mail_town end),
        cust_surname_company = (case when  len(@vcust_surname_company) > 0 then @vcust_surname_company else cust_surname_company end),
        cust_initials = (case when len(@vcust_initials) > 0 then @vcust_initials else cust_initials end),
        cust_title = (case when len(@vcust_title) > 0 then @vcust_title else cust_title end),
        cust_property_identification = (case when len(@vcust_property_identification) > 0 then @vcust_property_identification else cust_property_identification end),
        cust_mailing_address_no = (case when len(@vcust_mailing_address_no) > 0 then @vcust_mailing_address_no else cust_mailing_address_no end),
        cust_mailing_address_road = (case when len(@vcust_mailing_address_road) > 0 then @vcust_mailing_address_road else cust_mailing_address_road end),
        cust_mailing_address_locality = (case when len(@vcust_mailing_address_locality) > 0 then @vcust_mailing_address_locality else cust_mailing_address_locality end),
        cust_phone_day = (case when len(@vcust_phone_day) > 0 then @vcust_phone_day else cust_phone_day end),
        cust_phone_night = (case when len(@vcust_phone_night) > 0 then @vcust_phone_night else cust_phone_night end),
        cust_dir_listing_ind = (case when len(@vcust_dir_listing_ind) > 0 then @vcust_dir_listing_ind else cust_dir_listing_ind end) where
        cust_id = @vcust_id
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-5)
        end
      select @vcust_interests=rd.trim(@vcust_interests)
      select @iTemp=1
      /* Watcom only
      whileloop:
      */while 1=1 
        begin
          if len(substring(@vcust_interests,@iTemp,1)) > 0
            if substring(@vcust_interests,@iTemp,1) = '1'
              begin
                insert into customer_interest(cust_id,interest_id) values(@vcust_id,@iTemp)
                if @@error <> 0 /* <> was < */
                  begin
                    rollback transaction
                    return(-6)
                  end
              end
          else
            break
            /* Watcom only
            whileloop
            */
          select @iTemp=@iTemp+1
        end
      if len(@vccust_other_interests) > 0
        begin
          select @iTemp=0
          select @iTemp = interest_id from interest where soundex(interest_description) = soundex(@vccust_other_interests)
          if @iTemp > 0
            insert into customer_interest(cust_id,interest_id) values(@vcust_id,@iTemp)
          else
            begin
              insert into interest(interest_id,interest_description) values(null,@vccust_other_interests)
              insert into customer_interest(cust_id,interest_id) select @vcust_id,interest_id from interest where interest_description = @vccust_other_interests
            end
        end
      select @vcust_occupations=rd.trim(@vcust_occupations)
      select @iTemp=1
      /* Watcom only
      whileloop2:
      */while 1=1 
        begin
          if len(substring(@vcust_occupations,@iTemp,1)) > 0
            if substring(@vcust_occupations,@iTemp,1) = '1'
              begin
                insert into customer_occupation(cust_id,occupation_id) values(@vcust_id,@iTemp)
                if @@error <> 0 /* <> was < */
                  begin
                    rollback transaction
                    return(-7)
                  end
              end
          else
            break
            /* Watcom only
            whileloop2
            */
          select @iTemp=@iTemp+1
        end
      if len(@vcust_other_occupation) > 0
        begin
          select @iTemp=0
          select @iTemp = occupation_id from occupation where soundex(occupation_description) = soundex(@vcust_other_occupation)
          if @iTemp > 0
            insert into customer_occupation(cust_id,occupation_id) values(@vcust_id,@iTemp)
          else
            begin
              insert into occupation(occupation_id,occupation_description) values(null,@vcust_other_occupation)
              insert into customer_occupation(cust_id,occupation_id) select @vcust_id,occupation_id from occupation where occupation_description = @vcust_other_occupation
            end
        end
    end
  close c1
  return(1)
end




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Connect : 
--

CREATE procedure [rd].[sp_Connect](@inUserid char(20),@inPassword char(20))
as
begin
  select u.u_cargo,
    g.gp_level_1,
    g.gp_level_2,
    g.gp_level_3,
    g.gp_level_4,
    g.gp_level_5,
    g.gp_level_6,
    g.gp_level_7,
    g.gp_level_8,
    g.gp_level_9,
    g.gp_cargo,
    u.region_id,
    u.u_password_expiry,
    u.u_grace_logins,
    u.u_code,
    u_locked_date from
    userids as u,
    user_groups as g where
    (u.gp_code = g.gp_code) and
    (u.u_userid = @inUserid) and
    (u.u_password = @inPassword)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_GetRdsUserGroup](@AL_PARENT_ID1 int)
as
begin
  select LABEL=RDS_USER_GROUP.UG_NAME,ID=RDS_USER_GROUP.UG_ID,ACCOUNT=RDS_USER_GROUP.UG_ID,PARENT_ID1=@AL_PARENT_ID1,
    PICTINDEX=2 from RDS_USER_GROUP where @AL_PARENT_ID1 = 1 union select LABEL=RDS_USER.U_NAME,
    ID=RDS_USER_ID.UI_ID,ACCOUNT=RDS_USER.U_ID,PARENT_ID1=@AL_PARENT_ID1,PICTINDEX=3 from RDS_USER,
    RDS_USER_ID where @AL_PARENT_ID1 = 2 and RDS_USER.U_ID = RDS_USER_ID.U_ID union select LABEL=RDS_MAINTENANCE_TABLE.MT_NAME,
    ID=RDS_MAINTENANCE_TABLE.MT_ID,ACCOUNT=0,PARENT_ID1=@AL_PARENT_ID1,PICTINDEX=5 from
    RDS_MAINTENANCE_TABLE where @AL_PARENT_ID1 = 3
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_SearchForAddress : 
--

CREATE procedure [rd].[sp_SearchForAddress](@in_AdrNum char(40),@in_RoadId int,@in_SuburbId int,@in_TownId int,@in_Contract int,@in_RDNo char(40),@in_Surname char(45),@in_Initials char(30),@in_UI_UserId char(20),@in_ComponentId int)
-- TJB  Sept 2005  NPAD2 address schema changes
as -- Added adr_unit number and road_suffix to relevant parts of address returned
begin
  select addr.adr_id,
    rds_customer.cust_id,
    rds_customer.cust_surname_company,
    rds_customer.cust_initials,
    adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
    addr.adr_no+addr.adr_alpha) ,
    road_name=(select road_name+
      case when rt.rt_name is null then '' else ' '+rt.rt_name end +
      case when rs.rs_name is null then '' else ' '+rs.rs_name end  from
      road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
      road_suffix as rs on rd.rs_id=rs.rs_id where
      rd.road_id = addr.road_id),
    addr.sl_id,
    addr.tc_id,
    addr.adr_rd_no,
    addr.road_id,
    adr_unit=right(space(10)+addr.adr_unit,10),
    adr_no=right(space(10)+addr.adr_no,10),
    adr_alpha=upper(addr.adr_alpha) from
    address as addr,
    rds_customer,
    customer_address_moves,
    towncity where
    rds_customer.cust_id = customer_address_moves.cust_id and
    customer_address_moves.adr_id = addr.adr_id and
    addr.tc_id = towncity.tc_id and
    customer_address_moves.move_out_date is null and
    rds_customer.master_cust_id is null and
    exists(select rds_user_rights.region_id from
      rds_user_rights,
      rds_user_id,
      rds_user_id_group where
      rds_user_id.ui_id = rds_user_id_group.ui_id and
      rds_user_id_group.ug_id = rds_user_rights.ug_id and
      (rds_user_rights.rur_read = 'Y') and
      (rds_user_id.ui_userid = @in_UI_UserId) and
      (rds_user_rights.rc_id = @in_ComponentId) and
      (towncity.region_id = rds_user_rights.region_id or
      (rds_user_rights.region_id = 0 and
      towncity.region_id = (select rds_user.region_id from rds_user where
        rds_user.u_id = rds_user_id.u_id)) or
      (rds_user_rights.region_id = 0 and
      -1 = (select rds_user.region_id from rds_user where
        rds_user.u_id = rds_user_id.u_id)))) and
    (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
    addr.adr_no+addr.adr_alpha) like @in_AdrNum+'%') and
    (@in_RoadId = 0 or addr.road_id = @in_RoadId) and
    (@in_SuburbId = 0 or addr.sl_id = @in_SuburbId) and
    (@in_TownId = 0 or addr.tc_id = @in_TownId) and
    (@in_Contract = 0 or addr.contract_no = @in_Contract) and
    (@in_RDNo = '' or addr.adr_rd_no like @in_RDNo+'%') and
    (@in_Surname = '' or rds_customer.cust_surname_company like @in_Surname+'%') and
    (@in_Initials = '' or rds_customer.cust_initials like @in_Initials+'%') union
  select addr.adr_id,
    null,
    null,
    null,
    upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +
    addr.adr_no+addr.adr_alpha) as adr_num,
    road_name=(select road_name+
      case when rt.rt_name is null then '' else ' '+rt.rt_name end +
      case when rs.rs_name is null then '' else ' '+rs.rs_name end from
      road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
      road_suffix as rs on rd.rs_id=rs.rs_id where
      rd.road_id = addr.road_id),
    addr.sl_id,
    addr.tc_id,
    addr.adr_rd_no,
    addr.road_id,
    adr_unit=right(space(10)+addr.adr_unit,10),
    adr_no=right(space(10)+addr.adr_no,10),
    adr_alpha=upper(addr.adr_alpha) from
    address as addr,
    towncity where
    addr.tc_id = towncity.tc_id and
    not addr.adr_id = any(select customer_address_moves.adr_id from
      customer_address_moves,rds_customer where
      rds_customer.cust_id = customer_address_moves.cust_id and
      customer_address_moves.move_out_date is null and
      rds_customer.master_cust_id is null) and
    exists(select rds_user_rights.region_id from
      rds_user_rights,
      rds_user_id,
      rds_user_id_group where
      rds_user_id.ui_id = rds_user_id_group.ui_id and
      rds_user_id_group.ug_id = rds_user_rights.ug_id and
      (rds_user_rights.rur_read = 'Y') and
      (rds_user_id.ui_userid = @in_UI_UserId) and
      (rds_user_rights.rc_id = @in_ComponentId) and
      (towncity.region_id = rds_user_rights.region_id or
      (rds_user_rights.region_id = 0 and
      towncity.region_id = (select rds_user.region_id from rds_user where
        rds_user.u_id = rds_user_id.u_id)) or
      (rds_user_rights.region_id = 0 and
      -1 = (select rds_user.region_id from rds_user where
        rds_user.u_id = rds_user_id.u_id)))) and
    (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +
    addr.adr_no+addr.adr_alpha) like @in_AdrNum+'%') and
    (@in_RoadId = 0 or addr.road_id = @in_RoadId) and
    (@in_SuburbId = 0 or addr.sl_id = @in_SuburbId) and
    (@in_TownId = 0 or addr.tc_id = @in_TownId) and
    (@in_Contract = 0 or addr.contract_no = @in_Contract) and
    (@in_RDNo = '' or addr.adr_rd_no like @in_RDNo+'%') and
    (@in_Surname = '') and
    (@in_Initials = '')
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_SearchForAddress_v2b](@in_AdrNum varchar(40),@in_RoadName varchar(50),@in_RoadType int,@in_RoadSuffix int,@in_Suburb varchar(50),@in_Town varchar(50),@in_Contract int,@in_RDNo varchar(40),@in_Surname varchar(45),@in_Initials varchar(30),@in_UI_UserId varchar(20),@in_ComponentId int,@in_rd_contract int,@in_dpid int)
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added adr_unit number and road_suffix to relevant parts of address returned
--
-- TJB  NPAD2  Mar 2006  
-- Added in_rd_contract parameter.  Flags whether to limit search to RD contracts or not.
--       in_rd_contract = 1     limit search to contract #s between 5000 and 6000 (RD)
--       in_rd_contract = 0     limit search search to contracts outside the RD range
-- Also added in_dpid parameter for search criteria
-- Changed input parameters: replaced road_id with roadName, roadType and roadSuffix
--
-- TJB  NPAD2  Apr 2006  pre-go-live
-- Remove references to suburb
-- Separate out the authorization from all searches
-- Separate out dpid search (improved performance dramatically)
--
-- TJB  NPAD2  Apr 2006  BF016
as -- Change town and suburb parameters to names (were IDs)
begin
  declare @authorized integer
  if exists(select rds_user_rights.region_id from
      rds_user_rights,rds_user_id,rds_user_id_group,towncity where
      rds_user_id.ui_id = rds_user_id_group.ui_id and
      rds_user_id_group.ug_id = rds_user_rights.ug_id and
      (rds_user_rights.rur_read = 'Y') and
      (rds_user_id.ui_userid = @in_UI_UserId) and
      (rds_user_rights.rc_id = @in_ComponentId) and
      (towncity.region_id = rds_user_rights.region_id or
      (rds_user_rights.region_id = 0 and
      towncity.region_id = (select rds_user.region_id from rds_user where
        rds_user.u_id = rds_user_id.u_id)) or
      (rds_user_rights.region_id = 0 and
      -1 = (select rds_user.region_id from rds_user where
        rds_user.u_id = rds_user_id.u_id))))
    select @authorized=1
  else
    select @authorized=0
  if @in_dpid is not null and @in_dpid > 0
    select addr.adr_id,
      rds_customer.cust_id,
      rds_customer.cust_surname_company,
      rds_customer.cust_initials,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +
      isnull(addr.adr_no,'')+isnull(addr.adr_alpha,'')),
      road_name=(select isnull(road_name,'')+
        case when rt.rt_name is null then '' else ' '+rt.rt_name end+
        case when rs.rs_name is null then '' else ' '+rs.rs_name end from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
      address as addr,
      road,
      rds_customer,
      customer_address_moves where
      road.road_id = addr.road_id and
      rds_customer.cust_id = customer_address_moves.cust_id and
      rds_customer.master_cust_id is null and
      customer_address_moves.adr_id = addr.adr_id and
      customer_address_moves.move_out_date is null and
      @authorized = 1 and
      addr.dp_id = @in_dpid union
    select addr.adr_id,
      null,
      null,
      null,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      isnull(addr.adr_no,'')+isnull(addr.adr_alpha,'')),
      road_name=(select isnull(road_name,'')+
        case when rt.rt_name is null then '' else ' '+rt.rt_name end+
        case when rs.rs_name is null then '' else ' '+rs.rs_name end from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
      address as addr,
      road where
      road.road_id = addr.road_id and
      not addr.adr_id = any(select customer_address_moves.adr_id from
        customer_address_moves,rds_customer where
        rds_customer.cust_id = customer_address_moves.cust_id and
        customer_address_moves.move_out_date is null and
        rds_customer.master_cust_id is null) and
      @authorized = 1 and
      @in_dpid = addr.dp_id else
  if @in_roadName <> '' and
  @in_Town <> '' and
  @in_surname = '' and
  @in_Contract = 0 and
  @in_RDNo = ''
    select addr.adr_id,
      rds_customer.cust_id,
      rds_customer.cust_surname_company,
      rds_customer.cust_initials,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      isnull(addr.adr_no,'')+isnull(addr.adr_alpha,'')),
      road_name=(select isnull(road_name,'')+
        case when rt.rt_name is null then '' else ' '+rt.rt_name end+
        case when rs.rs_name is null then '' else ' '+rs.rs_name end from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
      address as addr left outer join suburblocality on addr.sl_id=suburblocality.sl_id
       left outer join towncity on addr.tc_id=towncity.tc_id,
      road,
      rds_customer,
      customer_address_moves where
      road.road_id = addr.road_id and
      customer_address_moves.adr_id = addr.adr_id and
      customer_address_moves.move_out_date is null and
      rds_customer.cust_id = customer_address_moves.cust_id and
      rds_customer.master_cust_id is null and
      @authorized = 1 and
      (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      isnull(addr.adr_no,'')+isnull(addr.adr_alpha,'')) like @in_AdrNum+'%') and
      -- and (in_RoadId     = 0  or addr.road_id = in_RoadId) 
      road.road_name = @in_roadName and
      (@in_roadType = 0 or road.rt_id = @in_roadType) and
      (@in_roadSuffix = 0 or road.rs_id = @in_roadSuffix) and
      -- and (in_SuburbId   = 0  or addr.sl_id     = in_SuburbId) 
      (@in_Suburb = '' or sl_name = @in_Suburb) and
      -- and addr.tc_id     = in_TownId
      tc_name = @in_Town and
      ((@in_rd_contract = 1 and addr.contract_no between 5000 and 5999) or
      (@in_rd_contract = 0 and addr.contract_no not between 5000 and 5999) or
      (addr.contract_no is null))
 union
    select addr.adr_id,
      null,
      null,
      null,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      isnull(addr.adr_no,'')+isnull(addr.adr_alpha,'')),
      road_name=(select isnull(road_name,'')+
        case when rt.rt_name is null then '' else ' '+rt.rt_name end+
        case when rs.rs_name is null then '' else ' '+rs.rs_name end from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
       address as addr left outer join suburblocality on addr.sl_id=suburblocality.sl_id
        left outer join towncity on addr.tc_id=towncity.tc_id,
      road where
      road.road_id = addr.road_id and
      not addr.adr_id = any(select customer_address_moves.adr_id from
        customer_address_moves,rds_customer where
        rds_customer.cust_id = customer_address_moves.cust_id and
        customer_address_moves.move_out_date is null and
        rds_customer.master_cust_id is null) and
      @authorized = 1 and
      (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      isnull(addr.adr_no,'')+isnull(addr.adr_alpha,'')) like @in_AdrNum+'%') and
      -- and (in_RoadId     = 0  or addr.road_id = in_RoadId) 
      road.road_name = @in_roadName and
      (@in_roadType = 0 or road.rt_id = @in_roadType) and
      (@in_roadSuffix = 0 or road.rs_id = @in_roadSuffix) and
      -- and (in_SuburbId   = 0  or addr.sl_id     = in_SuburbId) 
      (@in_Suburb = '' or sl_name = @in_Suburb) and
      -- and addr.tc_id     = in_TownId
      tc_name = @in_Town and
      ((@in_rd_contract = 1 and addr.contract_no between 5000 and 5999) or
      (@in_rd_contract = 0 and addr.contract_no not between 5000 and 5999) or
      (addr.contract_no is null))
  else
    select addr.adr_id,
      rds_customer.cust_id,
      rds_customer.cust_surname_company,
      rds_customer.cust_initials,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      isnull(addr.adr_no,'')+isnull(addr.adr_alpha,'')),
      road_name=(select isnull(road_name,'')+
        case when rt.rt_name is null then '' else ' '+rt.rt_name end+
        case when rs.rs_name is null then '' else ' '+rs.rs_name end from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
       address as addr left outer join suburblocality on addr.sl_id=suburblocality.sl_id
        left outer join towncity on addr.tc_id=towncity.tc_id,
      road,
      rds_customer,
      customer_address_moves where
      road.road_id = addr.road_id and
      customer_address_moves.adr_id = addr.adr_id and
      customer_address_moves.move_out_date is null and
      rds_customer.cust_id = customer_address_moves.cust_id and
      rds_customer.master_cust_id is null and
      @authorized = 1 and
      (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      isnull(addr.adr_no,'')+isnull(addr.adr_alpha,'')) like @in_AdrNum+'%') and
      -- and (in_RoadId     = 0  or addr.road_id = in_RoadId)
      (@in_roadName = '' or road.road_name = @in_roadName) and
      (@in_roadType = 0 or road.rt_id = @in_roadType) and
      (@in_roadSuffix = 0 or road.rs_id = @in_roadSuffix) and
      -- and (in_SuburbId   = 0  or addr.sl_id     = in_SuburbId)
      (@in_Suburb = '' or sl_name = @in_Suburb) and
      -- and (in_TownId     = 0  or addr.tc_id     = in_TownId)
      (@in_Town = '' or tc_name = @in_Town) and
      (@in_Contract = 0 or addr.contract_no = @in_Contract) and
      (@in_RDNo = '' or addr.adr_rd_no like @in_RDNo+'%') and
      (@in_Surname = '' or rds_customer.cust_surname_company like @in_Surname+'%') and
      (@in_Initials = '' or rds_customer.cust_initials like @in_Initials+'%') and
      ((@in_rd_contract = 1 and addr.contract_no between 5000 and 5999) or
      (@in_rd_contract = 0 and addr.contract_no not between 5000 and 5999) or
      (addr.contract_no is null))
union
    select addr.adr_id,
      null,
      null,
      null,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      isnull(addr.adr_no,'')+isnull(addr.adr_alpha,'')),
      road_name=(select isnull(road_name,'')+
        case when rt.rt_name is null then '' else ' '+rt.rt_name end+
        case when rs.rs_name is null then '' else ' '+rs.rs_name end from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
       address as addr left outer join suburblocality on addr.sl_id=suburblocality.sl_id
        left outer join towncity on addr.tc_id=towncity.tc_id,
      road where
      road.road_id = addr.road_id and
      not addr.adr_id = any(select customer_address_moves.adr_id from
        customer_address_moves,rds_customer where
        rds_customer.cust_id = customer_address_moves.cust_id and
        customer_address_moves.move_out_date is null and
        rds_customer.master_cust_id is null) and
      @authorized = 1 and
      (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      isnull(addr.adr_no,'')+isnull(addr.adr_alpha,'')) like @in_AdrNum+'%') and
      -- and (in_RoadId     = 0  or addr.road_id = in_RoadId) 
      (@in_roadName = '' or road.road_name = @in_roadName) and
      (@in_roadType = 0 or road.rt_id = @in_roadType) and
      (@in_roadSuffix = 0 or road.rs_id = @in_roadSuffix) and
      -- and (in_SuburbId   = 0  or addr.sl_id     = in_SuburbId) 
      (@in_Suburb = '' or sl_name = @in_Suburb) and
      -- and (in_TownId     = 0  or addr.tc_id     = in_TownId) 
      (@in_Town = '' or tc_name = @in_Town) and
      (@in_Contract = 0 or addr.contract_no = @in_Contract) and
      (@in_RDNo = '' or addr.adr_rd_no like @in_RDNo+'%') and
      (@in_Surname = '') and
      (@in_Initials = '') and
      ((@in_rd_contract = 1 and addr.contract_no between 5000 and 5999) or
      (@in_rd_contract = 0 and addr.contract_no not between 5000 and 5999) or
      (addr.contract_no is null))
order by cust_id			--added by ygu
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_SearchForAddress_v2](@in_AdrNum char(40),@in_RoadName char(50),@in_RoadType int,@in_RoadSuffix int,@in_SuburbId int,@in_TownId int,@in_Contract int,@in_RDNo char(40),@in_Surname char(45),@in_Initials char(30),@in_UI_UserId char(20),@in_ComponentId int,@in_rd_contract int,@in_dpid int)
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added adr_unit number and road_suffix to relevant parts of address returned
--
-- TJB  NPAD2  Mar 2006  
-- Added in_rd_contract parameter.  Flags whether to limit search to RD contracts or not.
--       in_rd_contract = 1     limit search to contract #s between 5000 and 6000 (RD)
--       in_rd_contract = 0     limit search search to contracts outside the RD range
-- Also added in_dpid parameter for search criteria
-- Changed input parameters: replaced road_id with roadName, roadType and roadSuffix
--
-- TJB  NPAD2  Apr 2006  pre-go-live
-- Remove references to suburb
-- Separate out the authorization from all searches
-- Separate out dpid search (improved performance dramatically)
--
-- TJB NPAD2  Apr 2006  production fixups bf004
as -- If the contract number is known, set in_rd_contract accordingly whatever is passed.
begin
  declare @authorized integer
  -- If the contract number is known, set in_rd_contract 
  -- accordingly whatever is passed.
  if @in_contract is not null
    if @in_contract between 5000 and 5999
      select @in_rd_contract=1
    else
      select @in_rd_contract=1
  if exists(select rds_user_rights.region_id from
      rds_user_rights,rds_user_id,rds_user_id_group,towncity where
      rds_user_id.ui_id = rds_user_id_group.ui_id and
      rds_user_id_group.ug_id = rds_user_rights.ug_id and
      (rds_user_rights.rur_read = 'Y') and
      (rds_user_id.ui_userid = @in_UI_UserId) and
      (rds_user_rights.rc_id = @in_ComponentId) and
      (towncity.region_id = rds_user_rights.region_id or
      (rds_user_rights.region_id = 0 and
      towncity.region_id = (select rds_user.region_id from rds_user where
        rds_user.u_id = rds_user_id.u_id)) or
      (rds_user_rights.region_id = 0 and
      -1 = (select rds_user.region_id from rds_user where
        rds_user.u_id = rds_user_id.u_id))))
    select @authorized=1
  else
    select @authorized=0
  if @in_dpid is not null and @in_dpid > 0
    select addr.adr_id,
      rds_customer.cust_id,
      rds_customer.cust_surname_company,
      rds_customer.cust_initials,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      addr.adr_no+addr.adr_alpha),
      road_name=(select road_name+
        case when rt.rt_name is null then '' else ' '+rt.rt_name end +
        case when rs.rs_name is null then '' else ' '+rs.rs_name end from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
      address as addr,
      road,
      rds_customer,
      customer_address_moves where
      --, towncity 
      rds_customer.cust_id = customer_address_moves.cust_id and
      rds_customer.master_cust_id is null and
      customer_address_moves.adr_id = addr.adr_id and
      customer_address_moves.move_out_date is null and
      road.road_id = addr.road_id and
      --and towncity.tc_id = addr.tc_id 
      @authorized = 1 and
      @in_dpid = addr.dp_id union
    select addr.adr_id,
      null,
      null,
      null,
      adr_num=upper(case when addr.adr_unit is null  then '' else addr.adr_unit+'/' end +
      addr.adr_no+addr.adr_alpha),
      road_name=(select road_name+
        case when rt.rt_name is null then '' else ' '+rt.rt_name end +
        case when rs.rs_name is null then '' else ' '+rs.rs_name end  from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
      address as addr,
      road where
      --,  towncity 
      road.road_id = addr.road_id and
      --and towncity.tc_id  = addr.tc_id 
      not addr.adr_id = any(select customer_address_moves.adr_id from
        customer_address_moves,rds_customer where
        rds_customer.cust_id = customer_address_moves.cust_id and
        customer_address_moves.move_out_date is null and
        rds_customer.master_cust_id is null) and
      @authorized = 1 and
      @in_dpid = addr.dp_id else
  if @in_roadName <> '' and @in_townid <> 0 and
  @in_surname = '' and
  @in_Contract = 0 and
  @in_RDNo = ''
    select addr.adr_id,
      rds_customer.cust_id,
      rds_customer.cust_surname_company,
      rds_customer.cust_initials,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +
      addr.adr_no+addr.adr_alpha),
      road_name=(select road_name+
        case when rt.rt_name is null then '' else ' '+rt.rt_name end+
        case when rs.rs_name is null then '' else ' '+rs.rs_name end from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
      address as addr,
      road,
      rds_customer,
      customer_address_moves,
      towncity where
      rds_customer.cust_id = customer_address_moves.cust_id and
      rds_customer.master_cust_id is null and
      customer_address_moves.adr_id = addr.adr_id and
      customer_address_moves.move_out_date is null and
      road.road_id = addr.road_id and
      towncity.tc_id = addr.tc_id and
      @authorized = 1 and
      (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +
      addr.adr_no+addr.adr_alpha) like @in_AdrNum+'%') and
      -- and (in_RoadId     = 0  or addr.road_id = in_RoadId) 
      road.road_name = @in_roadName and
      (@in_roadType = 0 or road.rt_id = @in_roadType) and
      (@in_roadSuffix = 0 or road.rs_id = @in_roadSuffix) and
      -- and (in_SuburbId   = 0  or addr.sl_id     = in_SuburbId) 
      addr.tc_id = @in_TownId and
      ((@in_rd_contract = 1 and addr.contract_no between 5000 and 5999) or
      (@in_rd_contract = 0 and addr.contract_no not between 5000 and 5999) or
      (addr.contract_no is null)) union
    select addr.adr_id,
      null,
      null,
      null,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      addr.adr_no+addr.adr_alpha),
      road_name=(select road_name+
        case  when rt.rt_name is null then '' else ' '+rt.rt_name end+
        case  when rs.rs_name is null then '' else ' '+rs.rs_name end from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
      address as addr,
      road,
      towncity where
      towncity.tc_id = addr.tc_id and
      road.road_id = addr.road_id and
      not addr.adr_id = any(select customer_address_moves.adr_id from
        customer_address_moves,rds_customer where
        rds_customer.cust_id = customer_address_moves.cust_id and
        customer_address_moves.move_out_date is null and
        rds_customer.master_cust_id is null) and
      @authorized = 1 and
      (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      addr.adr_no+addr.adr_alpha) like @in_AdrNum+'%') and
      -- and (in_RoadId     = 0  or addr.road_id = in_RoadId) 
      road.road_name = @in_roadName and
      (@in_roadType = 0 or road.rt_id = @in_roadType) and
      (@in_roadSuffix = 0 or road.rs_id = @in_roadSuffix) and
      -- and (in_SuburbId   = 0  or addr.sl_id     = in_SuburbId) 
      addr.tc_id = @in_TownId and
      ((@in_rd_contract = 1 and addr.contract_no between 5000 and 5999) or
      (@in_rd_contract = 0 and addr.contract_no not between 5000 and 5999) or
      (addr.contract_no is null))
  else
    select addr.adr_id,
      rds_customer.cust_id,
      rds_customer.cust_surname_company,
      rds_customer.cust_initials,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      addr.adr_no+addr.adr_alpha),
      road_name=(select road_name+
        case when rt.rt_name is null then  ''  else ' '+rt.rt_name end+
        case when rs.rs_name is null then '' else ' '+rs.rs_name end  from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
      address as addr,
      road,
      rds_customer,
      customer_address_moves,
      towncity where
      rds_customer.cust_id = customer_address_moves.cust_id and
      rds_customer.master_cust_id is null and
      customer_address_moves.adr_id = addr.adr_id and
      customer_address_moves.move_out_date is null and
      road.road_id = addr.road_id and
      towncity.tc_id = addr.tc_id and
      @authorized = 1 and
      (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      addr.adr_no+addr.adr_alpha) like @in_AdrNum+'%') and
      -- and (in_RoadId     = 0  or addr.road_id = in_RoadId) 
      (@in_roadName = '' or road.road_name = @in_roadName) and
      (@in_roadType = 0 or road.rt_id = @in_roadType) and
      (@in_roadSuffix = 0 or road.rs_id = @in_roadSuffix) and
      -- and (in_SuburbId   = 0  or addr.sl_id     = in_SuburbId) 
      (@in_TownId = 0 or addr.tc_id = @in_TownId) and
      (@in_Contract = 0 or addr.contract_no = @in_Contract) and
      (@in_RDNo = '' or addr.adr_rd_no like @in_RDNo+'%') and
      (@in_Surname = '' or rds_customer.cust_surname_company like @in_Surname+'%') and
      (@in_Initials = '' or rds_customer.cust_initials like @in_Initials+'%') and
      ((@in_rd_contract = 1 and addr.contract_no between 5000 and 5999) or
      (@in_rd_contract = 0 and addr.contract_no not between 5000 and 5999) or
      (addr.contract_no is null)) union
    select addr.adr_id,
      null,
      null,
      null,
      adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      addr.adr_no+addr.adr_alpha),
      road_name=(select road_name+
        case when rt.rt_name is null then '' else ' '+rt.rt_name end+
        case when rs.rs_name is null then '' else ' '+rs.rs_name end from
        road as rd left outer join road_type as rt on rd.rt_id=rt.rt_id left outer join
        road_suffix as rs on rd.rs_id=rs.rs_id where
        rd.road_id = addr.road_id),
      addr.sl_id,
      addr.tc_id,
      addr.adr_rd_no,
      addr.road_id,
      adr_unit=right(space(10)+addr.adr_unit,10),
      adr_no=right(space(10)+addr.adr_no,10),
      adr_alpha=upper(addr.adr_alpha) from
      address as addr,
      road,
      towncity where
      towncity.tc_id = addr.tc_id and
      road.road_id = addr.road_id and
      not addr.adr_id = any(select customer_address_moves.adr_id from
        customer_address_moves,rds_customer where
        rds_customer.cust_id = customer_address_moves.cust_id and
        customer_address_moves.move_out_date is null and
        rds_customer.master_cust_id is null) and
      @authorized = 1 and
      (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      addr.adr_no+addr.adr_alpha) like @in_AdrNum+'%') and
      -- and (in_RoadId     = 0  or addr.road_id = in_RoadId) 
      (@in_roadName = '' or road.road_name = @in_roadName) and
      (@in_roadType = 0 or road.rt_id = @in_roadType) and
      (@in_roadSuffix = 0 or road.rs_id = @in_roadSuffix) and
      -- and (in_SuburbId   = 0  or addr.sl_id     = in_SuburbId) 
      (@in_TownId = 0 or addr.tc_id = @in_TownId) and
      (@in_Contract = 0 or addr.contract_no = @in_Contract) and
      (@in_RDNo = '' or addr.adr_rd_no like @in_RDNo+'%') and
      (@in_Surname = '') and
      (@in_Initials = '') and
      ((@in_rd_contract = 1 and addr.contract_no between 5000 and 5999) or
      (@in_rd_contract = 0 and addr.contract_no not between 5000 and 5999) or
      (addr.contract_no is null))
end






GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure update_id_codes : 
--

CREATE procedure -- TWC - 13/06/2003
--This script has been written to resolve call 4524
-- This script will bring selected id_codes up to date
[rd].[update_id_codes]
as
begin
  declare @max_cust_id int,
  @max_address_id int,
  @max_road_id int,
  @max_user_rights int,
  @max_vehicle_id int,
  @max_contractor_id int,
  @max_rur_id int,
  @li_return int
  select @li_return=1
  select @max_contractor_id = max(contractor_supplier_no) 
    from contractor
  update id_codes set
    next_value = @max_contractor_id+1 where
    sequence_name = 'Contractor'
  if @@ERROR < 0
    select @li_return=-1
  select @max_vehicle_id = max(vehicle_number) 
    from vehicle
  update id_codes set
    next_value = @max_vehicle_id+1 where
    sequence_name = 'vehicles'
  if @@ERROR < 0
    select @li_return=-1
  select @max_user_rights = max(rur_id) 
    from rds_user_rights
  update id_codes set
    next_value = @max_user_rights+1 where
    sequence_name = 'rdsUserRights'
  if @@ERROR < 0
    select @li_return=-1
  select @max_cust_id = max(cust_id) 
    from rds_customer
  update id_codes set
    next_value = @max_cust_id+1 where
    sequence_name = 'customer'
  if @@ERROR < 0
    select @li_return=-1
  select @max_address_id = max(adr_id) 
    from address
  update id_codes set
    next_value = @max_address_id+1 where
    sequence_name = 'address'
  if @@ERROR < 0
    select @li_return=-1
  select @max_road_id = max(road_id) 
    from road
  update id_codes set
    next_value = @max_road_id+1 where
    sequence_name = 'road'
  if @@ERROR < 0
    select @li_return=-1
  select @max_rur_id = max(rur_id) 
    from rds_user_rights
  update id_codes set
    next_value = @max_rur_id+1 where
    sequence_name = 'rdsUserRights'
  if @@ERROR < 0
    select @li_return=-1
  return @li_return
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure p_getrandcustomers : 
--

CREATE procedure [rd].[p_getrandcustomers](@xrequired int)
as
begin
  -- PBY 25-11-2002 SR#4427
  -- Used a temporary table instead of the permenant temp_mine table.
  -- Also modified the query to use rds_customer table instead of the legacy customer table.
  --
  -- PBY Modified 27-Feb-2002
  -- Added a Post Code onto the label
  --
  -- TJB 30-Sep-2004 SR4637
  -- Include postcode to town name so it needn''t print on a separate line.
  --
  -- TJB  Sept 2005  NPAD2 Address schema changes
  -- Added adr_unit and road_suffix to addresses
  declare @xrand int,
  @xcount int,
  @xnum int,
  @xtmp int
 create table #tmp_rand_labels(
    cust_title varchar(10) null,
    cust_surname_company varchar(45) null,
    cust_initials varchar(30) null,
    cust_mailing_address_no varchar(9) null,
    cust_mailing_address_road varchar(45) null,
    cust_mailing_address_locality varchar(45) null,
    cust_mail_town varchar(45) null,
    cust_rd_number varchar(40) null,
    con_rd_ref_text varchar(35) null,
    uzed integer null,
    cust_post_code varchar(10) null)

  delete from #tmp_rand_labels
  --commit work;
  update tmp_rand_cust_list set uzed = null
  select @xnum = Count(*) 
    from tmp_rand_cust_list
  if @xnum = 0
    begin
      select cust_title,
        cust_surname_company,
        cust_initials,
        cust_mailing_address_no,
        cust_mailing_address_road,
        cust_mailing_address_locality,
        cust_mail_town,
        cust_rd_number,
        con_rd_ref_text,
        cust_post_code from
        #tmp_rand_labels
      return
    end
  select @xCount=0
  /* Watcom only
  CursorLoop:
  */while 1=1 
    begin
      select @xrand=round((rand()*@xnum),0)
      select @xTmp = Count(*) 
        from tmp_rand_cust_list where
        sequence = @xrand and
        uzed is null
      if @xTmp > 0
        begin
          update tmp_rand_cust_list set
            uzed = cust_id where
            sequence = @xrand
          select @xCount=@xCount+1
        end
      if @xcount >= @xrequired or @xCount >= @xNum
        break
        /* Watcom only
        CursorLoop
        */
    end
  insert into #tmp_rand_labels
    select distinct
      rds_customer.cust_title,
      rds_customer.cust_surname_company,
      rds_customer.cust_initials,
      case when address.adr_unit is null then '' else address.adr_unit+'/' end +
      IsNull(address.adr_no,'')+
      IsNull(address.adr_alpha,''),
      IsNull(road.road_name,'')+
      case when road_type.rt_name is null then '' else ' '+road_type.rt_name end +
      case when road_suffix.rs_name is null then '' else ' '+road_suffix.rs_name end ,
      suburblocality.sl_name,
      towncity.tc_name,
      address.adr_rd_no,'',
      rds_customer.cust_id,
      post_code.post_code from
      address left outer join road on address.road_id = road.road_id left outer join
      road_type on road.rt_id = road_type.rt_id left outer join
      road_suffix on road.rs_id = road_suffix.rs_id left outer join suburblocality on
      address.sl_id = suburblocality.sl_id left outer join towncity on
      address.tc_id = towncity.tc_id left outer join post_code on address.post_code_id = post_code.post_code_id,
      tmp_rand_cust_list,
      rds_customer where
      tmp_rand_cust_list.adr_id = address.adr_id and
      rds_customer.cust_id = tmp_rand_cust_list.cust_id and
      tmp_rand_cust_list.uzed is not null
  --commit work;
  select cust_title,
    cust_surname_company,
    cust_initials,
    cust_mailing_address_no,
    cust_mailing_address_road,
    cust_mailing_address_locality,
    -- TJB SR4637
    -- Include postcode with town name so it needn''t print on a separate line
    -- (similar to normal customer list)
    -- cust_mail_town,
    cust_mail_town+'   '+cust_post_code,
    cust_rd_number,
    con_rd_ref_text,
    cust_post_code from
    --    post_code.post_code from
    #tmp_rand_labels
--       post_code 
-- where tmp_mine.cust_mail_town *= post_code.post_mail_town
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure p_getrandcust : 
--
CREATE procedure [rd].[p_getrandcust](@xrequired int)
as
begin
  declare @xrand int,
  @xcust_id int,
  @xcount int,
  @xnum int,
  @xcust_title char(10),
  @xcust_surname_company char(45),
  @xcust_initials char(16),
  @xcust_mailing_address_no char(9),
  @xcust_mailing_address_road char(45),
  @xcust_mailing_address_locality char(45),
  @xcust_mail_town char(45),
  @xcust_rd_number char(40),
  @xcon_rd_ref_text char(35),
  @xuzed int,
  @xerr int
  /* Watcom only
  err_notfound exception for sqlstate value '02000'
  */
  /* Watcom only
    local temporary table tmp_mine(
    cust_title char(10) null,
    cust_surname_company char(45) null,
    cust_initials char(16) null,
    cust_mailing_address_no char(9) null,
    cust_mailing_address_road char(45) null,
    cust_mailing_address_locality char(45) null,
    cust_mail_town char(45) null,
    cust_rd_number char(40) null,
    con_rd_ref_text char(35) null,
    uzed integer null,
    ) on commit delete rows
  */
  declare CurCust cursor for select distinct
      customer.cust_title,
      customer.cust_surname_company,
      customer.cust_initials,
      customer.cust_mailing_address_no,
      customer.cust_mailing_address_road,
      customer.cust_mailing_address_locality,
      customer.cust_mail_town,
      customer.cust_rd_number,
      contract.con_rd_ref_text,
      customer.cust_id from
      contract,
      customer,
      tmp_rand_cust_list where
      (contract.contract_no = customer.contract_no) and
      (customer.cust_id = tmp_rand_cust_list.cust_id)
  select @xnum=Count(*) from tmp_rand_cust_list
  if @xnum = 0
    raiserror 17001 'No rows to return'
  open CurCust
  select @xcount=1
  /* Watcom only
  CursorLoop:
  */while 1=1 
    begin
      select @xrand=(rand()*@xnum)
      select @xrand=round(@xrand,0)
      if @xcount > @xrequired
        break
        /* Watcom only
        CursorLoop
        */
      if @xrand <> 0
        /* Watcom only
        FetchLoop:
        */while 1=1 
          begin
              /* Watcom only
              absolute @xrand CurCust
            */
            fetch next from CurCust into @xcust_title,
              @xcust_surname_company,
              @xcust_initials,
              @xcust_mailing_address_no,
              @xcust_mailing_address_road,
              @xcust_mailing_address_locality,
              @xcust_mail_town,
              @xcust_rd_number,
              @xcon_rd_ref_text,
              @xuzed
            select @xerr=@@error
            if @@FETCH_STATUS < 0
              break
              /* Watcom only
              CursorLoop
              */
            if @xerr <> 0
              begin
                close CurCust
                --raiserror (@xerr, 10, 1)--
              end
            if not exists(select uzed from tmp_mine where uzed = @xuzed)
              begin
                select @xnum=@xnum-1
                select @xcount=@xcount+1
                insert into tmp_mine(cust_title,
                  cust_surname_company,
                  cust_initials,
                  cust_mailing_address_no,
                  cust_mailing_address_road,
                  cust_mailing_address_locality,
                  cust_mail_town,
                  cust_rd_number,
                  con_rd_ref_text,
                  uzed) values(
                  @xcust_title,
                  @xcust_surname_company,
                  @xcust_initials,
                  @xcust_mailing_address_no,
                  @xcust_mailing_address_road,
                  @xcust_mailing_address_locality,
                  @xcust_mail_town,
                  @xcust_rd_number,
                  @xcon_rd_ref_text,
                  @xuzed)
                if @xnum = 0
                  break
                  /* Watcom only
                  CursorLoop
                  */
                break
                /* Watcom only
                FetchLoop
                */
              end
            else
              begin
                select @xrand=@xrand+1
                if @xrand > @xnum
                  select @xrand=1
              end
          end
    end
  close CurCust
  select cust_title,
    cust_surname_company,
    cust_initials,
    cust_mailing_address_no,
    cust_mailing_address_road,
    cust_mailing_address_locality,
    cust_mail_town,
    cust_rd_number,
    con_rd_ref_text from
    tmp_mine
end



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_getrandcustomers : 
--

CREATE procedure [rd].[sp_getrandcustomers](
@xrequired int)
as
begin
  -- PBY 25-11-2002 SR#4427
  -- Used a temporary table instead of the permenant temp_mine table.
  -- Also modified the query to use rds_customer table instead of the legacy customer table.
  --
  -- PBY Modified 27-Feb-2002
  -- Added a Post Code onto the label
  --
  -- TJB 30-Sep-2004 SR4637
  -- Include postcode to town name so it needn''t print on a separate line.
  --
  -- TJB  Sept 2005  NPAD2 Address schema changes
  -- Added adr_unit and road_suffix to addresses
  declare @xrand int
  declare @xcount int
  declare @xnum int
  declare @xtmp int
  create table #tmp_rand_labels(
    cust_title char(10) null,
    cust_surname_company char(45) null,
    cust_initials char(30) null,
    cust_mailing_address_no char(9) null,
    cust_mailing_address_road char(45) null,
    cust_mailing_address_locality char(45) null,
    cust_mail_town char(45) null,
    cust_rd_number char(40) null,
    con_rd_ref_text char(35) null,
    uzed integer null,
    cust_post_code varchar(10) null)

  delete from #tmp_rand_labels
  --commit work;
  update tmp_rand_cust_list set uzed = null
  select @xnum=Count(*) from tmp_rand_cust_list
  if @xnum = 0
    begin
      select cust_title,
        cust_surname_company,
        cust_initials,
        cust_mailing_address_no,
        cust_mailing_address_road,
        cust_mailing_address_locality,
        cust_mail_town,
        cust_rd_number,
        con_rd_ref_text,
        cust_post_code from
        #tmp_rand_labels
      return
    end
  select @xCount=0
  /* Watcom only
  CursorLoop:
  */while 1=1 
    begin
      select @xrand=round((rand()*@xnum),0)
      select @xTmp=Count(*)
        from tmp_rand_cust_list where
        sequence = @xrand and
        uzed is null
      if @xTmp > 0
        begin
          update tmp_rand_cust_list set
            uzed = cust_id where
            sequence = @xrand
          select @xCount=@xCount+1
        end
      if @xcount >= @xrequired or @xCount >= @xNum
        break
        /* Watcom only
        CursorLoop
        */
    end
  insert into #tmp_rand_labels
    select distinct
      rds_customer.cust_title,
      rds_customer.cust_surname_company,
      rds_customer.cust_initials,
      case when isnull(address.adr_unit,'')='' then '' else address.adr_unit+'/' end+
      IsNull(address.adr_no,'')+
      IsNull(address.adr_alpha,''),
      IsNull(road.road_name,'')+
      case when IsNull(road_type.rt_name,'')='' then '' else ' '+road_type.rt_name end+
      case when IsNull(road_suffix.rs_name,'')='' then '' else ' '+road_suffix.rs_name end,
      suburblocality.sl_name,
      towncity.tc_name,
      address.adr_rd_no,'',
      rds_customer.cust_id,
      post_code.post_code 
   from address 
      left outer join road on address.road_id=road.road_id 
      left outer join  road_type on road.rt_id=road_type.rt_id
      left outer join road_suffix on road.rs_id=road_suffix.rs_id
      left outer join suburblocality on address.sl_id = suburblocality.sl_id
      left outer join towncity on address.tc_id = towncity.tc_id
      left outer join post_code on address.post_code_id = post_code.post_code_id,
      tmp_rand_cust_list,
      rds_customer 
    where
      tmp_rand_cust_list.adr_id = address.adr_id and
      rds_customer.cust_id = tmp_rand_cust_list.cust_id and
      tmp_rand_cust_list.uzed is not null
  --commit work;
  select cust_title,
    cust_surname_company,
    cust_initials,
    cust_mailing_address_no,
    cust_mailing_address_road,
    cust_mailing_address_locality,
    -- TJB SR4637
    -- Include postcode with town name so it needn''t print on a separate line
    -- (similar to normal customer list)
    -- cust_mail_town,
    cust_mail_town+'   '+cust_post_code,
    cust_rd_number,
    con_rd_ref_text,
    cust_post_code from
    --    post_code.post_code from
    #tmp_rand_labels
--       post_code 
-- where tmp_mine.cust_mail_town *= post_code.post_mail_town
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_get_non_vehicle_override_rates : 
--

CREATE procedure [rd].[sp_get_non_vehicle_override_rates](@incontract_no int,@incontract_seq_no int)
-- TJB  SR4661  May2005
as -- Added delivery and processing wage rates
begin
  select contract_no,
    contract_seq_number,
    nvor_wage_hourly_rate,
    nvor_public_liability_rate_2,
    nvor_carrier_risk_rate,
    nvor_acc_rate,
    nvor_item_proc_rate_per_hour,
    nvor_frozen,
    nvor_accounting,
    nvor_telephone,
    nvor_sundries,
    nvor_acc_rate_amount,
    nvor_uniform,
    nvor_delivery_wage_rate,
    nvor_processing_wage_rate from
    non_vehicle_override_rate where
    contract_no = @incontract_no and
    contract_seq_number = @incontract_seq_no
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetSummaryFrequencies : 
--

CREATE procedure [rd].[sp_GetSummaryFrequencies](@inContract int,@inSequence int)
as
begin
  select standard_frequency.sf_key,
    standard_frequency.sf_description,
    route_frequency.rf_delivery_days,
    route_frequency.rf_distance,
    frequency_distances.fd_effective_date,
    frequency_distances.fd_distance,
    frequency_distances.fd_no_of_boxes,
    frequency_distances.fd_no_rural_bags,
    frequency_distances.fd_no_other_bags,
    frequency_distances.fd_no_private_bags,
    frequency_distances.fd_no_post_offices,
    frequency_distances.fd_no_cmbs,
    frequency_distances.fd_no_cmb_customers,
    frequency_distances.fd_volume,
    frequency_distances.fd_delivery_hrs_per_week,
    frequency_distances.fd_processing_hrs_week,
    rate_days.rtd_days_per_annum,'X' from
    frequency_distances join
    standard_frequency on
    frequency_distances.sf_key = standard_frequency.sf_key join
    route_frequency on
    frequency_distances.contract_no = route_frequency.contract_no and
    frequency_distances.rf_delivery_days = route_frequency.rf_delivery_days and
    frequency_distances.sf_key = route_frequency.sf_key join
    contract_renewals on
    frequency_distances.contract_no = contract_renewals.contract_no and
    frequency_distances.fd_effective_date >= contract_renewals.con_start_date and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence join
    rate_days on
    frequency_distances.sf_key = rate_days.sf_key where
    rate_days.rg_code = contract_renewals.con_rg_code_at_renewal and
    rate_days.rr_rates_effective_date = contract_renewals.con_rates_effective_date union
  select null,'Renewal Information',
    null,
    null,
    null,
    contract_renewals.con_distance_at_renewal,
    contract_renewals.con_no_customers_at_renewal,
    contract_renewals.con_no_rural_private_bags_at_renewal,
    contract_renewals.con_no_other_bags_at_renewal,
    contract_renewals.con_no_private_bags_at_renewal,
    contract_renewals.con_no_post_offices_at_renewal,
    contract_renewals.con_no_cmbs_at_renewal,
    contract_renewals.con_no_cmb_custs_at_renewal,
    contract_renewals.con_volume_at_renewal,
    contract_renewals.con_del_hrs_week_at_renewal,
    contract_renewals.con_processing_hours_per_week,
    1,'R' from
    contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [rd].[sp_GetFreqDistances](
@inContract int,
@inSFKey int,
@inDeliveryDays char(7))
as
begin
  select fd_effective_date,
    contract_no,
    sf_key,
    rf_delivery_days,
    fd_distance,
    fd_no_of_boxes,
    fd_no_rural_bags,
    fd_no_other_bags,
    fd_no_private_bags,
    fd_no_post_offices,
    fd_no_cmbs,
    fd_no_cmb_customers,
    fd_volume,
    fd_change_reason,
    fd_delivery_hrs_per_week,
    fd_processing_hrs_week from
    frequency_distances where
    (contract_no = @inContract) and
    (sf_key = @inSFKey) and
    (rf_delivery_days = @inDeliveryDays) order by
    fd_effective_date desc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRouteFrequency2001 : 
--

CREATE procedure [rd].[sp_GetRouteFrequency2001](@in_Contract int)
as
begin
  select route_frequency.contract_no,
    route_frequency.sf_key,
    route_frequency.rf_delivery_days,
    route_frequency.rf_active,
    rf_monday=substring(route_frequency.rf_delivery_days,1,1),
    rf_tuesday=substring(route_frequency.rf_delivery_days,2,1),
    rf_wednesday=substring(route_frequency.rf_delivery_days,3,1),
    rf_thursday=substring(route_frequency.rf_delivery_days,4,1),
    rf_friday=substring(route_frequency.rf_delivery_days,5,1),
    rf_saturday=substring(route_frequency.rf_delivery_days,6,1),
    rf_sunday=substring(route_frequency.rf_delivery_days,7,1),
    route_frequency.rf_distance,
    case when ((select count(*) from
      frequency_distances as fd,
      contract as c,contract_renewals as cr where
      fd.contract_no = route_frequency.contract_no and
      fd.sf_key = route_frequency.sf_key and
      fd.rf_delivery_days = route_frequency.rf_delivery_days and
      fd.contract_no = c.contract_no and
      c.con_active_sequence = cr.contract_seq_number) > 0 ) then 'Yes' else 'No' end  from
    route_frequency where
    route_frequency.contract_no = @in_Contract
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_getPostCodeID : 
--

CREATE function [rd].[f_getPostCodeID](@inPostCode char(4),@inTcID int,@inRoadID int)
/******************************************************************
* Description
*    This function returns the Post Code ID for the given Post Code.
*    Complicated by the fact that the post code may have more than one 
*    ID depending on the mailtown (this may only apply to the current
*    way Post Codes are defined - there is a new scheme on the offing).
*
*    Note too that the tc_id is from the townCity table, and MAY not 
*    be for a town that is in the post_code table; if so, we can try 
*    getting the post_code_id from the address table.
*
*    Failing any of that, return one of the IDs for the post code from 
*    the post_code table, or -1 if the post_code does not actually exist.
*    
* Parameters
*    @inPostCode   - The Post Code
*    @inTcID       - The tc_id of the town the post code is to be for
*    @inRoadID     - The road_id of the road the post code is to be for
*
* System
*    NPAD2 - NZ Post
*
* Author
*    Tom Britton, Synergy International
*
* Created on
*    November 2005
*
* Modification history
*
*****************************************************************/
returns int
as
begin
  declare @postCodeID int,
  @found integer
  -- First, check that the post code actually exists
  if not exists(select 1 from post_code where
      post_code = @inPostCode)
    return(-1)
  -- Now see if there is a post code for the mailtown
  select @postCodeID=null
  select @postCodeID = post_code_id from
    post_code as pc,townCity as tc where
    pc.post_code = @inPostCode and
    pc.post_mail_town = tc.tc_name and
    tc_id = @inTcID
  if @postCodeID is not null
    return(@postCodeID)
  -- No:  now try via the roadID in the address table
  select @found = count(distinct(post_code_id)) from
    address as addr where
    addr.road_id = @inRoadID and
    addr.tc_id = @inTcID
  -- If we found one post_code_id, return it
  if @found is not null and @found = 1
    begin
      select @postCodeID = addr.post_code_id from
        address as addr where
        addr.road_id = @inRoadID and
        addr.tc_id = @inTcID
      return(@postCodeID)
    end
  -- If we found more than one post_code_id, return the first
  if @found is not null and @found > 1
    begin
      select top 1 @postCodeID = addr.post_code_id from
        address as addr where
        addr.road_id = @inRoadID and
        addr.tc_id = @inTcID
      return(@postCodeID)
    end
  -- We haven''t found the post_code_id via either the mailtown or roadID
  -- (perhaps this is the first time an address has been added on this road) 
  -- so now we'll revert to picking one at 'random''.
  select @postCodeID = post_code_id from
    post_code as pc where
    pc.post_code = @inPostCode
  return(@postCodeID)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function noroadnumPercent : 
--

CREATE function [rd].[noroadnumPercent](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns real
-- TJB  Sept 2005  NPAD2 address schema changes
as -- Added adr_unit number to adr_no.
begin
  declare @i_no_num real,
  @i_total real,
  @d_percentage real
  select @i_no_num = count(addr.adr_id) 
    from towncity as tc join address as addr on tc.tc_id = addr.tc_id join "contract" as con on addr.contract_no = con.contract_no where
    (@inRegion = 0 or @inRegion is null or tc.region_id = @inRegion) and
    (@inOutlet = 0 or @inOutlet is null or con.con_lodgement_office = @inOutlet) and
    (@inContractType = 0 or @inContractType is null or con.con_base_cont_type = @inContractType) and
    (@inRenGroup = 0 or @inRenGroup is null or con.rg_code = @inRenGroup) and
    addr.adr_unit+addr.adr_no is null
  select @i_total = count(addr.adr_id) 
    from towncity as tc join address as addr on tc.tc_id = addr.tc_id join "contract" as con on addr.contract_no = con.contract_no where
    (@inRegion = 0 or @inRegion is null or tc.region_id = @inRegion) and
    (@inOutlet = 0 or @inOutlet is null or con.con_lodgement_office = @inOutlet) and
    (@inContractType = 0 or @inContractType is null or con.con_base_cont_type = @inContractType) and
    (@inRenGroup = 0 or @inRenGroup is null or con.rg_code = @inRenGroup)
  if @i_total <> 0
    begin
      select @d_percentage=(@i_no_num/@i_total)*100
      select @d_percentage=round(@d_percentage,2)
    end
  else
    select @d_percentage=0
  return round(@d_percentage,2)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function RDGeoPercent : 
--

CREATE function [rd].[RDGeoPercent](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns float
as
begin
  declare @i_geocoded float,
  @i_total float,
  @d_percentage float
  -- get the geocoded count
  select @i_geocoded = count(addr.adr_id) 
    from towncity as tc join address as addr on tc.tc_id = addr.tc_id join address_geocode as ag on addr.adr_id = ag.adr_id,contract as con where
    addr.contract_no = con.contract_no and
    (@inRegion = 0 or @inRegion is null or tc.region_id = @inRegion) and
    (@inOutlet = 0 or @inOutlet is null or con.con_lodgement_office = @inOutlet) and
    (@inRenGroup = 0 or @inRenGroup is null or con.rg_code = @inRenGroup) and
    (@inContractType = 0 or @inContractType is null or con.con_base_cont_type = @inContractType)
  -- get the not geocoded count
  select @i_total = count(addr.adr_id) 
    from towncity as tc join address as addr on tc.tc_id = addr.tc_id join contract as con on addr.contract_no = con.contract_no where
    addr.contract_no = con.contract_no and
    (@inRegion = 0 or @inRegion is null or tc.region_id = @inRegion) and
    (@inOutlet = 0 or @inOutlet is null or con.con_lodgement_office = @inOutlet) and
    (@inRenGroup = 0 or @inRenGroup is null or con.rg_code = @inRenGroup) and
    (@inContractType = 0 or @inContractType is null or con.con_base_cont_type = @inContractType)
  if @i_total <> 0
    begin
      select @d_percentage=(@i_geocoded/@i_total)*100
      select @d_percentage=round(@d_percentage,0)
    end
  else
    select @d_percentage=0
  return round(@d_percentage,2)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function privacyPercent : 
--

CREATE function [rd].[privacyPercent](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns float
as
begin
  declare @i_no_num float,
  @i_total float,
  @d_percentage float
  select @i_no_num = count(cust.cust_id) 
    from towncity as tc join 
address as addr on addr.tc_id = tc.tc_id  join customer_address_moves as cam on addr.adr_id = cam.adr_id join rds_customer as cust on cust.cust_id = cam.cust_id 
join contract as con on  addr.contract_no = con.contract_no where
    (@inRegion = 0 or @inRegion is null or tc.region_id = @inRegion) and
    (@inOutlet = 0 or @inOutlet is null or con.con_lodgement_office = @inOutlet) and
    (@inContractType = 0 or @inContractType is null or con.con_base_cont_type = @inContractType) and
    (@inRenGroup = 0 or @inRenGroup is null or con.rg_code = @inRenGroup) and
    cust.master_cust_id is null and
    cam.move_out_date is null and
    cust.cust_dir_listing_ind = 'N'
  select @i_total = count(cust.cust_id) 
    from towncity as tc join
address as addr on addr.tc_id = tc.tc_id  join customer_address_moves as cam on addr.adr_id = cam.adr_id join rds_customer as cust on cust.cust_id = cam.cust_id 
 join contract as con on  addr.contract_no = con.contract_no where
    (@inRegion = 0 or @inRegion is null or tc.region_id = @inRegion) and
    (@inOutlet = 0 or @inOutlet is null or con.con_lodgement_office = @inOutlet) and
    (@inContractType = 0 or @inContractType is null or con.con_base_cont_type = @inContractType) and
    (@inRenGroup = 0 or @inRenGroup is null or con.rg_code = @inRenGroup) and
    cust.master_cust_id is null and
    cam.move_out_date is null
  if @i_total <> 0
    begin
      select @d_percentage=(@i_no_num/@i_total)*100
      select @d_percentage=round(@d_percentage,2)
    end
  else
    select @d_percentage=0
  return round(@d_percentage,2)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE function [rd].[f_GetCustomerAddresses](@ai_cust_id int)
-- Get formatted customer address
-- TJB  SR4599    Add adr_alpha to adr_no.
-- TJB  SR4624a   Added move_out_date condition (current customer)
-- TJB  Sept 2005  NPAD2 Address schema changes
-- Added adr_unit and road_suffix to addresses
-- Returns address in this format
--   <Property ID>
--   <unit>/<number><alpha> <road name> <road type> <road suffix>
--   <suburb>
--   RD <RD number>
returns char(1000)
as --   <town>  <post code>
begin
  declare @sret varchar(100)
  declare @stemp1 varchar(100)
  declare @stemp2a varchar(50)
  declare @stemp2b varchar(50)
  declare @stemp2 varchar(100)
  declare @stemp3 varchar(100)
  declare @stemp4 varchar(100)
  declare @stemp5 varchar(100)
  declare @stemp6 varchar(100)
  declare @stemp7 varchar(100)
  declare @stemp8 varchar(50)
  declare @scrlf varchar(100)
  -- Note re this cursor: some customers have more than one address.  This use of a
  --      cursor avoids multiple result set errors.  The cursor shouldn''t be removed 
  --      unless you're SURE the data is clean, no matter how tempting!  - TJB Sept'05
  -- Note on the joins: The 'on' clauses appear to be redundant, and some probably are, 
  --      but removing them results in lots of extra rows, so its better to leave them.
  --      - TJB  Sept''05
  -- TJB SR4663 Add RD number
  declare Customer_Address  cursor for select address.adr_property_identification,
      case when isnull(address.adr_unit,'')='' then '' else address.adr_unit+'/' end +address.adr_no,
      address.adr_alpha,
      road.road_name,
      road_type.rt_name+case when isnull(road_suffix.rs_name,'')= '' then '' else ' '+road_suffix.rs_name end ,
      suburblocality.sl_name,
      towncity.tc_name,
      post_code.post_code,
      address.adr_rd_no from
      address left outer join road on
      address.road_id = road.road_id
		left outer join suburblocality on
      address.sl_id = suburblocality.sl_id
		left outer join towncity on
      address.tc_id = towncity.tc_id
		left outer join road_type on
      road.rt_id = road_type.rt_id
		left outer join rd.road_suffix on
      road.rs_id = road_suffix.rs_id
		 left outer join post_code on
      address.post_code_id = post_code.post_code_id,
      customer_address_moves,
      rds_customer where
      customer_address_moves.adr_id = address.adr_id and
      rds_customer.cust_id = customer_address_moves.cust_id and
      rds_customer.master_cust_id is null and
      customer_address_moves.move_out_date is null and
      rds_customer.cust_id = @ai_cust_id
  --      ((rds_customer.master_cust_id is null) and
  --      (rds_customer.cust_id = ai_cust_id));
  -- TJB (SR4624a) 26 May 2004
  -- Changed where conditions above: added move_out_date condition, split compound condition,
  -- and reformatted
  open Customer_Address
  fetch next from  Customer_Address into @stemp1,@stemp2a,@stemp2b,@stemp3,@stemp4,@stemp5,@stemp6,@stemp7,@stemp8
  -- PBY SR#4373,4368 Commented out char(13) so only a newline is used. (char13 is carriage return)
  select @scrlf=char(10) -- || "char"(13);
  -- TJB SR4599 Adjust to remove leading spaces when columns empty (change isnull(stemp3 to ifnull...)
  -- TJB SR4663 Move post code to Town line and add RD number after suburb
  -- NOTE:  It appears the output is to leave blank lines where there is no data
  --        (eg leave a blank line for the property name if there isn''t one)!
  select @sret=isnull(@stemp1,'')+@scrlf+ -- Property ID
    case when (@stemp2a is null) and (@stemp2b is null) then '' else isnull(@stemp2a,'')+isnull(@stemp2b,'')+' ' end+ -- Street number, unit, and alpha
    case when @stemp3 is null then '' else @stemp3+' ' end + isnull(@stemp4,'')+@scrlf+ -- Streen name, type, and suffix
    isnull(@stemp5,'')+@scrlf+ -- Suburb
    case when @stemp8 is null then '' else 'RD '+@stemp8 end +@scrlf+ -- RD number
    case when @stemp6 is null then '' else @stemp6+'    ' end +isnull(@stemp7,'')+@scrlf -- Town & Postcode

  close Customer_Address
  return(@sret)
end







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure npad_sp_SearchForAddress : 
--

CREATE procedure [rd].[npad_sp_SearchForAddress](@in_AdrNum char(40),@in_RoadId int,@in_SuburbId int,@in_TownId int,@in_Contract int,@in_RDNo char(40),@in_Surname char(45),@in_Initials char(30),@in_UI_UserId char(20),@in_ComponentId int)
--**********************************************************
-- TJB  NPAD2 testing  Oct 2005
-- This variant is used for NPAD2 testing
-- It is used by the NPAD testing application to search
-- for addresses as NPAD would know them (with a cust name
-- if there isn''t an adr_no, and no name if there is).
--**********************************************************
-- TJB  Sept 2005  NPAD2 address schema changes
as -- Added adr_unit number and road_suffix to relevant parts of address returned
begin
  -- First:  all the numbered addresses that meet the criteria
  select addr.adr_id,
    rds_customer.cust_id,
    cust_surname_company=null,
    cust_initials=null,
    adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +
    addr.adr_no+addr.adr_alpha),
    --(select road_name
    --        +ifnull(rt.rt_name,'',' '+rt.rt_name)
    --        +ifnull(rs.rs_name,'',' '+rs.rs_name)
    --   from road rd left outer join road_type rt
    --                left outer join road_suffix rs
    --  where rd.road_id = addr.road_id)                    as road_name,
    rd.road_name,
    addr.sl_id,
    addr.tc_id,
    addr.adr_rd_no,
    addr.road_id,
    adr_unit=right(space(10)+addr.adr_unit,10),
    adr_no=right(space(10)+addr.adr_no,10),
    adr_alpha=upper(addr.adr_alpha),
    addr.dp_id,
    master_dp_id=null,
    addr.adr_property_identification,
    pc.post_code,
    rd.rt_id,
    rd.rs_id,
    rt.rt_name,
    rs.rs_name from
    address as addr left outer join post_code as pc on addr.post_code_id = pc.post_code_id,
    road as rd left outer join road_type as rt on rd.rt_id = rt.rt_id left outer join
    road_suffix as rs on rd.rs_id = rs.rs_id,
    rds_customer,
    customer_address_moves,
    towncity where
    rds_customer.cust_id = customer_address_moves.cust_id and
    customer_address_moves.adr_id = addr.adr_id and
    addr.tc_id = towncity.tc_id and
    customer_address_moves.move_out_date is null and
    rds_customer.master_cust_id is null and
    rd.road_id = addr.road_id and
    -- and exists(select rds_user_rights.region_id 
    --              from rds_user_rights,
    --                   rds_user_id,
    --                   rds_user_id_group 
    --             where rds_user_id.ui_id = rds_user_id_group.ui_id 
    --               and rds_user_id_group.ug_id = rds_user_rights.ug_id 
    --               and (rds_user_rights.rur_read = 'Y') 
    --               and (rds_user_id.ui_userid = in_UI_UserId) 
    --               and (rds_user_rights.rc_id = in_ComponentId) 
    --               and (towncity.region_id = rds_user_rights.region_id 
    --                    or (rds_user_rights.region_id = 0 
    --                        and towncity.region_id = (select rds_user.region_id from rds_user 
    --                                                   where rds_user.u_id = rds_user_id.u_id))
    --                    or (rds_user_rights.region_id = 0 
    --                        and -1 = (select rds_user.region_id from rds_user 
    --                                   where rds_user.u_id = rds_user_id.u_id))
    --                   )
    --           ) 
    (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end + addr.adr_no+addr.adr_alpha) like @in_AdrNum+'%') and
    (@in_RoadId = 0 or addr.road_id = @in_RoadId) and
    (@in_SuburbId = 0 or addr.sl_id = @in_SuburbId) and
    (@in_TownId = 0 or addr.tc_id = @in_TownId) and
    (@in_Contract = 0 or addr.contract_no = @in_Contract) and
    (@in_RDNo = '' or addr.adr_rd_no like @in_RDNo+'%') and
    (@in_Surname = '' or rds_customer.cust_surname_company like @in_Surname+'%') and
    (@in_Initials = '' or rds_customer.cust_initials like @in_Initials+'%') and
    (upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end + addr.adr_no+addr.adr_alpha) <> '' and upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end + addr.adr_no+addr.adr_alpha) is not null) union
  -- Second:  all the un-numbered addresses that meet the criteria
  select addr.adr_id,
    rds_customer.cust_id,
    cust_surname_company=rds_customer.cust_surname_company,
    cust_initials=rds_customer.cust_initials,
    adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +
    addr.adr_no+addr.adr_alpha),
    --(select road_name
    --        +ifnull(rt.rt_name,'',' '+rt.rt_name)
    --        +ifnull(rs.rs_name,'',' '+rs.rs_name)
    --   from road rd left outer join road_type rt
    --                left outer join road_suffix rs
    --  where rd.road_id = addr.road_id)                    as road_name,
    rd.road_name,
    addr.sl_id,
    addr.tc_id,
    addr.adr_rd_no,
    addr.road_id,
    adr_unit=right(space(10)+addr.adr_unit,10),
    adr_no=right(space(10)+addr.adr_no,10),
    adr_alpha=upper(addr.adr_alpha),
    cam.dp_id,
    master_dp_id=(select dp_id from customer_address_moves as cam2 where cam2.cust_id = master_cust_id),
    addr.adr_property_identification,
    pc.post_code,
    rd.rt_id,
    rd.rs_id,
    rt.rt_name,
    rs.rs_name from
    address as addr left outer join post_code as pc on addr.post_code_id = pc.post_code_id,
    road as rd left outer join road_type as rt on rd.rt_id = rt.rt_id left outer join
    road_suffix as rs on rd.rs_id = rs.rs_id,
    rds_customer,
    customer_address_moves as cam,
    towncity where
    rds_customer.cust_id = cam.cust_id and
    cam.adr_id = addr.adr_id and
    addr.tc_id = towncity.tc_id and
    cam.move_out_date is null and
    rd.road_id = addr.road_id and
    -- and rds_customer.master_cust_id is null 
    -- and exists(select rds_user_rights.region_id 
    --              from rds_user_rights,
    --                   rds_user_id,
    --                   rds_user_id_group 
    --             where rds_user_id.ui_id = rds_user_id_group.ui_id 
    --               and rds_user_id_group.ug_id = rds_user_rights.ug_id 
    --               and (rds_user_rights.rur_read = 'Y') 
    --               and (rds_user_id.ui_userid = in_UI_UserId) 
    --               and (rds_user_rights.rc_id = in_ComponentId) 
    --               and (towncity.region_id = rds_user_rights.region_id 
    --                    or (rds_user_rights.region_id = 0 
    --                        and towncity.region_id = (select rds_user.region_id from rds_user 
    --                                                   where rds_user.u_id = rds_user_id.u_id))
    --                    or (rds_user_rights.region_id = 0 
    --                        and -1 = (select rds_user.region_id from rds_user 
    --                                   where rds_user.u_id = rds_user_id.u_id))
    --                   )
    --           ) 
    --and (in_AdrNum    = '' or adr_num   like in_AdrNum+'%') 
    (@in_RoadId = 0 or addr.road_id = @in_RoadId) and
    (@in_SuburbId = 0 or addr.sl_id = @in_SuburbId) and
    (@in_TownId = 0 or addr.tc_id = @in_TownId) and
    (@in_Contract = 0 or addr.contract_no = @in_Contract) and
    (@in_RDNo = '' or addr.adr_rd_no like @in_RDNo+'%') and
    (@in_Surname = '' or rds_customer.cust_surname_company like @in_Surname+'%') and
    (@in_Initials = '' or rds_customer.cust_initials like @in_Initials+'%') and
    (upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end + addr.adr_no+addr.adr_alpha) = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end + addr.adr_no+addr.adr_alpha) is null) and
    (rds_customer.cust_surname_company <> '' and rds_customer.cust_surname_company is not null) union
  -- Finally, any unoccupied, numbered addresses that meet the criteria
  select addr.adr_id,
    cust_id=null,
    cust_surname_company=null,
    cust_initials=null,
    adr_num=upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end +
    addr.adr_no+addr.adr_alpha),
    --(select road_name
    --        +ifnull(rt.rt_name,'',' '+rt.rt_name)
    --        +ifnull(rs.rs_name,'',' '+rs.rs_name)
    --   from road rd left outer join road_type rt
    --                left outer join road_suffix rs
    --  where rd.road_id = addr.road_id)                    as road_name,
    rd.road_name,
    addr.sl_id,
    addr.tc_id,
    addr.adr_rd_no,
    addr.road_id,
    adr_unit=right(space(10)+addr.adr_unit,10),
    adr_no=right(space(10)+addr.adr_no,10),
    adr_alpha=upper(addr.adr_alpha),
    addr.dp_id,
    master_dp_id=null,
    addr.adr_property_identification,
    pc.post_code,
    rd.rt_id,
    rd.rs_id,
    rt.rt_name,
    rs.rs_name from
    address as addr left outer join post_code as pc on addr.post_code_id = pc.post_code_id,
    road as rd left outer join road_type as rt on rd.rt_id = rt.rt_id left outer join
    road_suffix as rs on rd.rs_id = rs.rs_id,
    towncity where
    addr.tc_id = towncity.tc_id and
    rd.road_id = addr.road_id and
    not addr.adr_id = any(select customer_address_moves.adr_id from
      customer_address_moves,rds_customer where
      rds_customer.cust_id = customer_address_moves.cust_id and
      customer_address_moves.move_out_date is null and
      rds_customer.master_cust_id is null) and
    -- and exists(select rds_user_rights.region_id 
    --              from rds_user_rights,
    --                   rds_user_id,
    --                   rds_user_id_group 
    --             where rds_user_id.ui_id = rds_user_id_group.ui_id 
    --               and rds_user_id_group.ug_id = rds_user_rights.ug_id 
    --               and (rds_user_rights.rur_read = 'Y') 
    --               and (rds_user_id.ui_userid = in_UI_UserId) 
    --               and (rds_user_rights.rc_id = in_ComponentId) 
    --               and (towncity.region_id = rds_user_rights.region_id 
    --                    or (rds_user_rights.region_id = 0 
    --                        and towncity.region_id = (select rds_user.region_id from rds_user 
    --                                                   where rds_user.u_id = rds_user_id.u_id)) 
    --                    or (rds_user_rights.region_id = 0 
    --                        and -1 = (select rds_user.region_id from rds_user 
    --                                  where rds_user.u_id = rds_user_id.u_id))
    --                   )
    --           ) 
    (@in_AdrNum = '' or upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end + addr.adr_no+addr.adr_alpha) like @in_AdrNum+'%') and
    (@in_RoadId = 0 or addr.road_id = @in_RoadId) and
    (@in_SuburbId = 0 or addr.sl_id = @in_SuburbId) and
    (@in_TownId = 0 or addr.tc_id = @in_TownId) and
    (@in_Contract = 0 or addr.contract_no = @in_Contract) and
    (@in_RDNo = '' or addr.adr_rd_no like @in_RDNo+'%') and
    (@in_Surname = '') and
    (@in_Initials = '') and
    (upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end + addr.adr_no+addr.adr_alpha) <> '' and upper(case when addr.adr_unit is null then '' else addr.adr_unit+'/' end + addr.adr_no+addr.adr_alpha) is not null)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_nonumber_con](@con_id int)
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added road_suffix to road name
as -- Added joins with implicit relations
begin
  select cust_name=cust.cust_surname_company+
    case when cust.cust_initials is null then null else ' '+cust.cust_initials end ,
    road_name=rd.road_name+
    case when rt.rt_name is null then null else ' '+rt.rt_name end +
    case when rs.rs_name is null then null else ' '+rs.rs_name end,
    sl.sl_name,
    tc.tc_name,
    addr.adr_rd_no,
    cust.cust_phone_day,
    cust.cust_phone_night,
    cust.cust_phone_mobile from(
    rds_customer as cust join customer_address_moves as cad on cust.cust_id=cad.cust_id) join(
    address as addr left outer join SuburbLocality as sl on addr.sl_id=sl.sl_id) on cad.adr_id=addr.adr_id
	 join TownCity as tc on addr.tc_id=tc.tc_id
	 join road as rd on addr.road_id=rd.road_id left outer join
    road_type as rt on rt.rt_id=rd.rt_id left outer join
    road_suffix as rs on rd.rs_id=rs.rs_id where
    addr.contract_no = @con_id and
    addr.adr_no is null and
    cust.master_cust_id is null and
    cad.move_out_date is null order by
    --and rd.road_id = addr.road_id
    --and tc.tc_id = addr.tc_id
    road_name asc,cust_name asc
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
 

--
-- Definition for stored procedure sp_nonumber_town : 
--
 
CREATE procedure [rd].[sp_nonumber_town](@town_id int)
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added road_suffix to road name
as -- Added joins with implicit relations
begin
   select 
  cust_name=cust.cust_surname_company+
  case when cust.cust_initials is null then '' else ' '+cust.cust_initials end ,
  road_name=rd.road_name+
  (case when rt.rt_name is null then '' else ' '+rt.rt_name end) +
  (case when rs.rs_name is null then '' else ' '+rs.rs_name end),
  sl.sl_name,
  tc.tc_name,
  addr.adr_rd_no,
  cust.cust_phone_day,
  cust.cust_phone_night,
  cust.cust_phone_mobile
   from
  rds_customer as cust
  inner join customer_address_moves as cad
  on cust.cust_id=cad.cust_id
  inner join address as addr
  on cad.adr_id=addr.adr_id
  left outer join SuburbLocality as sl
  on addr.sl_id=sl.sl_id
  inner join TownCity as tc
  on addr.tc_id=tc.tc_id
  inner join road as rd
  on addr.road_id=rd.road_id
  left outer join road_type as rt
  on rt.rt_id=rd.rt_id
  left outer join
  road_suffix as rs on rd.rs_id=rs.rs_id 
 
   where
  addr.tc_id = @town_id and
  addr.adr_no is null and
  cust.master_cust_id is null and
  cad.move_out_date is null 
order by
    --and rd.Road_id = addr.Road_id
    --and tc.tc_id = addr.tc_id
    road_name asc,cust_name asc
end
 







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetTown_list : 
--

CREATE procedure -- Tim Chan 04/03/2003
-- This is a new procedure written as part of the resolution to service request 4474
-- 
[rd].[sp_GetTown_list]
as
begin
  select TownCity.tc_id,TownCity.tc_name from
    TownCity order by
    TownCity.tc_name asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for stored procedure sp_MigrateDpa2002 : 
--

CREATE procedure [rd].[sp_MigrateDpa2002] as
begin
  --Temp variables
  declare @v_iTemp integer
  declare @v_Loops integer
  declare @v_sTemp char(255)
  --Misc variables
  declare @v_Ctr integer
  declare @v_MaxTownCityId integer
  declare @v_MaxSuburbLocalityId integer
  declare @v_MaxRoadId integer
  declare @v_MaxRecipientId integer
  declare @v_TownCityId integer
  declare @v_SuburbLocalityId integer
  declare @v_RoadId integer
  declare @v_RoadTypeId integer
  declare @v_RoadName char(45)
  declare @v_PostCodeId integer
  --Customer/address fetch variables
  declare @v_region_id integer
  declare @v_cust_id integer
  declare @v_contract_no integer
  declare @v_cust_title char(10)
  declare @v_cust_surname_company char(45)
  declare @v_cust_initials char(30)
  declare @v_cust_rd_number char(40)
  declare @v_cust_mailing_address_no char(9)
  declare @v_cust_mailing_address_road char(45)
  declare @v_cust_mailing_address_locality char(45)
  declare @v_cust_mail_town char(40)
  declare @v_cust_nad_reference char(12)
  declare @v_cust_prior_customer integer
  declare @v_cust_phone_day char(14)
  declare @v_cust_phone_night char(14)
  declare @v_cust_dir_listing_ind char(1)
  declare @v_cust_dir_listing_text char(60)
  declare @v_cust_delivery_frequency tinyint
  declare @v_cust_delivery_days char(7)
  declare @v_cust_business char(1)
  declare @v_cust_rural_resident char(1)
  declare @v_cust_rural_farmer char(1)
  declare @v_cust_old_delivery_days char(1)
  declare @v_cust_adpost_quantity tinyint
  declare @v_cust_date_first_loaded datetime
  declare @v_cust_date_last_transfered datetime
  declare @v_cust_date_left datetime
  declare @v_printedon datetime
  declare @v_cust_date_commenced datetime
  declare @v_cust_property_identification char(100)
  declare @v_cust_post_code char(6)
  declare @v_cust_survey98_timestamp datetime
  declare @v_cust_phone_mobile char(14)
  declare @v_cust_category char(2)
  declare @v_sf_key1 integer
  declare @v_sf_key2 integer
  declare @v_sf_key3 integer
  declare @v_sf_key4 integer
  declare @v_sf_key5 integer
  declare @v_sf_key6 integer
  declare @v_sf_key7 integer
  declare @v_sf_key8 integer
  declare @v_sf_key9 integer
  declare vc_ContractCustomers cursor for select region.region_id,
      customer.cust_id,
      customer.contract_no,
      customer.cust_title,
      customer.cust_surname_company,
      customer.cust_initials,
      customer.cust_rd_number,
      customer.cust_mailing_address_no,
      customer.cust_mailing_address_road,
      customer.cust_mailing_address_locality,
      customer.cust_mail_town,
      customer.cust_nad_reference,
      customer.cust_prior_customer,
      customer.cust_phone_day,
      customer.cust_phone_night,
      customer.cust_dir_listing_ind,
      customer.cust_dir_listing_text,
      customer.cust_delivery_frequency,
      customer.cust_delivery_days,
      customer.cust_business,
      customer.cust_rural_resident,
      customer.cust_rural_farmer,
      customer.cust_old_delivery_days,
      customer.cust_adpost_quantity,
      customer.cust_date_first_loaded,
      customer.cust_date_last_transfered,
      customer.cust_date_left,
      customer.printedon,
      customer.cust_date_commenced,
      customer.cust_property_identification,
      customer.cust_post_code,
      customer.cust_survey98_timestamp,
      customer.cust_phone_mobile,
      customer.cust_category,
      customer.sf_key1,
      customer.sf_key2,
      customer.sf_key3,
      customer.sf_key4,
      customer.sf_key5,
      customer.sf_key6,
      customer.sf_key7,
      customer.sf_key8,
      customer.sf_key9 from
      contract,
      customer,
      outlet,
      region where
      customer.contract_no = contract.contract_no and
      outlet.outlet_id = contract.con_base_office and
      region.region_id = outlet.region_id
  --and   customer.contract_no between 5000 and 5010;
  --****Preliminary Processing*****
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-30)
    end
  --Get max town/city id
  select @v_MaxTownCityId=Max(tc_id)
    from TownCity
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-40)
    end
  --Get max Suburb/Locality id
  select @v_MaxSuburbLocalityId=Max(sl_id) 
    from SuburbLocality
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-50)
    end
  --Get max road Id
  select @v_MaxRoadId=max(road_id) 
    from road
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-60)
    end
  open vc_ContractCustomers
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-65)
    end
  select @v_Loops=0
  --********Main processing********
  /* Watcom only
  MAINLOOP:
  */while 1=1 
    begin
      select @v_Loops=@v_Loops+1
      select @v_TownCityId=null
      select @v_SuburbLocalityId=null
      select @v_RoadId=null
      select @v_RoadTypeId=null
      select @v_RoadName=null
      select @v_iTemp=null
      select @v_sTemp=null
      select @v_PostCodeId=null
      --Fetch customers into vars
      fetch next from vc_ContractCustomers into @v_region_id,
        @v_cust_id,
        @v_contract_no,@v_cust_title,@v_cust_surname_company,
        @v_cust_initials,@v_cust_rd_number,@v_cust_mailing_address_no,
        @v_cust_mailing_address_road,@v_cust_mailing_address_locality,@v_cust_mail_town,
        @v_cust_nad_reference,@v_cust_prior_customer,@v_cust_phone_day,
        @v_cust_phone_night,@v_cust_dir_listing_ind,@v_cust_dir_listing_text,
        @v_cust_delivery_frequency,@v_cust_delivery_days,@v_cust_business,
        @v_cust_rural_resident,@v_cust_rural_farmer,@v_cust_old_delivery_days,
        @v_cust_adpost_quantity,@v_cust_date_first_loaded,@v_cust_date_last_transfered,
        @v_cust_date_left,@v_printedon,@v_cust_date_commenced,
        @v_cust_property_identification,@v_cust_post_code,@v_cust_survey98_timestamp,
        @v_cust_phone_mobile,@v_cust_category,@v_sf_key1,
        @v_sf_key2,@v_sf_key3,@v_sf_key4,
        @v_sf_key5,@v_sf_key6,@v_sf_key7,
        @v_sf_key8,@v_sf_key9
      --Check SQLSTATE
      if @@fetch_status <0
        break
        /* Watcom only
        MAINLOOP
        */
      if charindex(rd.Trim('private bag'),rd.trim(upper(@v_cust_mailing_address_road))) > 0
        begin
          select @v_cust_property_identification=@v_cust_mailing_address_road
          select @v_cust_mailing_address_road=null
        end
      /******Migrate address******/
      --Generate Town/City
      if len(@v_cust_mail_town) > 0
        begin
          select @v_Ctr=count(*)
            from TownCity where
            region_id = @v_region_id and
            Upper(rd.Trim(tc_name)) = Upper(rd.Trim(@v_cust_mail_town))
          --Check @@error
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-70)
            end
          --Does it exist"?"
          if @v_Ctr = 0
            begin
              --No: Add town/city
              if @v_MaxTownCityId is null
                select @v_MaxTownCityId=0
              select @v_MaxTownCityId=@v_MaxTownCityId+1
              select @v_TownCityId=@v_MaxTownCityId
              insert into TownCity(tc_id,region_id,tc_name) values(
                @v_MaxTownCityId,@v_Region_Id,@v_cust_mail_town)
              --Check @@error
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-80)
                end
            end
          else
            begin
              --Yes: Get the Town/City ID for future use
              select top 1  @v_TownCityId=tc_Id
                from TownCity where
                region_id = @v_region_id and
                Upper(rd.Trim(tc_name)) = Upper(rd.Trim(@v_cust_mail_town))
              --Check @@error
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-90)
                end
            end
        end
      --Generate Suburbs/Locality
      if len(@v_cust_mailing_address_locality) > 0
        begin
          select @v_Ctr = count(*) 
            from SuburbLocality where
            Upper(rd.Trim(sl_name)) = Upper(rd.Trim(@v_cust_mailing_address_locality))
          --Check @@error
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-100)
            end
          --Does it exist"?"
          if @v_Ctr = 0
            begin
              --No: Add suburbs/locality
              if @v_MaxSuburbLocalityId is null
                select @v_MaxSuburbLocalityId=0
              select @v_MaxSuburbLocalityId=@v_MaxSuburbLocalityId+1
              select @v_SuburbLocalityId=@v_MaxSuburbLocalityId
              insert into SuburbLocality(sl_id,sl_name) values(
                @v_MaxSuburbLocalityId,@v_cust_mailing_address_locality)
              --Check @@error
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-110)
                end
            end
          else
            begin
              --Yes: Get suburb/locality ID for future use 
              select top 1 @v_SuburbLocalityId=sl_id 
                from SuburbLocality where
                Upper(rd.Trim(sl_name)) = Upper(rd.Trim(@v_cust_mailing_address_locality))
              --Check @@error
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-120)
                end
            end
        end
      --Generate town_suburb
      if @v_TownCityId > 0 and @v_SuburbLocalityId > 0 and len(@v_cust_mailing_address_locality) > 0 and len(@v_cust_mail_town) > 0
        begin
          select @v_iTemp=count(*) 
            from town_suburb where
            town_suburb.tc_id = @v_TownCityId and
            town_suburb.sl_id = @v_SuburbLocalityId
          --Check @@error
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-130)
            end
          if @v_iTemp = 0 or @v_iTemp is null
            begin
              insert into town_suburb(tc_id,sl_id) values(
                @v_TownCityId,@v_SuburbLocalityId)
              --Check @@error
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-140)
                end
            end
        end
      --Generate Roads
      if len(@v_cust_mailing_address_road) > 0
        begin
          --Generate Roads: Try to separate the road name and the type
          select top 1 @v_RoadName=case when len(rd.Trim(LEFT(customer.cust_mailing_Address_road,charindex(' ' + road_type.rt_abbrev,lower(cust_mailing_address_road))))) = 0 then cust_mailing_Address_road else rd.Trim(LEFT(customer.cust_mailing_Address_road,charindex(' ' + road_type.rt_abbrev,lower(cust_mailing_address_road)))) end,
            @v_RoadTypeId=rt_id  
             from customer,
            road_type where
            RIGHT(lower(cust_mailing_address_road),len(road_type.rt_abbrev)) = lower(road_type.rt_abbrev) and
            customer.cust_id = @v_cust_id
          --Check @@error
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-150)
            end
          if @v_RoadName is null
            select @v_RoadName=@v_cust_mailing_address_road
          --Search for road using extracted values
          select top 1 @v_RoadId=road.road_id,
            @v_sTemp=road.road_name  
             from road where
            Lower(rd.Trim(road.road_name)) = Lower(rd.Trim(@v_RoadName)) and
            ((road.rt_id = @v_RoadTypeId) or(road.rt_id is null and @v_RoadTypeId is null))
          --insert into fuck_t values (v_RoadId, v_sTemp,v_RoadTypeId, v_RoadName);
          --Check @@error
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
              return(-160)
            end
          --Add road (for the suburb) IF not found. Dupes allowed accross suburbs
          if @v_RoadId > 0
            select @v_MaxRoadId=@v_MaxRoadId --DO NOTHING
          else
            begin
              if len(@v_RoadName) = 0 or @v_RoadName is null
                begin
                  select @v_RoadName=@v_cust_mailing_address_road
                  select @v_RoadTypeId=null
                end
              if @v_MaxRoadId is null
                select @v_MaxRoadId=0
              select @v_MaxRoadId=@v_MaxRoadId+1
              select @v_RoadId=@v_MaxRoadId
              --Create road
              insert into road(road_id,road_name,rt_id) values(
                @v_MaxRoadId,@v_RoadName,@v_RoadTypeId)
              --Check @@error
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-170)
                end
            end
        end
      --road
      --Create road/suburb  
      if @v_SuburbLocalityId > 0 and @v_RoadId > 0
        begin
          select @v_iTemp=Count(*) 
            from road_suburb where
            sl_id = @v_SuburbLocalityId and
            road_id = @v_RoadId
          if @v_iTemp = 0
            begin
              insert into road_suburb(sl_id,road_id) values(
                @v_SuburbLocalityId,@v_RoadId)
              --Check @@error
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-185)
                end
            end
        end
      --Create town/road 
      if @v_RoadId > 0 and @v_TownCityId > 0
        begin
          select @v_iTemp=Count(*) 
            from town_road where
            tc_id = @v_TownCityId and
            road_id = @v_RoadId
          if @v_iTemp = 0
            begin
              insert into town_road(tc_id,road_id) values(
                @v_TownCityId,@v_RoadId)
              --Check @@error
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
                  return(-195)
                end
            end
        end
      select top 1 @v_PostCodeId=post_code.post_code_id 
        from post_code where
        rd.Trim(Lower(post_code.post_code)) = rd.Trim(Lower(@v_cust_post_code)) and
        rd.Trim(Lower(post_mail_town)) = rd.Trim(Lower(@v_cust_mail_town))
      --Migrate the address: main address record
      insert into address(adr_id,tc_id,road_id,
        sl_id,contract_no,post_code_id,
        adr_rd_no,adr_no,/*adr_nad_reference,*/
        adr_old_delivery_days,adr_property_identification,adr_date_loaded) values(
        @v_cust_id,@v_TownCityId,@v_RoadId,
        @v_SuburbLocalityId,@v_contract_no,@v_PostCodeId,
        @v_cust_rd_number,@v_cust_mailing_address_no,/*@v_cust_nad_reference,*/
        @v_cust_old_delivery_days,@v_cust_property_identification,@v_cust_date_first_loaded)
      --Check @@error
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-200)
        end
      /*Migrate customer*/
      insert into rds_customer(cust_id,
        cust_title,cust_surname_company,
        cust_initials,cust_phone_day,cust_phone_night,
        cust_dir_listing_ind,cust_dir_listing_text,cust_business,
        cust_rural_resident,cust_rural_farmer,printedon,
        cust_date_commenced,
        cust_phone_mobile,master_cust_id,
        cust_care_of,cust_adpost_quantity) values(
        @v_cust_id,@v_cust_title,isNull(@v_cust_surname_company,''),
        @v_cust_initials,@v_cust_phone_day,@v_cust_phone_night,
        isNull(@v_cust_dir_listing_ind,'N'),@v_cust_dir_listing_text,@v_cust_business,
        @v_cust_rural_resident,@v_cust_rural_farmer,@v_printedon,
        (case when @v_cust_date_commenced > @v_cust_date_last_transfered or @v_cust_date_last_transfered is null then @v_cust_date_commenced else @v_cust_date_last_transfered end),
        @v_cust_phone_mobile,null,
        null,@v_cust_adpost_quantity)
      --Check @@error
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-210)
        end
      select @v_MaxRecipientId=Max(cust_id) 
        from rds_customer where
        cust_id > 500000
      if @v_MaxRecipientId is null
        select @v_MaxRecipientId=500000
      /*Migrate recipients*/
      insert into rds_customer(cust_id,
        cust_title,cust_surname_company,
        cust_initials,cust_phone_day,cust_phone_night,
        cust_dir_listing_ind,cust_dir_listing_text,cust_business,
        cust_rural_resident,cust_rural_farmer,printedon,
        cust_date_commenced,cust_phone_mobile,master_cust_id,
        cust_care_of,cust_adpost_quantity)
        select row_number() over (order by master_cust_id asc) +@v_MaxRecipientId,null,isNull(rc_surname_company,''),
          isNull(rc_first_names,''),null,null,'N',
          null,null,
          null,null,null,
          null,null,@v_cust_id,
          null,null from
          recipient where
          cust_id = @v_cust_id
      --Check @@error
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-220)
        end
      --Migrate Address Frequency Sequence
      insert into address_frequency_sequence(adr_id,
        sf_key,rf_delivery_days,contract_no,seq_num)
        select @v_cust_id,sf_key,rf_delivery_days,@v_contract_no,cfo_sequence from
          cust_frequency_order where
          contract_no = @v_contract_no and
          cust_id = @v_cust_id
      --Check @@error
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-230)
        end
      --Generate Customer moves 
      insert into customer_address_moves(adr_id,
        cust_id,move_in_date,move_out_date) values(
        @v_cust_id,@v_cust_id,isNull(@v_cust_date_commenced,getdate()),null)
      --Check @@error
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-240)
        end
      --Generate Customer moves for recipients
      insert into customer_address_moves(adr_id,
        cust_id,move_in_date,move_out_date)
        select @v_cust_id,cust_id,isNull(@v_cust_date_commenced,getdate()),null from
          rds_customer where
          master_cust_id = @v_cust_id
      --Check @@error
      if @@error <> 0 /* <> was < */
        begin
          rollback transaction
          return(-250)
        end
    end
  --Migrate Route Description - No need (just drop the foreign key to customer)
  --************************
  --Close the cursor
  close vc_ContractCustomers
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-270)
    end
  --Commit changes
  commit transaction
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-290)
    end
  select @v_Loops 
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_PrepareMigrateDpa2002]
as
begin
  --Temp variables
  declare @v_iTemp integer
  --Generate road types
  delete from address_frequency_sequence
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-1)
    end
  delete from customer_address_moves
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-2)
    end
  delete from rds_customer
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-3)
    end
  delete from road_suburb
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-4)
    end
  delete from town_suburb
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-5)
    end
  delete from town_road
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-6)
    end
  delete from address
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-7)
    end
  delete from road
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-8)
    end
  delete from TownCity
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-9)
    end
  delete from SuburbLocality
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-10)
    end
  delete from road_type
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-11)
    end
  commit transaction
  
  DBCC CHECKIDENT ('rd.TownCity', RESEED, 0)
  DBCC CHECKIDENT ('rd.road_type', RESEED, 0)
  DBCC CHECKIDENT ('rd.SuburbLocality', RESEED, 0)  
  
  insert into road_type(rt_id,rt_name,rt_abbrev) values(1,'Avenue','Ave')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(2,'Grove','Gve')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(3,'Street','St')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(4,'Highway','Hwy')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(5,'Motorway','Motorway')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(6,'Terrace','Tce')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(7,'Road','Rd')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(8,'Boulevard','Blvd')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(9,'Lane','Ln')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(10,'Crescent','Cres')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(11,'Way','Way')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(12,'Close','Close')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(13,'Court','Ct')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(14,'Drive','Dve')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(15,'Esplanade','Espl')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(16,'Junction','Junction')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(17,'Line','Line')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(18,'Park','Park')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(19,'Parade','Pde')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(20,'Point','Point')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(21,'Place','Pl')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(22,'Rise','Rise')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(23,'Straight','Straight')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(24,'Track','Track')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(25,'Village','Village')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(26,'Bend','Bend')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(27,'Creek','Creek')
  insert into road_type(rt_id,rt_name,rt_abbrev) values(28,'Pass','Pass')
  commit transaction
  --Check @@error
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
      return(-30)
    end
  select 1 
end


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetTownSuburbMap : 
--

CREATE procedure [rd].[sp_GetTownSuburbMap] as
begin
  select towncity.tc_id,
    towncity.region_id,
    towncity.tc_name,
    suburblocality.sl_id,
    suburblocality.sl_name from
    towncity,
    suburblocality,
    town_suburb where
    (town_suburb.sl_id = suburblocality.sl_id) and
    (town_suburb.tc_id = towncity.tc_id)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure v_expPercent : 
--
CREATE function  [rd].[v_expPercent](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns real
as -- TJB  SR4658  9-Apr-2005 Bug fix
begin 
  declare @i_exp_num real,
  @i_total real,
  @d_percentage real,
  @month_6 datetime,
  @count_final int
  -- table to hold end results and allow the filtering of results
  declare  @final_temp table(
    reg_name char(40) null,
    expiry datetime null,
    con_num int null,
    rego char(8) null,
    vmake char(20) null,
    vmodel char(20) null,
    vyear smallint null
    ) 
declare  @cv_temp table(
    v_num int null,
    c_num int null,
    start_num int null,
    seq_no int null,
    dist_renew numeric(10,2) null
    ) 
declare  @cr_temp table(
    c_num int null,
    cd_num numeric(10,2) null
    ) 
declare  @con_temp table(
    contract_no int null,
    active_seq int null
    )
-- MRB 12/3/2007 - added in active_seq to returned list
  insert into @con_temp(contract_no,active_seq)
    select distinct(con.contract_no),con.con_active_sequence from
      towncity as tc join address as addr on tc.tc_id = addr.tc_id join contract as con on addr.contract_no = con.contract_no join contract_renewals as cr on con.contract_no = cr.contract_no where
      (@inRegion = 0 or @inRegion is null or tc.region_id = @inRegion) and
      (@inOutlet = 0 or @inOutlet is null or con.con_lodgement_office = @inOutlet) and
      (@inContractType = 0 or @inContractType is null or con.con_base_cont_type = @inContractType) and
      (@inRenGroup = 0 or @inRenGroup is null or con.rg_code = @inRenGroup) and
      cr.con_expiry_date > rd.today()
  -- populate the contract_vehicle temp with the lastest vehicles 
  -- where vehicle newer than contract start date
  insert into @cv_temp(v_num,c_num,start_num,seq_no,dist_renew)
    select distinct(cv.vehicle_number),
      cv.contract_no,
      max(cv.start_kms),
      max(cv.contract_seq_number),
      max(cr.con_distance_at_renewal) from
      contract_vehical as cv join vehicle as veh on cv.vehicle_number = veh.vehicle_number,
      @con_temp as temp,
      contract_renewals as cr where
      cv.contract_no = temp.contract_no and
      -- TJB  SR4658  9-Apr-2005
      -- Bug fix: removed following line.
      -- con_temp.active_seq is never populated so this condition is never true!
      -- MRB 12/3/2007 - added line back in as list was not returning the correct vehicle details
      -- and commented out filter for null start_kms as this was excluding valid vehicles.
      cv.contract_seq_number = temp.active_seq and
      --       and cv.start_kms is not null
      cr.contract_no = cv.contract_no and
      cr.contract_seq_number = cv.contract_seq_number and
      cr.con_distance_at_renewal is not null and
      veh.v_purchased_date >= cr.con_start_date and
      veh.v_purchased_date = (select max(veh1.v_purchased_date) from
        contract_vehical as cv2 join vehicle as veh1 on cv2.vehicle_number = veh1.vehicle_number where
        cv2.contract_no = cv.contract_no
        group by cv2.contract_no)
      group by cv.contract_no,cv.vehicle_number,cv.start_kms,cv.contract_seq_number,cr.con_distance_at_renewal
  -- populate the contract_vehicle temp with latest vehicles - where vehicles older than contract start
  insert into @cv_temp(v_num,c_num,start_num,seq_no,dist_renew)
    select distinct(cv.vehicle_number),
      cv.contract_no,
      cv.start_kms,
      cv.contract_seq_number,
      cr.con_distance_at_renewal from
      contract_vehical as cv join vehicle as veh on cv.vehicle_number = veh.vehicle_number,
      @con_temp as temp,
      contract_renewals as cr where
      cv.contract_no = temp.contract_no and
      not cv.contract_no = any(select c_num from @cv_temp) and
      not cv.vehicle_number = any(select v_num from @cv_temp) and
/*!      cv.start_kms is not null and
      cv.start_kms = (select min(cv1.start_kms) from
        contract_vehical as cv1 where
        cv1.contract_no = cv.contract_no) and  */
      --MRB 12/3/2007 - remove start_kms filters as these were excluding valid vehicles
      --       and cv.start_kms is not null
      --       and cv.start_kms = (select min(cv1.start_kms) 
      --                             from contract_vehical cv1 
      --                            where cv1.contract_no = cv.contract_no)

      cr.contract_seq_number = cv.contract_seq_number and
      cv.contract_seq_number = temp.active_seq and
      cr.contract_no = cv.contract_no and
      cr.con_distance_at_renewal is not null and
      veh.v_purchased_date < cr.con_start_date and
      veh.v_purchased_date = (select max(veh1.v_purchased_date) from
        contract_vehical as cv2 join vehicle as veh1 on cv2.vehicle_number = veh1.vehicle_number where
        cv2.contract_no = cv.contract_no
        group by cv2.contract_no)
      group by cv.contract_no,cv.vehicle_number,cv.start_kms,cv.contract_seq_number,cr.con_distance_at_renewal
  -- set any milages over 200000 to limit of 200000
  update @cv_temp set
    start_num = 200000 where
    start_num > 200000
  -- set any null mileages to 0
  update @cv_temp set
    start_num = 0 where
    start_num is null;

  insert into @final_temp(expiry,con_num,rego,vmake,vmodel,vyear)
    select distinct expiry=(case when cv.start_num > 5000 and cv.start_num is not null then
        rd.date(dateadd(day,(((200000-cv.start_num)/cv.dist_renew)*365),v.v_purchased_date))
      else rd.date(dateadd(day,((200000/cv.dist_renew)*365),v.v_purchased_date))
      end),
      con.contract_no,
      v.v_vehicle_registration_number,
      v.v_vehicle_make,
      v.v_vehicle_model,
      v.v_vehicle_year from
      vehicle as v,
      @con_temp as con,
      @cv_temp as cv where
      -- cr.c_num = con.contract_no   
      cv.c_num = con.contract_no and
      v.vehicle_number = cv.v_num and
      v.v_purchased_date is not null and
      -- exclude styles : boat, bus, minibus, motorcycle, trucks
      v.vs_key not in(3,8,12,16,15)
  -- see how many are to expire before today
  select @i_exp_num = count(*) 
    from @final_temp as ft where
    ft.expiry > rd.today()
  -- get the total
  select @i_total = count(*)
    from @final_temp
  if @i_total <> 0
    begin
      select @d_percentage=(@i_exp_num/@i_total)*100
      select @d_percentage=round(@d_percentage,2)
    end
  else
    select @d_percentage=0
  return @d_percentage
end



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractor : 
--

--
-- Definition for stored procedure sp_GetContractor : 
--

CREATE procedure [rd].[sp_GetContractor](@in_Contractor int)
as
begin
  select contractor_supplier_no,
    c_title,
    c_surname_company,
    c_first_names,
    c_initials,
    c_address,
    c_phone_day,
    c_phone_night,
    c_mobile from
    contractor where
    contractor_supplier_no = @in_Contractor
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractorFull : 
--

--
-- Definition for stored procedure sp_GetContractorFull : 
--

CREATE procedure [rd].[sp_GetContractorFull](@in_Contractor int)
as
begin
  select contractor_supplier_no,
    c_title,
    c_surname_company,
    c_first_names,
    c_initials,
    c_address,
    c_phone_day,
    c_phone_night,
    c_mobile,
    c_bank_account_no,
    c_ird_no,
    c_gst_number,
    c_tax_rate,
    c_salutation from
    contractor where
    contractor_supplier_no = @in_Contractor
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractorFullODPS : 
--

--
-- Definition for stored procedure sp_GetContractorFullODPS : 
--

CREATE procedure [rd].[sp_GetContractorFullODPS](@in_Contractor int)
as
begin
  select contractor_supplier_no,
    c_title,
    c_surname_company,
    c_first_names,
    c_initials,
    c_address,
    c_phone_day,
    c_phone_night,
    c_mobile,
    c_bank_account_no,
    c_ird_no,
    c_gst_number,
    c_tax_rate,
    c_salutation,
    NZ_Post_Employee,
    c_witholding_tax_certificate,
    c_tpid_number,
    c_email_address from
    contractor where
    contractor_supplier_no = @in_Contractor
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_ContractorList : 
--

CREATE procedure [odps].[sp_ContractorList]
as
begin
  select c.contractor_supplier_no,
    contractor_name=c.c_surname_company + isnull(c.c_first_names,isnull(c.c_initials,'')) from
    rd.contractor as c
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure od_dws_ContractorList : 
--

CREATE procedure [odps].[od_dws_ContractorList]
as
begin
  select c.contractor_supplier_no,
    contractor_name=c.c_surname_company + case when isnull(c.c_first_names,'') = '' then case when isnull(c.c_initials,'') = '' then '' else ', ' + c.c_initials end
			else ', ' + c.c_first_names end  from
    rd.contractor as c
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_SearchForContractor3](@in_ContractorSupplierNo int,@in_ContractNo int,@in_ct_key int,@in_c_surname_company char(40),@in_c_first_names char(40),@in_c_phone_day char(11))
as
begin
  select contractor_supplier_no from
    contractor
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure OD_DWS_NetPay_Before_acceptance : 
--

CREATE procedure  [odps].[OD_DWS_NetPay_Before_acceptance]
as
begin
  select distinct contractor.c_surname_company + case when len(c_first_names) > 0 then ', ' + c_first_names else ''
    end,Payment_Value=(select sum(pc_amount) from
       odps.t_payment_component INNER JOIN
       odps.Payment_Component_Type ON odps.t_payment_component.pct_id = odps.Payment_Component_Type.pct_id INNER JOIN
       odps.payment_component_group ON odps.Payment_Component_Type.pcg_id = odps.payment_component_group.pcg_id where
--      t_payment_component.pct_id = payment_component_type.pct_id and
--      payment_component_group.pcg_id = payment_component_type.pcg_id and
      payment_component_group.pcg_Short_code in('GP','OGP') and
      t_payment.invoice_id = t_payment_component.invoice_id),
    tax=(select sum(pc_amount)*-1 from
       odps.t_payment_component INNER JOIN
       odps.Payment_Component_Type ON odps.t_payment_component.pct_id = odps.Payment_Component_Type.pct_id INNER JOIN
       odps.payment_component_group ON odps.Payment_Component_Type.pcg_id = odps.payment_component_group.pcg_id where
--      t_payment_component.pct_id = payment_component_type.pct_id and
--      payment_component_group.pcg_id = payment_component_type.pcg_id and
      payment_component_group.pcg_Short_code = 'TAX' and
      t_payment.invoice_id = t_payment_component.invoice_id),
    GST=(select sum(pc_amount) from
       odps.t_payment_component INNER JOIN
       odps.Payment_Component_Type ON odps.t_payment_component.pct_id = odps.Payment_Component_Type.pct_id INNER JOIN
       odps.payment_component_group ON odps.Payment_Component_Type.pcg_id = odps.payment_component_group.pcg_id where
--      t_payment_component.pct_id = payment_component_type.pct_id and
--      payment_component_group.pcg_id = payment_component_type.pcg_id and
      payment_component_group.pcg_Short_code = 'GST' and
      t_payment.invoice_id = t_payment_component.invoice_id),
    Adjustments=(select abs(sum(pc_amount)) from
       odps.t_payment_component INNER JOIN
       odps.Payment_Component_Type ON odps.t_payment_component.pct_id = odps.Payment_Component_Type.pct_id INNER JOIN
       odps.payment_component_group ON odps.Payment_Component_Type.pcg_id = odps.payment_component_group.pcg_id where
--      t_payment_component.pct_id = payment_component_type.pct_id and
--      payment_component_group.pcg_id = payment_component_type.pcg_id and
      payment_component_group.pcg_Short_code = 'PTA' and
      t_payment.invoice_id = t_payment_component.invoice_id),
    contract_no from
     odps.t_payment INNER JOIN rd.contractor 
    ON  contractor.contractor_supplier_no = odps.t_payment.contractor_supplier_no where
    t_payment.contractor_supplier_no = contractor.contractor_supplier_no order by
    6 asc,1 asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure od_dws_netpaydet_before_acceptance : 
--

CREATE procedure [odps].[od_dws_netpaydet_before_acceptance]
as
begin
  select(case when payment_component_type.pct_description like 'Withh%' then t_payment_component.pc_amount*-1 else t_payment_component.pc_amount end),
    t_payment.contract_no,
    account_codes.ac_code,
    t_payment_component.comments,
    name=c_surname_company + case when isnull(c_first_names,'') = '' then '' else ', ' + 

c_first_names end  + ' 
                                                                                                                           ' 
from
    odps.payment_component_type,
    odps.t_payment,
    odps.t_payment_component,
    rd.contractor,
    odps.account_codes where
    (t_payment_component.invoice_id = t_payment.invoice_id) and
    (t_payment_component.pct_id = payment_component_type.pct_id) and
    (t_payment.contractor_supplier_no = contractor.contractor_supplier_no) and
    (account_codes.ac_id = payment_component_type.ac_id) order by
    t_payment.contract_no asc,c_surname_company asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_RPF_PCGetSumYear : 
--

CREATE function [odps].[OD_RPF_PCGetSumYear](@con_supplier int,@contract int,@con_seq_no int,@sdate datetime,@edate datetime,@ShortCode char(5),@NZPostEmp char(1)=
null)
returns numeric(12,2)
as
begin
  -- TJB SR4611 2 Aug 2004
  -- Add clauses to calculate taxable allowances sttributed to NZH (NZ Herald)
  -- and Guardian (amt2), then deduct this from the gross pay calculated (amt1).
  -- Note: if the '... not like ...' clauses are included in the gross pay
  -- statement, rows with NULL values in the misc_string column are also excluded.
  declare @amt1 numeric(12,2),
  @amt2 numeric(12,2)
  if @NZPostEmp is null
    begin
      select @amt1 = sum(payment_component.pc_amount) 
        from payment,payment_component,payment_component_type,
        payment_component_group where
        payment.contractor_supplier_no = @con_supplier and
        payment.contract_no = @contract and
        --Removed for net pay variance report testing 19/7/2000
        -- |note by JJG - including the next line screws up the net pay variance report
        -- |excluding the next line screws up the yearly earnings report
        payment.contract_seq_number = @con_seq_no and
        payment.invoice_id = payment_component.invoice_id and
        payment_component.pct_id = payment_component_type.pct_id and
        --Added 16/09/1999
        -- This stops it from adding Kiwimail, Courierpost and XP, so that the extension,
        -- Standard and allowance are the only values that are calculated.  
        -- TJB 2-Aug-2004 - changed to 'not in ...' syntax
        payment_component_type.pct_id not in(7,9,13) and
        payment_component_type.pcg_id = payment_component_group.pcg_id and
        payment_component_group.pcg_short_code = @ShortCode and
        payment.invoice_date between @sdate and @edate
      -- TJB SR4611 2 Aug 2004
      select @amt2 = sum(payment_component.pc_amount) 
        from payment,payment_component,payment_component_type,
        payment_component_group where
        payment.contractor_supplier_no = @con_supplier and
        payment.contract_no = @contract and
        payment.contract_seq_number = @con_seq_no and
        payment.invoice_id = payment_component.invoice_id and
        payment_component.pct_id = payment_component_type.pct_id and
        payment_component_type.pcg_id = payment_component_group.pcg_id and
        payment_component_group.pcg_short_code = @ShortCode and
        payment.invoice_date between @sdate and @edate and
        payment_component.pct_id not in(7,9,13) and
        (payment_component.misc_string like '%NZH%' or
        payment_component.misc_string like '%Guardian%')
      select @amt1=iSnull(@amt1,0) - iSnull(@amt2,0)
    end
  else
    if upper(@NZPostEmp) = 'Y'
      begin
        select @amt1 = sum(payment_component.pc_amount) 
          from payment,rd.contractor,payment_component,payment_component_type,
          payment_component_group where
          payment.contractor_supplier_no = @con_supplier and
          payment.contract_no = @contract and
          payment.contract_seq_number = @con_seq_no and
          payment.contractor_supplier_no = contractor.contractor_supplier_no and
          payment.invoice_id = payment_component.invoice_id and
          payment_component.pct_id = payment_component_type.pct_id and
          --Added 16/09/1999
          -- This stops it from adding Kiwimail, Courierpost and XP, so that the extension,
          -- Standard and allowance are the only values that are calculated.  
          -- TJB 2-Aug-2004 - changed to 'not in ...' syntax
          payment_component_type.pct_id not in(7,9,13) and
          payment_component_type.pcg_id = payment_component_group.pcg_id and
          payment_component_group.pcg_short_code = @ShortCode and
          contractor.nz_post_employee = 'Y' and
          payment.invoice_date between @sdate and @edate
        -- TJB SR4611 2 Aug 2004
        select @amt2 = sum(payment_component.pc_amount) 
          from payment,rd.contractor,payment_component,
          payment_component_type,payment_component_group where
          payment.contractor_supplier_no = @con_supplier and
          payment.contract_no = @contract and
          payment.contract_seq_number = @con_seq_no and
          payment.contractor_supplier_no = contractor.contractor_supplier_no and
          payment.invoice_id = payment_component.invoice_id and
          payment_component.pct_id = payment_component_type.pct_id and
          payment_component.pct_id not in(7,9,13) and
          payment_component_type.pcg_id = payment_component_group.pcg_id and
          payment_component_group.pcg_short_code = @ShortCode and
          contractor.nz_post_employee = 'Y' and
          payment.invoice_date between @sdate and @edate and
          (payment_component.misc_string like '%NZH%' or
          payment_component.misc_string like '%Guardian%')
        select @amt1=isnull(@amt1,0) - isnull(@amt2,0)
      end
    else
      begin
        select @amt1 = sum(payment_component.pc_amount) 
          from payment,rd.contractor,payment_component,payment_component_type,
          payment_component_group where
          payment.contractor_supplier_no = @con_supplier and
          payment.contract_no = @contract and
          payment.contract_seq_number = @con_seq_no and
          payment.contractor_supplier_no = contractor.contractor_supplier_no and
          payment.invoice_id = payment_component.invoice_id and
          payment_component.pct_id = payment_component_type.pct_id and
          --Added 16/09/1999
          -- This stops it from adding Kiwimail, Courierpost and XP, so that the extension,
          -- Standard and allowance are the only values that are calculated.  
          -- TJB 2-Aug-2004 - changed to 'not in ...' syntax
          payment_component_type.pct_id not in(7,9,13) and
          payment_component_type.pcg_id = payment_component_group.pcg_id and
          payment_component_group.pcg_short_code = @ShortCode and
          (contractor.nz_post_employee = 'N' or contractor.nz_post_employee is null) and
          payment.invoice_date between @sdate and @edate
        -- TJB SR4611 2 Aug 2004
        select @amt2 = sum(payment_component.pc_amount) 
          from payment,rd.contractor,payment_component,
          payment_component_type,payment_component_group where
          payment.contractor_supplier_no = @con_supplier and
          payment.contract_no = @contract and
          payment.contract_seq_number = @con_seq_no and
          payment.contractor_supplier_no = contractor.contractor_supplier_no and
          payment.invoice_id = payment_component.invoice_id and
          payment_component.pct_id = payment_component_type.pct_id and
          payment_component.pct_id not in(7,9,13) and
          payment_component_type.pcg_id = payment_component_group.pcg_id and
          payment_component_group.pcg_short_code = @ShortCode and
          (contractor.nz_post_employee = 'N' or
          contractor.nz_post_employee is null) and
          payment.invoice_date between @sdate and @edate and
          (payment_component.misc_string like '%NZH%' or
          payment_component.misc_string like '%Guardian%')
        select @amt1=isnull(@amt1,0)-isnull(@amt2,0)
      end
  return @amt1
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_RPF_PCGetSumYear_spec : 
--

CREATE function [odps].[OD_RPF_PCGetSumYear_spec](@con_supplier int,@contract int,@con_seq_no int,@sdate datetime,@edate datetime,@ShortCode char(5),@NZPostEmp char(1)= null)
returns numeric(12,2)as
begin
  declare @amt numeric(12,2)
  if @NZPostEmp is null
    select @amt = sum(payment_component.pc_amount)  
      from payment,payment_component,payment_component_type,payment_component_group where
      payment.contractor_supplier_no = @con_supplier and
      payment.contract_no = @contract and
      --Removed for net pay variance report testing 19/7/2000
      -- |note by JJG - including the next line screws up the net pay variance report
      -- |excluding the next line screws up the yearly earnings report
      payment.contract_seq_number = @con_seq_no and
      payment.invoice_id = payment_component.invoice_id and
      payment_component.pct_id = payment_component_type.pct_id and
      --Added 16/09/1999,this stops it from adding Kiwimail ,Courierpost and XP.
      --So that the extension ,Standard and allowance are the only values that are 
      --calculated.  
      payment_component_type.pct_id <> 7 and
      payment_component_type.pct_id <> 9 and
      payment_component_type.pct_id <> 13 and
      payment_component_type.pcg_id = payment_component_group.pcg_id and
      payment_component_group.pcg_short_code = @ShortCode and
      payment.invoice_date between @sdate and @edate
  else
    if upper(@NZPostEmp) = 'Y'
      select @amt = sum(payment_component.pc_amount) 
        from payment,rd.contractor,payment_component,payment_component_type,payment_component_group where
        payment.contractor_supplier_no = @con_supplier and
        payment.contract_no = @contract and
        payment.contract_seq_number = @con_seq_no and
        payment.contractor_supplier_no = contractor.contractor_supplier_no and
        payment.invoice_id = payment_component.invoice_id and
        payment_component.pct_id = payment_component_type.pct_id and
        --Added 16/09/1999,this stops it from adding Kiwimail ,Courierpost and XP.
        --So that the extension ,Standard and allowance are the only values that are 
        --calculated.  
        payment_component_type.pct_id <> 7 and
        payment_component_type.pct_id <> 9 and
        payment_component_type.pct_id <> 13 and
        payment_component_type.pcg_id = payment_component_group.pcg_id and
        payment_component_group.pcg_short_code = @ShortCode and
        contractor.nz_post_employee = 'Y' and
        payment.invoice_date between @sdate and @edate
    else
      select @amt = sum(payment_component.pc_amount) 
        from payment,rd.contractor,payment_component,payment_component_type,payment_component_group where
        payment.contractor_supplier_no = @con_supplier and
        payment.contract_no = @contract and
        payment.contract_seq_number = @con_seq_no and
        payment.contractor_supplier_no = contractor.contractor_supplier_no and
        payment.invoice_id = payment_component.invoice_id and
        payment_component.pct_id = payment_component_type.pct_id and
        --Added 16/09/1999,this stops it from adding Kiwimail ,Courierpost and XP.
        --So that the extension ,Standard and allowance are the only values that are 
        --calculated.  
        payment_component_type.pct_id <> 7 and
        payment_component_type.pct_id <> 9 and
        payment_component_type.pct_id <> 13 and
        payment_component_type.pcg_id = payment_component_group.pcg_id and
        payment_component_group.pcg_short_code = @ShortCode and
        (contractor.nz_post_employee = 'N' or contractor.nz_post_employee is null) and
        payment.invoice_date between @sdate and @edate
  if @amt is null
    return 0
  else
    return @amt
return -1
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_RPF_PCYearlyEarnings : 
--

CREATE function [odps].[OD_RPF_PCYearlyEarnings](@con_supplier int,@contract int,@con_seq_no int,@sdate datetime,@edate datetime,@ShortCode char(5),@NZPostEmp char(1) ) --! = null)
returns decimal(12,2)
as
begin
  declare @amt decimal(12,2)
  if @NZPostEmp is null
    select @amt = sum(payment_component.pc_amount) 
      from payment,payment_component,payment_component_type,payment_component_group where
      payment.contractor_supplier_no = @con_supplier and
      payment.contract_no = @contract and
      payment.contract_seq_number = @con_seq_no and
      payment.invoice_id = payment_component.invoice_id and
      payment_component.pct_id = payment_component_type.pct_id and
      --Added 16/09/1999,this stops it from adding Kiwimail ,Courierpost and XP.
      --So that the extension ,Standard and allowance are the only values that are 
      --calculated.  
      --and payment_component_type.pct_id<>7
      --and payment_component_type.pct_id<>9
      --and payment_component_type.pct_id<>13
      payment_component_type.pcg_id = payment_component_group.pcg_id and
      payment_component_group.pcg_short_code = @ShortCode and
      payment.invoice_date between @sdate and @edate
  else
    if upper(@NZPostEmp) = 'Y'
      select @amt = sum(payment_component.pc_amount) 
        from payment,rd.contractor,payment_component,payment_component_type,payment_component_group where
        payment.contractor_supplier_no = @con_supplier and
        payment.contract_no = @contract and
        payment.contract_seq_number = @con_seq_no and
        payment.contractor_supplier_no = contractor.contractor_supplier_no and
        payment.invoice_id = payment_component.invoice_id and
        payment_component.pct_id = payment_component_type.pct_id and
        --Added 16/09/1999,this stops it from adding Kiwimail ,Courierpost and XP.
        --So that the extension ,Standard and allowance are the only values that are 
        --calculated.  
        --and payment_component_type.pct_id<>7
        --and payment_component_type.pct_id<>9
        --and payment_component_type.pct_id<>13
        payment_component_type.pcg_id = payment_component_group.pcg_id and
        payment_component_group.pcg_short_code = @ShortCode and
        contractor.nz_post_employee = 'Y' and
        payment.invoice_date between @sdate and @edate
    else
      select @amt = sum(payment_component.pc_amount) 
        from payment,rd.contractor,payment_component,payment_component_type,payment_component_group where
        payment.contractor_supplier_no = @con_supplier and
        payment.contract_no = @contract and
        payment.contract_seq_number = @con_seq_no and
        payment.contractor_supplier_no = contractor.contractor_supplier_no and
        payment.invoice_id = payment_component.invoice_id and
        payment_component.pct_id = payment_component_type.pct_id and
        --Added 16/09/1999,this stops it from adding Kiwimail ,Courierpost and XP.
        --So that the extension ,Standard and allowance are the only values that are 
        --calculated.  
        --and payment_component_type.pct_id<>7
        --and payment_component_type.pct_id<>9
        --and payment_component_type.pct_id<>13
        payment_component_type.pcg_id = payment_component_group.pcg_id and
        payment_component_group.pcg_short_code = @ShortCode and
        (contractor.nz_post_employee = 'N' or contractor.nz_post_employee is null) and
        payment.invoice_date between @sdate and @edate
  if @amt is null
    return 0
  else
    return @amt
return -1
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure od_OwnerDriver : 
--

CREATE procedure  [odps].[od_OwnerDriver](@inStartDate datetime,@inEndDate datetime,@inOwnerDriver varchar(40))
as
begin
  select payment.contract_no,
    contractor.c_first_names from
    rd.contractor,payment where
    contractor.contractor_supplier_no = payment.contractor_supplier_no and
    payment.invoice_date between @inStartDate and @inEndDate and
    contractor.c_first_names like @inOwnerDriver+'%'
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_UpdatedContractors : 
--

CREATE procedure [odps].[OD_RPS_UpdatedContractors](@FromDate datetime,@ToDate datetime)
as
begin
select DS_No=(select max(cd_old_ds_no) from rd.contractor_ds where contractor_ds.contractor_supplier_no = contractor.contractor_supplier_no),
    title=c_title,
    initials=c_initials,
    surname_company=c_surname_company,
    address1=c_address,
    bank_account_no=c_bank_account_no,bank=space(40),
    branch=space(40),changetype=' New Vendor' from
    rd.rds_audit,
    rd.contractor where
    contractor.contractor_supplier_no = a_contractor and
    rds_audit.a_comment = 'New Contractor' and
    rd.date(rds_audit.a_datetime) between rd.date(@FromDate) and rd.date(@ToDate) 

union all
  select DS_No=(select max(cd_old_ds_no) from rd.contractor_ds where contractor_ds.contractor_supplier_no = contractor.contractor_supplier_no),
    title=(case when a_newvalue like '%Title:%' then
      c_title
    else
      space(10)
    end),
    initials=(case when a_newvalue like '%Initials:%' then
      c_initials
    else
      space(10)
    end),
    surname_company=(case when a_newvalue like '%Surname or company name:%' then
      c_surname_company
    else
      space(40)
    end),
    address1=(case when a_newvalue like '%Address:%' then
      c_address
    else
      space(200)
    end),
    bank_account_no=(case when a_newvalue like '%Bank account number:%' then
      c_bank_account_no
    else
      space(18)
    end),
    bank=space(40),
    branch=space(40),
    changetype=(case when (case when a_newvalue like '%Title:%' then c_title else space(10) end) <> space(10) then 'Title'  --!changed title to its origine 
    else
      case when (case when a_newvalue like '%Initials:%' then c_initials else space(10) end) <> space(10) then 'Initials'  --!changed initials to its origine 
      else
        case when (case when a_newvalue like '%Surname or company name:%' then c_surname_company else space(40) end) <> space(40) then 'Name'  --!changed surname_company to its origine 
        else
          case when (case when a_newvalue like '%Address:%' then c_address else space(200) end) <> space(200) then 'Address'  --!changed address1 to its origine 
          else
            case when (case when a_newvalue like '%Bank account number:%' then c_bank_account_no else space(18) end) <> space(18) then 'Bank account no'  --!changed bank_account_no to its origine 
            end
          end
        end
      end
    end) from
    rd.rds_audit,
    rd.contractor where
    contractor.contractor_supplier_no = a_contractor and
    rds_audit.a_comment = 'Updated Contractor' and
    rd.date(rds_audit.a_datetime) between rd.date(@FromDate) and rd.date(@ToDate) and
    (a_newvalue like '%Title:%' or
    a_newvalue like '%Initials:%' or
    a_newvalue like '%Surname or company name:%' or
    a_newvalue like '%Address:%' or
    a_newvalue like '%Bank account number:%' or
    a_newvalue like '%Branch:%' or
    a_newvalue like '%Bank:%') order by
    1 asc,3 asc

end






GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure rds_npad_merge_address : 
--

CREATE procedure [rd].[rds_npad_merge_address](
@in_old_dpid int,
@in_new_dpid int,
@in_username char(20))
/******************************************************************
* Description
*    This routine merges the customers from one address into another
*    and deletes the old address.
*    This usually involves merging the customers from an unnumbered 
*    address into an existing numbered address.  An implicit assumption
*    is that the two addresses differ only in the street number.
*
* Parameters
*    new_dpid    - DPID of the originating address
*    old_dpid    - DPID of the new address
*    system_date - Not actually used since the address table isn''t updated
*
* Returns
*    status      - A status code
*                   0 = Success
*                  >0 = Failure for various reasons (see code)
*                  -1 = SQL errors
*    description - Short description of the status
*
* System
*    NPAD2 - NZ Post
*
* Author
*    Tom Britton, Synergy International
*
* Created 
*    November 2005
*
* Modification history
* 13Feb2006  TJB  Added deletion of geocode entry for the address (CR13)
* 14Feb2006  TJB  Fixed bug with geocode entry
*
*****************************************************************/
as
begin
  declare @status int, -- Return status (0 = success)
  @description char(100), -- Return description (mainly error
  -- message)
  @msg char(80), -- Test message
  @found integer, -- Flag indicating a database record 
  -- exists (1) or not (NULL)
  -- Sometimes used as a count.
  @old_master_cust_id int,
  @new_master_cust_id int,
  @old_adrID int, -- Old address ID
  @new_adrID int, -- New address ID
  @now datetime
  -- Need the date and time for the logged actions
  select @now=getdate()
  select @status=0
  /************************************************************
  * Check input parameters
  ***********************************************************/
  -- Check to see that the dpids are valid ...
  if @in_old_dpid is null or @in_old_dpid <= 0
    begin
      select @status=103
      select @description='Invalid old DPID'
    end
  else
  if @in_new_dpid is null or @in_new_dpid <= 0
    begin
      select @status=104
      select @description='Invalid new DPID'
    end
  -- Check that the old address already exists 
  if @status = 0
    begin
      select @found=null
      select @found = count(*) from
        address where
        dp_id = @in_old_dpid
      if @found is null or @found <> 1
        begin
          select @status=101
          select @description='Old DPID does not exist'
        end
    end
  -- Check that the new address already exists 
  if @status = 0
    begin
      select @found=null
      select @found = count(*) from
        address where
        dp_id = @in_new_dpid
      if @found is null or @found <> 1
        begin
          select @status=102
          select @description='New DPID does not exist'
        end
    end
  -- Check that the new address is a numbered address
  if @status = 0 and
    not exists(select 1 from address where
      dp_id = @in_new_dpid and
      adr_no is not null)
    begin
      select @status=105
      select @description='New DPID must be a numbered address'
    end
  -- Check that the old address is an unnumbered address
  if @status = 0 and
    exists(select 1 from address where
      dp_id = @in_old_dpid and
      adr_no is not null)
    begin
      select @status=107
      select @description='Old DPID must be an unnumbered address'
    end
  -- Check that the old DPID is for a master customer
  -- (and get the old address' master customer's cust_id)
  if @status = 0
    begin
      select @old_master_cust_id=null
      select @old_master_cust_id = rcust.cust_id from
        address as addr left outer join customer_address_moves as cam on addr.adr_id = cam.adr_id 
        left outer join rds_customer as rcust on cam.cust_id = rcust.cust_id  where
        addr.dp_id = @in_old_dpid and
        move_out_date is null and
        master_cust_id is null
      if @old_master_cust_id is null
        begin
          select @status=106
          select @description='Old address must have a master customer'
        end
    end
  /***************************************************************
  * Merge the customers from the old address into the new address
  ***************************************************************/
  if @status = 0
    begin
      -- Get the cust_id of the master customer at the new address
      -- if there is one.
      select @new_master_cust_id=null
      select @new_master_cust_id = rds_customer.cust_id from
        address left outer join customer_address_moves on address.adr_id = customer_address_moves.adr_id left outer join
        rds_customer on customer_address_moves.cust_id = rds_customer.cust_id  where
        address.dp_id = @in_new_dpid and
        move_out_date is null and
        master_cust_id is null
      -- Get the adr_id''s of the old and new addresses
      select @old_adrID = adr_id from
        address where
        dp_id = @in_old_dpid
      select @new_adrID = adr_id from
        address where
        dp_id = @in_new_dpid
      -- Link all the customers from the old address
      -- to the new address.  The new address is numbered
      -- so the customers won''t have DPIDs.
      update customer_address_moves set
        adr_id = @new_adrID,
        dp_id = null where
        adr_id = @old_adrID
      if @@error <> 0
        begin
          select @status=-1
          select @description='SQL Error '+convert(char(6),@@error)+' updating customer_address_moves'
        end
      else
        select @msg='Linked customers to new address'
      -- If the new address already has a master customer
      -- link the old master and any recipients to the 
      -- existing master at the new address as recipients
      if @status = 0 and @new_master_cust_id is not null
        begin
          update rds_customer set
            master_cust_id = @new_master_cust_id,
            cust_last_amended_date = @now,
            cust_last_amended_user = @in_username where
            (cust_id = @old_master_cust_id or
            master_cust_id = @old_master_cust_id)
          if @@error <> 0
            begin
              select @status=-1
              select @description='SQL Error '+convert(char(6),@@error)+' linking customers to new master'
            end
          else
            select @msg=@msg+' and linked customers to new master'
        end
      if @status = 0
        begin
          -- Delete the old address
          delete from address where
            dp_id = @in_old_dpid
          if @@error <> 0
            begin
              select @status=-1
              select @description='SQL Error '+convert(char(6),@@error)+' deleting old address record'
            end
          if @@error = 0
            delete from address_geocode where
              adr_id = @old_adrID
          if @@error <> 0 and @@rowcount <> 0 /* was @@error <>100 */
            begin
              -- Return the error if it isn't 'not found'' (100)
              select @status=-1
              select @description='SQL Error '+convert(char(6),@@error)+' deleting old address_geocode record'
            end
        end
    end
  /************************************************************
  * Done.  Return status
  ***********************************************************/
  if @status = 0
    begin
      commit transaction
      select @description='Success'+' - '+@msg
    end
  else
    rollback transaction
  -- log message
  select @msg= rd.trim(convert(char(8),@in_new_dpid))
  insert into NPAD_msg_log(msg_date,
    msg_username,msg_type,msg_dpid,msg_status,msg_description) values(
    @now,@in_username,'merge address',@in_old_dpid,@status,@msg)
  -- Return status
  select Status=@status,Description=@description 
  return @status
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure f_rds_npad_modify_customer : 
--

CREATE procedure [rd].[f_rds_npad_modify_customer](@dpid int,@username char(20),@description char(120),@outfile char(120))
as
begin
  declare @surname char(45),
  @initials char(30),
  @title char(10),
  @todaysDate char(10),
  @todaysTime char(8),
  @s_dpid char(8),
  @outstring varchar(2000), -- Max 32K 
  @schema char(64),
  @crlf char(2),
  @status int,
  @now datetime,
  @rc int,
  @errmsg char(120)
  select @status=0
  select @schema='http://schemas.nzpost.co.nz/NPAD/v2/RDSNPAD'
  select @rc=0
  select @errmsg=''
  -- Need today''s date/time for the XML file
  select @now=getdate()
  -- Need the DPID as a string for the XML file
  -- (or for error message)
  select @s_dpid=convert(char(8),@dpid)
  if @dpid is null
    select @s_dpid='null'
  -- Validate the DPID
  if @dpid is null or @dpid <= 0
    begin
      select @status=1
      select @errmsg='Invalid DPID: '+@s_dpid
    end
  else
    begin
      -- Look up the customer details
      select @surname = cust_surname_company,@initials = cust_initials,@title = cust_title from
        customer_address_moves as cam,rds_customer as c where
        cam.dp_id = @dpid and
        cam.move_out_date is null and
        c.cust_id = cam.cust_id
      if @@error <> 0
        begin
          select @status=@@error
          --select @errmsg = errormsg(@status)
			select @errmsg = ERROR_MESSAGE()
        end
    end
  if @status = 0
    begin
      -- Format today''s date/time for the XML file
      select @todaysDate=convert(char(10),@now,105) -- yyyy-mm-dd
      select @todaysTime=convert(char(8),@now,108) -- HH:mm:ss
      select @crlf= char(13)+ char(10)
      -- Prepare the XML file contents
      select @outstring='<?xml version="1.0"?>'+@crlf+'<NZPost xmlns="'+
        @schema+'">'+@crlf+'<Header>'+
        @crlf+'<ChannelType>RDSNPAD</ChannelType>'+
        @crlf+'<Version>0.1</Version>'+
        @crlf+'<Description>'+
        @description+'</Description>'+@crlf+'<Priority>1</Priority>'+
        @crlf+'<ProduceDate>'+
        @todaysDate+'T'+@todaysTime+'</ProduceDate>'+@crlf+'</Header>'+
        @crlf+'<RDSNPAD>'+
        @crlf+'<CustomerModify>'+
        @crlf+'<DPID>'+
        @s_dpid+'</DPID>'+@crlf+'<Surname>'+
        @surname+'</Surname>'+@crlf+'<Initials>'+
        @initials+'</Initials>'+@crlf+'<Title>'+
        @title+'</Title>'+@crlf+'<UserID>'+
        @username+'</UserID>'+@crlf+'</CustomerModify>'+
        @crlf+'</RDSNPAD>'+
        @crlf+'</NZPost>'
      -- Write the file

DECLARE   @object   int --create a Scripting Object for openning file
DECLARE   @hr   int  
DECLARE   @filehandle   int 
DECLARE   @src   varchar(255),   @desc   varchar(255)   

EXEC   @hr   =   sp_OACreate   'Scripting.FileSystemObject',   @object   OUT   
  IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
        --SELECT   hr=convert(varbinary(4),@hr),   Source=@src,   Description=@desc
		select @errmsg='create a Scripting Object failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   
          
  END   

EXEC @hr = sp_OAMethod @object, 'CreateTextFile', @filehandle OUTPUT , @outfile   --create a file
 IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
		select @errmsg='Create a text file failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   

  END   
 
EXEC   @hr   =   sp_OAMethod   @filehandle,   'Write',NULL,   @outstring    --write message to the file
  IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
		select @errmsg='Write a text file failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   
  END   
 
EXEC   @hr   =   sp_OAMethod   @filehandle,   'Close',NULL     --close the file
  IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
		select @errmsg='Write close a text file failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   
        select @status=-1
  END
  ELSE
     begin
      select @errmsg=@title+' '+@initials+' '+@surname+' File = '+@outfile
     end

      /*
	  execute @rc = xp_write_file @outfile,@outstring
      if @rc = 0
        -- If successful, "errmsg" contains details of the message
        select @errmsg=@title+' '+@initials+' '+@surname+' File = '+@outfile
      else
        begin
          -- If not successful, "errmsg" contains the error code and output filename
          select @status=-1
          select @errmsg='xp_write_file failed: rc = '+convert(char(4),@rc)+'; File = '+@outfile
        end
		*/
    end
  /**************************
  *  Exit
  **************************/
  -- Log the message
  insert into NPAD_msg_log(msg_date,
    msg_username,msg_type,msg_dpid,msg_status,msg_description) values(
    @now,@username,'modify customer',@dpid,@status,@errmsg)
  return @status
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--THE EVALUATION VERSION TRIMS COLUMN NAMES AND VARIABLES TO 7 CHARACTERS
--
CREATE procedure [rd].[f_rds_npad_addr_occupied] 
@dpid INT ,@occupied CHAR(5) ,@username CHAR(20) ,@description CHAR(120) ,@outfile CHAR(120) ,@SWP_Re INT OUTPUT 

/******************************************************************
* Description
*    This function generates an 'address occupied status' NPAD interface
*    message (an XML file).
*
*    ==> Only checks that input arguments aren't null (or 0);
*        assumes caller has passed the right DPIDs.
*
* Parameters
*    dpid          Dpid of the address
*    occupied      'true' or 'false' (is occupied or not)
*    username      Name of user making change
*    description   Description of message for XML file header
*    outfile       Name of output XML file
*
* Returns
*    0   Success
*    1   Invalid dpid
*
* System
*    NPAD2 - NZ Post
*
* Author
*    Tom Britton, Synergy International
*
* Created
*    7 May 2007
*
* Modification history
* 14 May 2007  TJB  Updated format to match ECN's specifications
******************************************************************/
AS
begin
   declare @todaysDate CHAR(10)
   declare @todaysTime CHAR(8) -- Max 32K
   declare @s_dpid CHAR(8)
   declare @outstring VARCHAR(2000)
   declare @schema CHAR(64)
   declare @crlf CHAR(2)
   declare @status INT
   declare @now DATETIME
   set @status = 0
   set @schema = 'http://schemas.nzpost.co.nz/NPAD/v2/RDSNPAD'
  -- Need the date and time for the XML file
   set @now = GetDate()
  -- Check the validity of the old DPID
   if @dpid is null or @dpid <= 0
   begin
      set @status = 1
   end
   else
   begin
    -- Convert the DPID to a string for the output file
      set @s_dpid = convert(CHAR(8),@dpid)
    -- Format the date and time for XML file elements
      set @todaysDate = convert(CHAR(10),@now,103) -- yyyy-mm-dd
      set @todaysTime = convert(CHAR(8),@now,108) -- HH:mm:ss
      set @crlf = char(13)+char(10)
    -- Prepare XML file contents
      set @outstring = '<?xml version="1.0"?>'+@crlf+'<NZPost xmlns="'+@schema+'">'+@crlf+'<Header>'+@crlf+'  <ChannelType>RDSNPAD</ChannelType>'+@crlf+'  <Version>0.1</Version>'+@crlf+'  <Description>'+@description+'</Description>'+@crlf+'  <Priority>1</Priority>'+@crlf+'  <ProduceDate>'+@todaysDate+'T'+@todaysTime+'</ProduceDate>'+@crlf+'</Header>'+@crlf+'<NPAD>'+@crlf+'  <DeliveryStatusUpdate>'+@crlf+'    <DPIDs>'+@crlf+'      <in>'+@s_dpid+'</in>'+@crlf+'    </DPIDs>'+@crlf+'    <DeliveredTo>'+@occupied+'</DeliveredTo>'+@crlf+'    <UserID>'+@username+'</UserID>'+@crlf+'  </DeliveryStatusUpdate>'+@crlf+'</NPAD>'+@crlf+'</NZPost>'
    -- Create the XML file
      --! EXECUTE xp_write_file @outfile ,@outstring
      -- Write a file

		DECLARE   @object   int --create a Scripting Object for openning file
		DECLARE   @hr   int  
		DECLARE   @filehandle   int 
		DECLARE   @src   varchar(255),   @desc   varchar(255)   

		EXEC   @hr   =   sp_OACreate   'Scripting.FileSystemObject',   @object   OUT   

		EXEC @hr = sp_OAMethod @object, 'CreateTextFile', @filehandle OUTPUT , @outfile   --create a file
		 
		EXEC   @hr   =   sp_OAMethod   @filehandle,   'Write',NULL,   @outstring    --write message to the file
		 
		EXEC   @hr   =   sp_OAMethod   @filehandle,   'Close',NULL     --close the file
   end
  /**************************
  *  Exit
  **************************/
  -- Log the message
   insert into rd.NPAD_msg_log(msg_date, msg_username, msg_type, msg_dpid, msg_status, msg_description) values(@now,@username,'address occupied',@dpid,@status,'Occupied flag = '+@occupied)
   set @SWP_Re = @status
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for stored procedure f_rds_npad_transfer_customer : 
--

CREATE procedure [rd].[f_rds_npad_transfer_customer](@old_dpid int,@new_dpid int,@username char(20),@description char(120),@outfile char(120))
/******************************************************************
* Description
*    This function generates a 'transfer customer' NPAD interface
*    message (an XML file).
*    ==> Only checks that input arguments aren''t null (or 0);
*        assumes caller has passed the right DPIDs.
* Parameters
*    old_dpid      Dpid of the customer who is transferring
*    new_dpid      Dpid of the address the customer is transferring to
*    username      Name of user making change
*    description   Description of message for XML file header
*    outfile       Name of output XML file
* Returns
*    0   Success
*    1   Invalid old dpid
*    2   Invalid new dpid
* System
*    NPAD2 - NZ Post
* Author
*    Tom Britton, Synergy International
* Created on
*    December 2005
* Modification history
* 12 Jan 2006  TJB  Added schema to NZPost definition, and date 
*                   format to XML standards.
* 16 Mar 2006  TJB  Changed "Old_DPID" to "OldDPID" and "New_DPID" 
*                   to "NewDPID" in XML message.
* 21 Mar 2006  TJB  Fixed bug in writing to npad message log
* 20 June 2006 TJB  Added check of xp_write_file & record result in
*                   npad_msg_log and improve error messages in npad_msg_log.
******************************************************************/
as
begin
  declare @todaysDate char(10),
  @todaysTime char(8),
  @s_old_dpid char(8),
  @s_new_dpid char(8),
  @outstring varchar(2000), -- Max 32K
  @schema char(64),
  @crlf char(2),
  @status integer,
  @now datetime,
  @rc integer,
  @errmsg char(40)
  select @status=0
  select @schema='http://schemas.nzpost.co.nz/NPAD/v2/RDSNPAD'
  select @rc=0
  select @errmsg=''
  -- Need the date and time for the XML file
  select @now=getdate()
  -- Convert the DPIDs to strings for the output file
  -- (or for the error message if the values are invalid)
  select @s_old_dpid=convert(char(8),@old_dpid)
  select @s_new_dpid=convert(char(8),@new_dpid)
  if @old_dpid is null
    select @s_old_dpid='null'
  if @new_dpid is null
    select @s_new_dpid='null'
  -- Check the validity of the old DPID
  if @old_dpid is null or @old_dpid <= 0
    begin
      select @status=1
      select @errmsg='Invalid old DPID: '+@s_old_dpid
    end
  else
  if @new_dpid is null or @new_dpid <= 0
    begin
      -- Check the validity of the new DPID
      select @status=2
      select @errmsg='Invalid new DPID: '+@s_new_dpid
    end
  else
    begin
      -- Format the date and time for XML file elements
      select @todaysDate=convert(char(10),@now,105) -- yyyy-mm-dd
      select @todaysTime=convert(char(8),@now,108) -- HH:mm:ss
      select @crlf= char(13)+ char(10)
      -- Prepare XML file contents
      select @outstring='<?xml version="1.0"?>'+@crlf+'<NZPost xmlns="'+
        @schema+'">'+@crlf+'<Header>'+
        @crlf+'<ChannelType>RDSNPAD</ChannelType>'+
        @crlf+'<Version>0.1</Version>'+
        @crlf+'<Description>'+
        @description+'</Description>'+@crlf+'<Priority>1</Priority>'+
        @crlf+'<ProduceDate>'+
        @todaysDate+'T'+@todaysTime+'</ProduceDate>'+@crlf+'</Header>'+
        @crlf+'<RDSNPAD>'+
        @crlf+'<MasterRecipientUpdate>'+
        @crlf+'<OldDPID>'+
        @s_old_dpid+'</OldDPID>'+@crlf+'<NewDPID>'+
        @s_new_dpid+'</NewDPID>'+@crlf+'<UserID>'+
        @username+'</UserID>'+@crlf+'</MasterRecipientUpdate>'+
        @crlf+'</RDSNPAD>'+
        @crlf+'</NZPost>'

DECLARE   @object   int --create a Scripting Object for openning file
DECLARE   @hr   int  
DECLARE   @filehandle   int 
DECLARE   @src   varchar(255),   @desc   varchar(255)   

EXEC   @hr   =   sp_OACreate   'Scripting.FileSystemObject',   @object   OUT   
  IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
        --SELECT   hr=convert(varbinary(4),@hr),   Source=@src,   Description=@desc
		select @errmsg='create a Scripting Object failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   
          
  END   

EXEC @hr = sp_OAMethod @object, 'CreateTextFile', @filehandle OUTPUT , @outfile   --create a file
 IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
		select @errmsg='Create a text file failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   

  END   
 
EXEC   @hr   =   sp_OAMethod   @filehandle,   'Write',NULL,   @outstring    --write message to the file
  IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
		select @errmsg='Write a text file failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   
  END   
 
EXEC   @hr   =   sp_OAMethod   @filehandle,   'Close',NULL     --close the file
  IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
		select @errmsg='Write close a text file failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   
        select @status=-1
  END
  ELSE
     begin
        select @errmsg='New DPID = '+@s_new_dpid+'  Outfile = '+@outfile
     end

      -- Create the XML file
	  /*!
      execute @rc = xp_write_file @outfile,@outstring
      if @rc = 0
        -- If successful, "errmsg" contains details of the message
        select @errmsg='New DPID = '+@s_new_dpid+'  Outfile = '+@outfile
      else
        begin
          -- If not successful, "errmsg" contains the error code and output filename
          select @status=-1
          select @errmsg='xp_write_file failed: rc = '+convert(char(4),@rc)+'; File = '+@outfile
        end
	   */
    end
  /**************************
  *  Exit
  **************************/
  -- Log the message
  insert into NPAD_msg_log(msg_date,
    msg_username,msg_type,msg_dpid,msg_status,msg_description) values(
    @now,@username,'transfer customer',@s_old_dpid,@status,@errmsg)
  return @status
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-----------------------------------------------------------zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
--
-- Definition for stored procedure sp_cust_list_any : 
--


CREATE procedure [rd].[f_rds_npad_delete_customer](@dpid int,@username char(20),@description char(120),@outfile char(120))
as
begin
  declare @todaysDate char(10),
  @todaysTime char(8),
  @s_dpid char(8),
  @outstring varchar(2000), -- Max 32K
  @schema char(64),
  @crlf char(2),
  @status int,
  @now datetime,
  @rc int,
  @errmsg char(40)
  select @status=0
  select @schema='http://schemas.nzpost.co.nz/NPAD/v2/RDSNPAD'
  select @rc=0
  select @errmsg=''
  -- Need the date and time for the XML file
  select @now=getdate()
  -- Convert to string for the XML output file
  -- (or error message)
  select @s_dpid=convert(char(8),@dpid)
  if @dpid is null
    select @s_dpid='null'
  -- Check the DPID for validity
  if @dpid is null or @dpid <= 0
    begin
      select @status=1
      select @errmsg='Invalid DPID: '+@s_dpid
    end
  else
    begin
      -- Format the date and time for the XML file
      select @todaysDate=convert(char(10),@now,105) -- yyyy-mm-dd
      select @todaysTime=convert(char(8),@now,108) -- HH:mm:ss
      select @crlf=char(13)+char(10)
      -- Prepare the XML file contents
      select @outstring='<?xml version="1.0"?>'+@crlf+'<NZPost xmlns="'+
        @schema+'">'+@crlf+'<Header>'+
        @crlf+'<ChannelType>RDSNPAD</ChannelType>'+
        @crlf+'<Version>0.1</Version>'+
        @crlf+'<Description>'+
        @description+'</Description>'+@crlf+'<Priority>1</Priority>'+
        @crlf+'<ProduceDate>'+
        @todaysDate+'T'+@todaysTime+'</ProduceDate>'+@crlf+'</Header>'+
        @crlf+'<RDSNPAD>'+
        @crlf+'<CustomerDelete>'+
        @crlf+'<DPID>'+
        @s_dpid+'</DPID>'+@crlf+'<UserID>'+
        @username+'</UserID>'+@crlf+'</CustomerDelete>'+
        @crlf+'</RDSNPAD>'+
        @crlf+'</NZPost>'

DECLARE   @object   int --create a Scripting Object for openning file
DECLARE   @hr   int  
DECLARE   @filehandle   int 
DECLARE   @src   varchar(255),   @desc   varchar(255)   

EXEC   @hr   =   sp_OACreate   'Scripting.FileSystemObject',   @object   OUT   
  IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
        --SELECT   hr=convert(varbinary(4),@hr),   Source=@src,   Description=@desc
		select @errmsg='create a Scripting Object failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   
          
  END   

EXEC @hr = sp_OAMethod @object, 'CreateTextFile', @filehandle OUTPUT , @outfile   --create a file
 IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
		select @errmsg='Create a text file failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   

  END   
 
EXEC   @hr   =   sp_OAMethod   @filehandle,   'Write',NULL,   @outstring    --write message to the file
  IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
		select @errmsg='Write a text file failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   
  END   
 
EXEC   @hr   =   sp_OAMethod   @filehandle,   'Close',NULL     --close the file
  IF   @hr   <>   0   
  BEGIN   
        EXEC   sp_OAGetErrorInfo   @object,   @src   OUT,   @desc   OUT     
		select @errmsg='Write or close a text file failed: rc = '+convert(char(4),@hr)+ @desc +'; File = ' + @outfile   
        select @status=-1
  END
  ELSE
     begin
      select @errmsg='succeeded'
	 end


      -- Create the file
	  /*!
      execute @rc = xp_write_file @outfile,@outstring
      if @rc = 0
        -- If successful, "errmsg" says so (the details are in other the columns)
        select @errmsg='succeeded'
      else
        begin
          -- If not successful, "errmsg" contains the error code and output filename
          select @status=-1
          select @errmsg='xp_write_file failed: rc = '+convert(char(4),@rc)+'; File = '+@outfile
        end
	   */
    end
  -- Log the message
  insert into NPAD_msg_log(msg_date,
    msg_username,msg_type,msg_dpid,msg_status,msg_description) values(
    @now,@username,'delete customer',@dpid,@status,@errmsg)
  return @status
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure rds_npad_delete_address : 
--

CREATE procedure [rd].[rds_npad_delete_address](
@in_dpid int,
@in_username char(20))
/******************************************************************
* Description
*    This routine deletes an address record.  The address must not
*    be occupied (which disqualifies unnumbered addresses).
*    
* Parameters
*    dpid        - DPID of the  to be deletedaddress
*
* Returns
*    status      - A status code
*                   0 = Success
*                  >0 = Failure for various reasons (see code)
*                  -1 = SQL errors
*    description - Short description of the status
*
* System
*    NPAD2 - NZ Post
*
* Author
*    Tom Britton, Synergy International
*
* Created 
*    November 2005
*
* Modification history
* 13 Feb 2006  TJB  Added deletion of geocode entry for the address (CR13)
* xx Mar 2006  TJB  Added check for address being a termination point
* 20 Mar 2006  TJB  Fixed "dpid_id" bug
*
*****************************************************************/
as
begin
  declare @status int, -- Return status (0 = success)
  @description char(100), -- Return description (mainly error
  -- message)
  @msg char(80), -- Test message
  @found int, -- Flag indicating a database record 
  -- exists (1) or not (NULL)
  -- Sometimes used as a count.
  @adrID int, -- Old address ID
  @now datetime
  -- Need the date and time for the logged actions
  select @now=getdate()
  select @status=0
  /************************************************************
  * Check input parameters
  ***********************************************************/
  -- Check to see that the dpid is valid ...
  if @in_dpid is null or @in_dpid <= 0
    begin
      select @status=101
      select @description='DPID does not exist'
    end
  -- ... and must already exist 
  if @status = 0
    begin
      select @found=null
      select @found = count(*) from
        address where
        dp_id = @in_dpid
      if @@error <> 0
        begin
          select @status=-1
          select @description='SQL Error '+convert(char(6),@@error)+' checking the address already exists'
        end
      if @status = 0 and(@found is null or @found <> 1)
        begin
          select @status=103
          select @description='DPID does not exist or is duplicated'
        end
    end
  -- Check that the address is not occupied
  if @status = 0 and
    exists(select 1 from address join customer_address_moves on address.dp_id = customer_address_moves.dp_id where
      address.dp_id = @in_dpid and
      move_out_date is null)
    begin
      select @status=102
      select @description='Address occupied'
    end
  -- Check that the address is not a termination point
  if @status = 0 and
    exists(select 1 from route_description as rd,address where
      address.dp_id = @in_dpid and
      rd.adr_id = address.adr_id)
    begin
      select @status=121
      select @description='Address is route termination point'
    end
  /***************************************************************
  * Delete the address record
  ***************************************************************/
  if @status = 0
    begin
      delete from address where
        dp_id = @in_dpid
      if @@error <> 0
        begin
          select @status=-1
          select @description='SQL Error '+convert(char(6),@@error)+' deleting address record'
        end
      else
        select @msg='Address deleted'
      if @@error <> 0 and @@rowcount <> 0 /* was @@error <>100 */
        begin
          -- Return error if the error isn't 'not found'' (100)
          delete from address_geocode where
            adr_id = @adrID
          if @@error <> 0
            begin
              select @status=-1
              select @description='SQL Error '+convert(char(6),@@error)+' deleting address_geocode record'
            end
        end
    end
  /************************************************************
  * Done.  Return status
  ***********************************************************/
  if @status = 0
    begin
      commit transaction -- Commit the changes
      select @description='Success'+' - '+@msg
    end
  else
    rollback transaction
  -- log message
  select @msg=ltrim(rtrim(convert(char(8),@in_dpid)))
  insert into NPAD_msg_log(msg_date,
    msg_username,msg_type,msg_dpid,msg_status,msg_description) values(
    @now,@in_username,'delete address',@in_dpid,@status,@msg)
  -- Return status
  select Status=@status,Description=@description 
  return @status
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure rds_npad_delete_road : 
--

CREATE procedure [rd].[rds_npad_delete_road](@in_unique_road_id int,@in_username char(20))
/******************************************************************
* Description
*    This routine deletes an existing road.
*
* System
*    NPAD2 - NZ Post
*
* Author
*    Tom Britton, Synergy International
*
* Created on
*    November 2005
*
* Modification history
* 13Feb2006  TJB  Moved 'rollback' to end if inserts
*
*****************************************************************/
as
begin
  declare @status int,
  @description char(100),
  @msg char(80),
  @roadID int, -- RDS road_id of the road 
  @now datetime
  -- Need the date and time for the logged actions
  select @now=getdate()
  select @status=0
  /************************************************************
  * Check input parameters
  ***********************************************************/
  -- Check to see that the unique_road_id is valid ...
  if @in_unique_road_id is null or @in_unique_road_id <= 0
    begin
      select @status=101
      select @description='Unique_road_id does not exist or invalid'
    end
  -- ... and already exists
  -- Get the road_id for the road
  if @status = 0
    begin
      select @roadID=null
      select @roadID = road_id from road where
        unique_road_id = @in_unique_road_id
      if @@error <> 0 and @@rowcount <> 0 /* was @@error <>100 */
        begin
          select @status=-1
          select @description='SQL Error '+convert(char(6),@@error)+' getting RDS road_id'
          rollback transaction
        end
      else
      if @roadID is null
        begin
          select @status=101
          select @description='Unique_road_id does not exist or invalid'
        end
    end
  -- Check to see if there are any addresses on the road
  if @status = 0 and
    exists(select 1 from address where
      road_id = @roadID)
    begin
      select @status=102
      select @description='Street has at least one address'
    end
  /************************************************************
  * Delete the road
  ***********************************************************/
  if @status = 0
    begin
      delete from road_suburb where
        road_id = @roadID
      if @@error <> 0 and @@rowcount <> 0 /* was @@error <>100 */
        begin
          select @status=-1
          select @description='SQL Error '+convert(char(6),@@error)+' deleting road from road_suburb table'
        end
      if @status = 0
        begin
          delete from town_road where
            road_id = @roadID
          if @@error <> 0 and @@rowcount <> 0 /* was @@error <>100 */
            begin
              select @status=-1
              select @description='SQL Error '+convert(char(6),@@error)+' deleting road from town_road table'
            end
        end
      if @status = 0
        begin
          delete from road where
            road_id = @roadID
          if @@error <> 0 and @@rowcount <> 0 /* was @@error <>100 */
            begin
              select @status=-1
              select @description='SQL Error '+convert(char(6),@@error)+' deleting road from road table'
            end
        end
    end
  /************************************************************
  * Done.  Return status
  ***********************************************************/
  if @status = 0
    begin
      commit transaction -- Commit the changes
      select @description='Success'
    end
  else
    rollback transaction
  -- log message
  select @msg=ltrim(rtrim(convert(char(8),@in_unique_road_id)))
  insert into NPAD_msg_log(msg_date,
    msg_username,msg_type,msg_dpid,msg_status,msg_description) values(
    @now,@in_username,'delete road',null,@status,@msg)
  -- Return status
  select Status=@status,
    Description=@description 
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_Extension_DaysPerAnnum](@inContract int,@inKey int)
as
begin
  select rate_days.rtd_days_per_annum from
    contract join
    contract_renewals as cr on
    contract.contract_no = cr.contract_no and
    contract.con_active_sequence = cr.contract_seq_number
	 join
    rate_days on
    cr.con_rg_code_at_renewal = rate_days.rg_code and
    cr.con_rates_effective_date = rate_days.rr_rates_effective_date and
    rate_days.sf_key = @inKey where
    contract.contract_no = @inContract
end




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractPieceRatesODPS : 
--

--
-- Definition for stored procedure sp_GetContractPieceRatesODPS : 
--

CREATE procedure [rd].[sp_GetContractPieceRatesODPS](@in_Contract int,@in_RetrieveType char(1),@in_DateStart datetime,@in_DateEnd datetime)
as
begin
  declare @maxratedate datetime,
  @maxdeldate datetime
  if @in_RetrieveType = 'A'
    begin
      select @maxdeldate=max(piece_rate_delivery.prd_paid_to_date)
        from piece_rate_delivery where
        piece_rate_delivery.contract_no = @in_Contract
      select @maxratedate=max(pr.pr_effective_date) 
        from piece_rate as pr,
        contract where
        pr.pr_effective_date <= @maxdeldate and
        pr.rg_code = contract.rg_code and
        contract.contract_no = @in_Contract
      select piece_rate_delivery.prd_date,
        piece_rate_type.prs_key,
        piece_rate_quantity=sum(piece_rate_delivery.prd_quantity),
        piece_rate_cost=sum(piece_rate_delivery.prd_cost),
        paid_to_date=prd_paid_to_date from
        piece_rate,
        piece_rate_type,
        piece_rate_delivery,
        contract where
        piece_rate.prt_key = piece_rate_delivery.prt_key and
        piece_rate_type.prt_key = piece_rate.prt_key and
        contract.contract_no = piece_rate_delivery.contract_no and
        piece_rate.rg_code = contract.rg_code and
        piece_rate_delivery.contract_no = @in_Contract and
        piece_rate.pr_effective_date = @maxratedate
        group by piece_rate_delivery.prd_date,
        piece_rate_type.prs_key,
        prd_paid_to_date order by
        piece_rate_delivery.prd_date desc,
        piece_rate_type.prs_key asc
    end
  else
    begin
      select @maxdeldate=max(piece_rate_delivery.prd_paid_to_date) 
        from piece_rate_delivery where
        piece_rate_delivery.contract_no = @in_Contract and
        piece_rate_delivery.prd_date <= @in_DateEnd
      select @maxratedate=max(pr.pr_effective_date)  
        from piece_rate as pr,
        contract where
        pr.pr_effective_date <= @maxdeldate and
        pr.rg_code = contract.rg_code and
        contract.contract_no = @in_Contract
      select piece_rate_delivery.prd_date,
        piece_rate_type.prs_key,
        piece_rate_quantity=sum(piece_rate_delivery.prd_quantity),
        piece_rate_cost=sum(piece_rate_delivery.prd_cost),
        paid_to_date=prd_paid_to_date from
        piece_rate,
        piece_rate_type,
        piece_rate_delivery,
        contract where
        piece_rate.prt_key = piece_rate_delivery.prt_key and
        piece_rate_type.prt_key = piece_rate.prt_key and
        contract.contract_no = piece_rate_delivery.contract_no and
        piece_rate.rg_code = contract.rg_code and
        piece_rate_delivery.contract_no = @in_Contract and
        piece_rate.pr_effective_date = @maxratedate and
        piece_rate_delivery.prd_date between @in_DateStart and @in_DateEnd
        group by piece_rate_delivery.prd_date,
        piece_rate_type.prs_key,
        prd_paid_to_date order by
        piece_rate_delivery.prd_date desc,
        piece_rate_type.prs_key asc
    end
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_GetContractPieceRates](@in_Contract int,@in_RetrieveType char(1),@in_DateStart datetime,@in_DateEnd datetime)
as
begin
  select piece_rate_delivery.prd_date,
    piece_rate_type.prs_key,
    piece_rate_quantity=sum(piece_rate_delivery.prd_quantity),
    piece_rate_cost=sum(piece_rate_delivery.prd_cost) from
    piece_rate join piece_rate_type  on piece_rate.prt_key=piece_rate_type.prt_key
	 join piece_rate_delivery  on piece_rate_type.prt_key=piece_rate_delivery.prt_key
		join contract on contract.contract_no=piece_rate_delivery.contract_no where
    piece_rate.rg_code = contract.rg_code and
    piece_rate_delivery.contract_no = @in_Contract and
    (@in_RetrieveType = 'A' or piece_rate_delivery.prd_date between @in_DateStart and @in_DateEnd) and
    piece_rate.pr_effective_date = 
    (select max(pr.pr_effective_date) from
      piece_rate as pr where
      pr.prt_key = piece_rate.prt_key and
      pr.pr_effective_date <= piece_rate_delivery.prd_date and
      pr.rg_code = contract.rg_code)
    group by piece_rate_delivery.prd_date,
    piece_rate_type.prs_key order by piece_rate_delivery.prd_date desc,
    piece_rate_type.prs_key asc
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_GetPieceRateBreakDown](
@in_Contract int,
@in_Supplier int,
@in_Date datetime)
as
begin
  select (piece_rate_type.prt_code + ' (' + piece_rate_type.prt_description + ')') as piece_rate_description,
    piece_rate_delivery.prd_cost,
    piece_rate_delivery.prd_quantity 
  from
    piece_rate join piece_rate_type on piece_rate.prt_key=piece_rate_type.prt_key
		join piece_rate_delivery on piece_rate_type.prt_key=piece_rate_delivery.prt_key
		 join contract on piece_rate_delivery.contract_no=contract.contract_no where
    piece_rate.rg_code = contract.rg_code and
    piece_rate_delivery.prd_date = @in_Date and
    piece_rate_type.prs_key = @in_Supplier and
    piece_rate_delivery.contract_no = @in_Contract and
    piece_rate.pr_effective_date = 
    (select max(pr.pr_effective_date) from
      piece_rate as pr where
      pr.prt_key = piece_rate.prt_key and
      pr.pr_effective_date <= @in_Date and
      pr.rg_code = contract.rg_code) order by piece_rate_description asc
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_CreateTFC : 
--

CREATE procedure [rd].[sp_CreateTFC] as
begin
  insert into types_for_contract(contract_no,
    ct_key)
    select contract.contract_no,
      isnull(contract.con_base_cont_type,0) from
      rd.contract where
      0 = (select count(*) from
        rd.types_for_contract as tfc where
        (tfc.ct_key = contract.con_base_cont_type) and
        (tfc.contract_no = contract.contract_no))
end








SET ANSI_NULLS ON




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRenewalInfo : 
--

CREATE procedure [rd].[sp_GetRenewalInfo](
@in_ContractNo int,
@in_ContractSeq int)
as
begin
  select contract_renewals.contract_no,
    contract_renewals.contract_seq_number,
    contract.con_title,
    contract_renewals.con_start_date,
    contract_renewals.con_rates_effective_date,
    contract_renewals.con_rg_code_at_renewal,
    contract_renewals.con_expiry_date,
    contract_renewals.con_start_pay_date,
    contract_renewals.con_last_paid_date,
    contract_renewals.con_processing_hours_per_week,
    round(contract_renewals.con_renewal_benchmark_price,0),
    round(contract_renewals.con_renewal_payment_value,2),
    contract_renewals.con_relief_driver_name,
    contract_renewals.con_relief_driver_address,
    contract_renewals.con_relief_driver_home_phone,
    contract_renewals.con_date_last_assigned,
    contract_renewals.con_acceptance_flag,
    contract_renewals.con_volume_at_renewal,
    contract_renewals.con_del_hrs_week_at_renewal,
    contract_renewals.con_distance_at_renewal,
    contract_renewals.con_no_customers_at_renewal,
    contract_renewals.con_no_rural_private_bags_at_renewal,
    contract_renewals.con_no_other_bags_at_renewal,
    contract_renewals.con_no_private_bags_at_renewal,
    contract_renewals.con_no_post_offices_at_renewal,
    contract_renewals.con_no_cmbs_at_renewal,
    contract_renewals.con_no_cmb_custs_at_renewal from
    contract_renewals join contract on contract_renewals.contract_no=contract.contract_no where
    (contract_renewals.contract_no = @in_ContractNo) and
    (contract_renewals.contract_seq_number = @in_ContractSeq)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetConVehConsumptionRate : 
--

CREATE function [rd].[f_GetConVehConsumptionRate](@incontractNo int,@inSequenceNo int,@inVehicleNo int)
returns numeric(12,2)
-- TJB SR4633 14-Oct-2004  - New
-- Get fuel consumption rate for a specific vehicle in a contract 
-- Used to get the consumption rate for the previous vehicle in a contract 
-- when a new vehicle has been added and a frequency adjustment may 
-- need to be created.
as -- Based on f_getConsumptionRates.
begin
  declare @vn_ConsumptionRate numeric(12,2)
  select @vn_ConsumptionRate = fuel_rates.fr_fuel_consumtion_rate
    from fuel_type,
    fuel_rates,
    contract_vehical,
    vehicle,
    contract,
    contract_renewals where
    contract_vehical.contract_no = @inContractNo and
    contract_vehical.contract_seq_number = @inSequenceNo and
    contract_vehical.vehicle_number = @inVehicleNo and
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    fuel_type.ft_key = vehicle.ft_key and
    fuel_rates.ft_key = fuel_type.ft_key and
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    fuel_rates.rr_rates_effective_date = contract_renewals.con_rates_effective_date and
    contract.contract_no = contract_renewals.contract_no and
    fuel_rates.rg_code = contract.rg_code
  return @vn_ConsumptionRate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetConVehFuelRate : 
--

CREATE function [rd].[f_GetConVehFuelRate](@inContractNo int,@inSequenceNo int,@inVehicleNo int)
returns numeric(12,2)
-- TJB SR4633 14-Oct-2004 
-- Get fuel rate for a specific vehicle in a contract 
-- Used to get the fuel rate for the previous vehicle in a contract 
-- when a new vehicle has been added and a frequency adjustment may 
-- need to be created.
as -- Based on f_getFuelRate.
begin
  declare @vn_fuelrate numeric(12,2)
  select @vn_fuelrate = fuel_rates.fr_fuel_rate
    from fuel_type,
    fuel_rates,
    contract_vehical,
    vehicle,
    contract,
    contract_renewals where
    contract_vehical.contract_no = @inContractNo and
    contract_vehical.contract_seq_number = @inSequenceNo and
    contract_vehical.vehicle_number = @inVehicleNo and
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    fuel_type.ft_key = vehicle.ft_key and
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract.contract_no = contract_renewals.contract_no and
    fuel_rates.rr_rates_effective_date = contract_renewals.con_rates_effective_date and
    fuel_rates.ft_key = fuel_type.ft_key and
    fuel_rates.rg_code = contract.rg_code
  return @vn_fuelrate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_GL_Interface_for_AccrualsSummary : 
--

CREATE procedure [odps].[OD_RPS_GL_Interface_for_AccrualsSummary](@ProcDate datetime)
as
begin
  -- TJB  SR4684  June-2006
  -- (reformatted for ledgibility)
  -- Apr05 MRB 
  -- Changed accrual ratio from 0.3548387 (11/31sts) to 0.3333333 (10/30ths)
  -- and removed absolute values as incorectly adding negative allowances.
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from sql code.
  -- Used the corresponding payment_component_type.prs_key instead (same as used in
  -- OD_RPS_GL_Interface_for_Accruals stored procedure) for consistency.
  select pbu_code=pbu_code.pbu_code,
    account_number=account_codes.ac_code,
    transaction_amount=sum(pc_amount)*.3333333333333,description='RD Accruals - Contract Price',drcr='D',
    trans=0,
    trans2=0 from
    rd.contract,
    payment,
    payment_component,
    payment_component_group,
    payment_component_type,
    account_codes,
    pbu_code where
    contract.contract_no = payment.contract_no and
    payment_component.invoice_id = payment.invoice_id and
    payment_component_type.pcg_id = payment_component_group.pcg_id and
    payment_component_type.pct_id = payment_component.pct_id and
    pbu_code.pbu_id = contract.pbu_id and
    account_codes.ac_id = payment_component_type.ac_id and
    -- and ( (payment_component_group.pcg_short_code = 'GP'
    --        or payment_component_group.pcg_short_code ='OGP')
    --      and payment_component_type.pct_id <> 4)
    payment_component_group.pcg_short_code in('GP','OGP') and
    payment_component_type.pct_id <> 4 and
    payment_component_type.prs_key is null and
    -- and (payment_component_type.pct_description not like 'Kiwimail%'
    --      and payment_component_type.pct_description not like 'CourierPos%'
    --      and payment_component_type.pct_description not like 'XP%')
    payment.invoice_date = @procdate
    group by pbu_code.pbu_code,
    account_codes.ac_code
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_getConNumbers : 
--

--
-- Definition for stored procedure sp_getConNumbers : 
--

CREATE procedure -- TWC -- 15/08/2003
-- This procedure will return all contract numbers of contracts that have not expired.
[rd].[sp_getConNumbers]
as
begin
  select distinct contract_no,con_title from
    contract as con where
    con.con_date_terminated is null and
    contract_no > 0 order by
    contract_no asc,con_title asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for user-defined function f_GetContractNo : 
--

CREATE function [rd].[f_GetContractNo](@ai_cust_id int)
returns char(300)
as
begin
  declare @sret varchar(100),
  @stemp1 varchar(100),
  @stemp2 varchar(100)
  declare contract_no cursor for select contract.contract_no,
      contract.con_title from
      rds_customer,
      customer_address_moves,
      address,
      contract where
      (customer_address_moves.cust_id = rds_customer.cust_id) and
      (customer_address_moves.move_out_date is null) and
      (address.adr_id = customer_address_moves.adr_id) and
      (contract.contract_no = address.contract_no) and
      ((rds_customer.master_cust_id is null) and
      (rds_customer.cust_id = @ai_cust_id))
  open contract_no
  fetch next from contract_no into @stemp1,@stemp2
  select @sret='('+@stemp1+')'+' '+@stemp2
  close contract_no
  return(@sret)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function GetPRSupplierVolumes : 
--

CREATE function [rd].[GetPRSupplierVolumes](@inRegion int,@inSupplier int,@inFromDate datetime,@inToDate datetime)
returns int
as
begin
  declare @iVolume int
  select @iVolume = sum(piece_rate_delivery.prd_quantity) 
    from piece_rate_delivery join
    contract on
    piece_rate_delivery.contract_no = contract.contract_no and
    piece_rate_delivery.prd_date between @inFromDate and @inToDate join
    piece_rate_type on
    piece_rate_delivery.prt_key = piece_rate_type.prt_key and
    piece_rate_type.prs_key = @inSupplier
  return @iVolume
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetCurrentrenewal : 
--

--
-- Definition for stored procedure sp_GetCurrentrenewal : 
--

CREATE procedure [rd].[sp_GetCurrentrenewal](@inContract int)
as
begin
  -- PBY 24/06/2002 SR#4411
  -- changed con_active_sequence > (select max... to 
  -- con_active_sequence < (select max...
  select cnt=count(*) from
    contract where
    contract.contract_no = @inContract and
    (contract.con_active_sequence is null or
    contract.con_active_sequence < (select max(contract_seq_number) from
      contract_renewals where
      contract_renewals.contract_no = contract.contract_no))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_RenewalGroupList : 
--

CREATE procedure [rd].[sp_DDDW_RenewalGroupList]
as
begin
  select rg_code,rg_description from renewal_group
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_DDDW_RenewalGroups : 
--

CREATE procedure [rd].[sp_DDDW_RenewalGroups]
as
begin
  select rg_code,rg_description from renewal_group union
  select-1,'<All Renewal Groups>'  order by
    2 asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO





--
-- Definition for user-defined function OD_BLF_Mainrun_Checkrun : 
--

CREATE function  [odps].[OD_BLF_Mainrun_Checkrun](@inContract_No int,@inContractor_no int,@inPayPeriod_Start datetime,@inPayPeriod_End datetime)
returns int
as
begin
 
  declare @v_temp_int int
  declare @v_temp_int2 int
  if @inContract_no > 0
    select @v_temp_int = count(*) 
    from odps.payment where
      (invoice_date between @inPayPeriod_Start and @inPayPeriod_End) and
      (contract_no = @inContract_no) and
      (contractor_supplier_no = @inContractor_no) and
      POTS = 'N'
  else
    select @v_temp_int = count(payment_runs.pr_id) 
    from odps.payment_runs where
      (cast((cast(payment_runs.pr_date as varchar)) as datetime) between @inPayPeriod_Start and @inPayPeriod_End ) and
      (payment_runs.pr_contract_no = @inContract_no) and
      POTS = 'N'
  return(@v_temp_int)
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_GetContractFixedAssets](@in_Contract int)
as
begin
  select cfa.contract_no,
    cfa.fa_fixed_asset_no,
    fa.fat_id,
    fa.fa_owner,
    fa.fa_purchase_date,
    fa.fa_purchase_price from
    contract_fixed_assets as cfa join fixed_asset_register as fa on cfa.fa_fixed_asset_no=fa.fa_fixed_asset_no where
    cfa.contract_no = @in_Contract
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_CheckRates : 
--

--
-- Definition for user-defined function f_CheckRates : 
--

CREATE function [rd].[f_CheckRates](@inRGCode int,@inEffDate datetime)
returns int
as
begin
  declare @ll_Count integer,
  @ll_NumVehicleTypes integer,
  @ll_NumVehicleTypesFilled integer
  --Check fuel rates
  select @ll_Count=count(*)
    from fuel_type,
    fuel_rates where
    fuel_type.ft_key = fuel_rates.ft_key and
    fuel_rates.rr_rates_effective_date = @inEffDate and
    fuel_rates.rg_code = @inRGCode and
    (fuel_rates.fr_fuel_rate is null or fuel_rates.fr_fuel_consumtion_rate is null)
  if @ll_Count > 0
    return 0
  --check rate days
  select @ll_Count = count(*)
    from standard_frequency,
    rate_days where
    standard_frequency.sf_key = rate_days.sf_key and
    rate_days.rr_rates_effective_date = @inEffDate and
    rate_days.rg_code = @inRGCode and
    rate_days.rtd_days_per_annum is null
  if @ll_Count > 0
    return 0
  --
  select @ll_Count=count(*)
    from piece_rate where
    piece_rate.pr_effective_date = @inEffDate and
    piece_rate.rg_code = @inRGCode and
    pr_active_status = 'Y' and
    pr_rate is null
  if @ll_Count > 0
    return 0
  --Count vehicle types
  select @ll_NumVehicleTypes = count(*) 
    from vehicle_type
  --Count vehicle types already entered
  select @ll_NumVehicleTypesFilled = count(vehicle_rate.vt_key) 
    from vehicle_rate where
    vehicle_rate.vr_rates_effective_date = @inEffDate and
    vehicle_rate.vr_nominal_vehicle_value is not null and
    vehicle_rate.vr_repairs_maintenance_rate is not null and
    vehicle_rate.vr_tyre_tubes_rate is not null and
    vehicle_rate.vr_vehicle_allowance_rate is not null and
    vehicle_rate.vr_licence_rate is not null and
    vehicle_rate.vr_vehicle_rate_of_return_pct is not null and
    vehicle_rate.vr_salvage_ratio is not null and
    vehicle_rate.vr_ruc is not null and
    vehicle_rate.vr_sundries_k is not null and
    vehicle_rate.vr_vehicle_value_insurance_pct is not null
  if(@ll_NumVehicleTypesFilled is null or @ll_NumVehicleTypesFilled < @ll_NumVehicleTypes)
    return 0
  return 1
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_InitFuelRates : 
--

CREATE procedure [rd].[sp_InitFuelRates](@in_RenewalGroup int,@in_Date datetime) as
begin
  declare @dMaxDate datetime,
  @dMaxRgCode integer
  select @dMaxDate=max(rr_rates_effective_date) 
    from fuel_rates
  select @dMaxRgCode=max(rg_code) 
    from fuel_rates where
    rr_rates_effective_date = @dMaxDate
  insert into fuel_rates
    select fuel_type.ft_key,
      @in_RenewalGroup,
      @in_Date,
      fuel_rates.fr_fuel_rate,
      fuel_rates.fr_fuel_consumtion_rate from
      fuel_type join fuel_rates on fuel_type.ft_key=fuel_rates.ft_key where
      fuel_rates.rg_code = @dMaxRgCode and
      fuel_rates.rr_rates_effective_date = @dMaxDate and
      not fuel_type.ft_key = any(select ft_key from
        fuel_rates as fr where
        fr.ft_key = fuel_type.ft_key and
        fr.rg_code = @in_RenewalGroup and
        fr.rr_rates_effective_date = @in_Date)
  insert into fuel_rates
    select fuel_type.ft_key,
      @in_RenewalGroup,
      @in_Date,
      0,
      0 from
      fuel_type where
      not fuel_type.ft_key = any(select ft_key from
        fuel_rates as fr where
        fr.ft_key = fuel_type.ft_key and
        fr.rg_code = @in_RenewalGroup and
        fr.rr_rates_effective_date = @in_Date)
  commit transaction
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetFuelRates : 
--

--
-- Definition for stored procedure sp_GetFuelRates : 
--

CREATE procedure [rd].[sp_GetFuelRates](@in_Date datetime)
as
begin
  select fuel_type.ft_key,
    fuel_rates.rg_code,
    fuel_rates.rr_rates_effective_date,
    fuel_rates.fr_fuel_rate,
    fuel_rates.fr_fuel_consumtion_rate,
    fuel_type.ft_description from
    fuel_type left outer join
    fuel_rates on
    (fuel_type.ft_key = fuel_rates.ft_key and
    fuel_rates.rr_rates_effective_date = @in_Date)
--and fuel_rates.rg_code=in_RenewalGroup
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetFuelRates2001 : 
--

--
-- Definition for stored procedure sp_GetFuelRates2001 : 
--

CREATE procedure [rd].[sp_GetFuelRates2001](@inRgCode int,@in_Date datetime)
as
begin
  select fuel_type.ft_key,
    fuel_rates.rg_code,
    fuel_rates.rr_rates_effective_date,
    fuel_rates.fr_fuel_rate,
    fuel_rates.fr_fuel_consumtion_rate,
    fuel_type.ft_description from
    fuel_type left outer join
    fuel_rates on
    (fuel_type.ft_key = fuel_rates.ft_key and
    fuel_rates.rr_rates_effective_date = @in_Date) and
    fuel_rates.rg_code = @inRgCode
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Vehicle : 
--

CREATE procedure [rd].[sp_Vehicle](@inContract int,@inSequence int)
as
begin
  select make=vehicle.v_vehicle_make,
    model=vehicle.v_vehicle_model,
    modelyear=vehicle.v_vehicle_year,
    odometer=conv.start_kms,
    cc_rating=vehicle.v_vehicle_cc_rating,
    reg_number=vehicle.v_vehicle_registration_number,
    date_purchased=vehicle.v_purchased_date,
    ruc=vehicle.v_road_user_charges_indicator,
    Purchase_value=vehicle.v_purchase_value,
    fuel_type.ft_description,
    vehicle_type.vt_description from
    contract_renewals as conr join
    contract_vehical as conv on conr.contract_no = conv.contract_no and
    conr.contract_seq_number = conv.contract_seq_number and
    conv.cv_vehical_status = 'A'
    join
    vehicle on
    conv.vehicle_number = vehicle.vehicle_number
    left outer join
    fuel_type on
    fuel_type.ft_key = vehicle.ft_key
	left outer join
    vehicle_type on
    vehicle.vt_key = vehicle_type.vt_key where
    conr.contract_no = @inContract and
    conr.contract_seq_number = @inSequence
end














	
  


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractorDS : 
--

--
-- Definition for stored procedure sp_GetContractorDS : 
--

CREATE procedure [rd].[sp_GetContractorDS](@in_Contractor int)
as
begin
  select contractor_supplier_no,
    cd_old_ds_no from
    contractor_ds where
    contractor_supplier_no = @in_Contractor order by
    cd_old_ds_no asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Get_vehicle_override_rates : 
--

CREATE procedure [rd].[sp_Get_vehicle_override_rates](@incontract_no int,@incontract_seq_no int) as
begin
  select top 1 vehicle_override_rate.contract_no,
    vehicle_override_rate.contract_seq_number,
    vehicle_override_rate.vor_nominal_vehicle_value,
    vehicle_override_rate.vor_repairs_maintenance_rate,
    vehicle_override_rate.vor_tyre_tubes_rate,
    vehicle_override_rate.vor_vehical_allowance_rate,
    vehicle_override_rate.vor_licence_rate,
    vehicle_override_rate.vor_vehicle_rate_of_return_pct,
    vehicle_override_rate.vor_salvage_ratio,
    vehicle_override_rate.vor_ruc,
    vehicle_override_rate.vor_sundries_k,
    vehicle_override_rate.vor_vehicle_insurance_premium,
    vehicle_override_rate.vor_fuel_rate,
    vehicle_override_rate.vor_consumption_rate,
    vehicle_override_rate.vor_livery,
    vehicle_override_rate.vor_effective_date from
    vehicle_override_rate where
    (vehicle_override_rate.contract_no = @incontract_no) and
    (vehicle_override_rate.contract_seq_number = @incontract_seq_no) order by
    vehicle_override_rate.vor_effective_date desc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetLatestVehicle : 
--

--
-- Definition for user-defined function f_GetLatestVehicle : 
--

CREATE function [rd].[f_GetLatestVehicle](@in_contractNo int,@inSequenceNo int)
returns int
as
begin
  declare @vn_vehicle_number int
  select @vn_vehicle_number=vehicle.vehicle_number 
    from contract_vehical,
    vehicle where
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    contract_vehical.contract_no = @in_contractNo and
    contract_vehical.contract_seq_number = @inSequenceNo and
    isnull(vehicle.v_purchased_date,getdate()-10000) = 
    (select max(isnull(v.v_purchased_date,getdate()-10000)) from
      contract_vehical as cv,
      vehicle as v where
      v.vehicle_number = cv.vehicle_number and
      cv.contract_no = @in_contractNo and
      cv.contract_seq_number = @inSequenceNo)
  return @vn_vehicle_number
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_VehicleAgingDetails : 
--

CREATE procedure [rd].[sp_VehicleAgingDetails](@inContract int,@inSequence int,@inVehicleNo int)
as
begin
  select contract_vehical.start_kms,
    vehicle.v_vehicle_make,
    vehicle.v_vehicle_model,
    vehicle.v_vehicle_year,
    vehicle.v_vehicle_registration_number,
    vehicle.v_purchased_date,
    contract_vehical.contract_no,
    contract_vehical.contract_seq_number,
    contract_vehical.vehicle_number,
    contract_vehical.cv_vehical_status,
    PurchaseStatus=(select(case when year(v_purchased_date) = v_vehicle_year or start_kms <= 1000 then 'New' else 'Used' end) ),
    con_expiry_date=(select con_expiry_date from contract_renewals where contract_no = @inContract and contract_seq_number = @inSequence),
    con_distance_at_renewal=(select con_distance_at_renewal from contract_renewals where contract_no = @inContract and contract_seq_number = @inSequence),
    con_start_date=(select con_start_date from contract_renewals where contract_no = @inContract and contract_seq_number = @inSequence) from
    contract_vehical,
    vehicle where
    (vehicle.vehicle_number = contract_vehical.vehicle_number) and
    ((contract_vehical.contract_no = @inContract) and
    (contract_vehical.contract_seq_number = @inSequence) and
    (contract_vehical.vehicle_number = @inVehicleNo))
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetLatestConVehicle : 
--

CREATE function [rd].[f_GetLatestConVehicle](@in_contractNo int)
returns int
as
begin
  declare @vn_vehicle_number int
  select @vn_vehicle_number=max(cv.vehicle_number) 
    from contract_vehical as cv where
    cv.contract_no = @in_contractNo and
    cv.contract_seq_number = (select max(contract_seq_number) from
      contract_vehical as cv1 where
      cv1.contract_no = @in_contractNo)
  return @vn_vehicle_number
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_GetRenewalGroupRatev3 : 
--

CREATE procedure [rd].[sp_GetRenewalGroupRatev3](
@inRGCode int,
@in_EffectDate datetime)
as
begin
  select rg_code,
    rr_rates_effective_date,
    rr_nominal_vehical_value,
    rr_wage_hourly_rate,
    rr_repairs_maintenance_rate,
    rr_tyre_tubes_rate,
    rr_vehical_allowance_rate,
    rr_vehical_insurance_premium,
    rr_public_liability_rate,
    rr_carrier_risk_rate,
    rr_acc_rate,
    rr_licence_rate,
    rr_vehical_rate_of_return_pct,
    rr_salvage_ratio,
    rr_item_proc_rate_per_hr,
    rr_frozen_indicator,
    rr_contract_start,
    rr_contract_end,
    rr_ruc,rr_accounting,rr_telephone,rr_sundries,rr_sundries_k from
    renewal_rate where
    rg_code = @inRgCode and rr_rates_effective_date = @in_EffectDate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRenewalRatesWithDate : 
--

CREATE procedure [rd].[sp_GetRenewalRatesWithDate](
@inRGCode int,
@inEffectDate datetime)
as
begin
  select renewal_rate.rg_code,renewal_rate.rr_rates_effective_date,renewal_rate.rr_nominal_vehical_value,
    renewal_rate.rr_wage_hourly_rate,
    renewal_rate.rr_repairs_maintenance_rate,
    renewal_rate.rr_tyre_tubes_rate,
    renewal_rate.rr_vehical_allowance_rate,
    renewal_rate.rr_vehical_insurance_premium,
    renewal_rate.rr_public_liability_rate,
    renewal_rate.rr_carrier_risk_rate,
    renewal_rate.rr_acc_rate,
    renewal_rate.rr_licence_rate,
    renewal_rate.rr_vehical_rate_of_return_pct,renewal_rate.rr_salvage_ratio,renewal_rate.rr_item_proc_rate_per_hr,
    renewal_rate.rr_frozen_indicator,
    renewal_rate.rr_contract_start,
    renewal_rate.rr_contract_end,
    renewal_rate.rr_ruc,renewal_rate.rr_accounting,renewal_rate.rr_telephone,renewal_rate.rr_sundries from
    renewal_rate where
    rg_code = @inRGCode and
    rr_rates_effective_date = @inEffectDate order by
    rr_rates_effective_date desc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRenewalGroupRate : 
--

CREATE procedure [rd].[sp_GetRenewalGroupRate](
@inRGCode int,@in_EffectDate datetime)
as
begin
  select rg_code,
    rr_rates_effective_date,
    rr_nominal_vehical_value,
    rr_wage_hourly_rate,
    rr_repairs_maintenance_rate,
    rr_tyre_tubes_rate,
    rr_vehical_allowance_rate,
    rr_vehical_insurance_premium,
    rr_public_liability_rate,
    rr_carrier_risk_rate,
    rr_acc_rate,
    rr_licence_rate,
    rr_vehical_rate_of_return_pct,
    rr_salvage_ratio,
    rr_item_proc_rate_per_hr,
    rr_frozen_indicator,
    rr_contract_start,
    rr_contract_end from
    renewal_rate where
    rg_code = @inRgCode and rr_rates_effective_date = @in_EffectDate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_GetRenewalGroupRatev2 : 
--

CREATE procedure [rd].[sp_GetRenewalGroupRatev2](
@inRGCode int,
@in_EffectDate datetime)
as
begin
  select rg_code,
    rr_rates_effective_date,
    rr_nominal_vehical_value,
    rr_wage_hourly_rate,
    rr_repairs_maintenance_rate,
    rr_tyre_tubes_rate,
    rr_vehical_allowance_rate,
    rr_vehical_insurance_premium,
    rr_public_liability_rate,
    rr_carrier_risk_rate,
    rr_acc_rate,
    rr_licence_rate,
    rr_vehical_rate_of_return_pct,
    rr_salvage_ratio,
    rr_item_proc_rate_per_hr,
    rr_frozen_indicator,
    rr_contract_start,
    rr_contract_end,
    rr_ruc,rr_accounting,rr_telephone,rr_sundries from
    renewal_rate where
    rg_code = @inRgCode and rr_rates_effective_date = @in_EffectDate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [rd].[sp_GetRenewalRates]
as
begin
  select rg_code,
    rr_rates_effective_date,
    rr_frozen_indicator from
    renewal_rate order by
    rr_rates_effective_date desc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRoadTownMap : 
--

--
-- Definition for stored procedure sp_GetRoadTownMap : 
--

CREATE procedure [rd].[sp_GetRoadTownMap] as
begin
  select road.road_id,
    road.rt_id,
    town_road.tc_id from
    road,
    town_road where
    (town_road.road_id = road.road_id)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRoadMap_v2 : 
--

CREATE procedure [rd].[sp_GetRoadMap_v2]
-- TJB  Sept 2005  NPAD2 address schema changes
-- Add rs_id and rs_name to returned values
-- TJB  Mar 2006   NPAD2
as -- Add mailtown ID to returned columns
begin
  select road.road_id,
    road.rt_id,
    road.road_name,
    road_type.rt_name,
    road.rs_id,
    road_suffix.rs_name,
    town_road.tc_id 
  from
    road left outer join road_type on road.rt_id=road_type.rt_id 
    left outer join road_suffix on road.rs_id=road_suffix.rs_id join
    town_road  on road.road_id=town_road.road_id where
    town_road.road_id = road.road_id 
order by  road.road_name asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE function [rd].[f_validate_road](@in_roadname char(50),@in_rtid int,@in_rsid int,@in_slname char(50),@in_tcid int)
returns int 
-- TJB  NPAD2  May 2006   - New -
-- Validate the address
-- Return
--   >0     road_id of existing road
--   -1     road doesn''t already exist
--   -2     road doesn''t exist in the mailtown
--   -3     road doesn''t exist in the suburb
as --   -4     suburb doesn''t exist in the mailtown
begin
  declare @roadid int,
  @slid int,
  @temp int
  -- First, determine the suburb ID, if a suburb name is specified.
  -- There are possibly multiple suburbs with the same name, but only
  -- one suburb with a given name in a mailtown.  Its an error if 
  -- the specified suburb doesn''t exist in the specified mailtown.
  if @in_slname is null or @in_slname = ''
    select @slid=0
  else
    select @slid = s.sl_id from
      town_suburb as ts join suburblocality as s on ts.sl_id = s.sl_id where
      ts.tc_id = @in_tcid and
      s.sl_name = @in_slname order by
      s.sl_id asc
  if @slid is null
    return-4 -- Suburb doesn''t exist in the town
  -- Check to see if the road exists in the mailtown and suburb
  if @slid = 0
    select @roadid = road.road_id from
      road join town_road as tr on road.road_id = tr.road_id where
      road_name = @in_roadname and
      tr.tc_id = @in_tcid and
      isnull(@in_rtid,0) = isnull(rt_id,0) and
      isnull(@in_rsid,0) = isnull(rs_id,0)
  else
    select @roadid = road.road_id from
      road join town_road as tr on road.road_id = tr.road_id
	 join road_suburb as rs on road.road_id = rs.road_id where
      road.road_name = @in_roadname and
      road.road_name = @in_roadname and
      tr.tc_id = @in_tcid and
      rs.sl_id = @slid and
      isnull(@in_rtid,0) = isnull(road.rt_id,0) and
      isnull(@in_rsid,0) = isnull(road.rs_id,0)
  if @roadid is not null and @roadid > 0
    return @roadid -- The road exists in the town and suburb
  -- Check to see if a road of the specified name/type/suffix exists
  select @roadid = road_id from
    road where
    road_name = @in_roadname and
    isnull(@in_rtid,0) = isnull(rt_id,0) and
    isnull(@in_rsid,0) = isnull(rs_id,0) order by
    road_id asc
  if @roadid is null or @roadid <= 0
    return-1 -- These''s no road by that name
  -- At this point, if a suburb wasn''t specified, we know that
  -- the road exists, but doesn''t exist in the mailtown (otherwise 
  -- the initial lookup of the road_id would have succeeded).
  if @slid = 0
    return-2 -- Road doesn''t exist in the town
  -- If a suburb was specified, it could be either the road/town or 
  -- road/suburb that doesn't exist.  We'll check for the road/suburb.
  if not exists(select 1 from road join road_suburb on road.road_id = road_suburb.road_id where
      road_name = @in_roadname and
      isnull(@in_rtid,0) = isnull(rt_id,0) and
      isnull(@in_rsid,0) = isnull(rs_id,0) and
      road_suburb.sl_id = @slid)
    return-3 -- Road doesn''t exist in the suburb
  else
    return-2 -- Road doesn''t exist in the town
return 0
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRoadTownMap_V2 : 
--

--
-- Definition for stored procedure sp_GetRoadTownMap_V2 : 
--

CREATE procedure [rd].[sp_GetRoadTownMap_V2]
-- TJB  Mar 2006   NPAD2
as -- Add road_name and rs_id to returned columns
begin
  select road.road_id,
    road.rt_id,
    town_road.tc_id,
    road.road_name,
    road.rs_id from
    road,
    town_road where
    town_road.road_id = road.road_id
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetMiscRate : 
--

CREATE procedure [rd].[sp_GetMiscRate](
@in_RgCode int,
@in_EffectDate datetime)
as
begin
  select misc_rate.rg_code,
    misc_rate.mr_effective_date,
    misc_rate.mr_name,
    misc_rate.mr_value,
    misc_rate.mr_km_flag,
    misc_rate.mr_annual_flag from
    misc_rate where
    (misc_rate.rg_code = @in_RgCode) and
    (misc_rate.mr_effective_date = @in_EffectDate)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_GetRoadSuburbMap]
-- TJB  Sept 2005  NPAD2 address schema changes
as -- Added road_suffix to road_type returned
begin
  select r1.road_id,
    r1.rt_id,
    r1.road_name,
    road_type.rt_name+case when road_suffix.rs_name is null then null else ' '+road_suffix.rs_name end ,
    suburblocality.sl_id,
    suburblocality.sl_name from
/*    road as r1 join road_type on r1.rt_id=road_type.rt_id,
    road as r2 left outer join road_suffix on r2.rs_id=road_suffix.rs_id,
    road as r3 join road_suburb on r3.road_id=road_suburb.road_id,
    road_suburb as rs join suburblocality on rs.sl_id=suburblocality.sl_id*/
	road as r1 join road_type on r1.rt_id=road_type.rt_id
		left outer join road_suffix on r1.rs_id=road_suffix.rs_id
		 join road_suburb on r1.road_id=road_suburb.road_id
		 join suburblocality on road_suburb.sl_id=suburblocality.sl_id
--   where road_type.rt_id = road.rt_id
--     and road_suburb.sl_id = suburblocality.sl_id
--     and road_suburb.road_id = road.road_id
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_GetRoadSuburbMap_v2]
-- TJB  Sept 2005  NPAD2 address schema changes
as -- Added road_suffix and road_type returned
begin
  select r1.road_id,
    r1.road_name,
    r1.rt_id,
    road_type.rt_name,
    road_suffix.rs_id,
    road_suffix.rs_name,
    suburblocality.sl_id,
    suburblocality.sl_name from
    /*road as r1 join road_type on r1.rt_id=road_type.rt_id,
    road as r2 left outer join road_suffix on r2.rs_id=road_suffix.rs_id,
    road as r3 join road_suburb  on r3.road_id=road_suburb.road_id,
    road_suburb as rs join suburblocality on rs.sl_id=suburblocality.sl_id*/
	road as r1 join road_type on r1.rt_id=road_type.rt_id
		left outer join road_suffix on r1.rs_id=road_suffix.rs_id
		left outer join road_suburb as rs on r1.road_id=rs.road_id
		left outer join suburblocality on rs.sl_id=suburblocality.sl_id
--   where road_type.rt_id = road.rt_id
--     and road_suburb.sl_id = suburblocality.sl_id
--     and road_suburb.road_id = road.road_id
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetBenchmarkRptVehicleStdRates2001 : 
--

--
-- Definition for stored procedure sp_GetBenchmarkRptVehicleStdRates2001 : 
--

CREATE procedure [rd].[sp_GetBenchmarkRptVehicleStdRates2001]
as
begin
  select vt_description as VehicleType,'Net Vehicle Value ($)' as Formula,vr_nominal_vehicle_value as Value from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key union
  select vt_description,'Rep Maint Rate ($/1000k)',vr_repairs_maintenance_rate from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key union
  select vt_description,'Tyres ($/1000k)',vr_tyre_tubes_rate from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key union
  select vt_description,'Vehicle Allowance ($/1000k)',vr_vehicle_allowance_rate from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key union
  select vt_description,'Relicensing ($ pa)',vr_licence_rate from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key union
  select vt_description,'Vehicle Rate Of Return (%)',vr_vehicle_rate_of_return_pct from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key union
  select vt_description,'Salvage Ratio (%)',vr_salvage_ratio from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key union
  select vt_description,'Road User Charges ($/1000k)',vr_ruc from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key union
  select vt_description,'Rep Maint Rate ($/1000k)',vr_sundries_k from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key union
  select vt_description,'Sundries ($/1000k)',vr_vehicle_value_insurance_pct from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key union
  select vt_description,'Rep Maint Rate ($/1000k)',vr_livery from vehicle_rate,vehicle_type where vehicle_type.vt_key = vehicle_rate.vt_key
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetNonVehicleRenewalRates : 
--

CREATE procedure [rd].[sp_GetNonVehicleRenewalRates](
@inRGCode int,
@in_EffectDate datetime)
-- TJB  SR4661  May2005
as -- Added delivery and processing wage rates
begin
  select rg_code,
    nvr_rates_effective_date,
    nvr_wage_hourly_rate,
    nvr_vehicle_insurance_base_premium,
    nvr_public_liability_rate,
    nvr_carrier_risk_rate,
    nvr_acc_rate,
    nvr_item_proc_rate_per_hr,
    nvr_frozen_indicator,
    nvr_contract_start,
    nvr_contract_end,
    nvr_accounting,
    nvr_telephone,
    nvr_sundries,
    nvr_acc_rate_amount,
    nvr_uniform,
    nvr_delivery_wage_rate,
    nvr_processing_wage_rate from
    non_vehicle_rate where
    (rg_code = @inRGCode or @inRGCode is null) and
    nvr_rates_effective_date = @in_EffectDate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetNonVehicleRenewaRate : 
--

CREATE procedure [rd].[sp_GetNonVehicleRenewaRate](
@inRGCode int,
@in_EffectDate datetime)
as
begin
  select non_vehicle_rate.rg_code,
    non_vehicle_rate.nvr_rates_effective_date,
    non_vehicle_rate.nvr_wage_hourly_rate,
    non_vehicle_rate.nvr_vehicle_insurance_base_premium,
    non_vehicle_rate.nvr_public_liability_rate,
    non_vehicle_rate.nvr_carrier_risk_rate,
    non_vehicle_rate.nvr_acc_rate,
    non_vehicle_rate.nvr_item_proc_rate_per_hr,
    non_vehicle_rate.nvr_frozen_indicator,
    non_vehicle_rate.nvr_contract_start,
    non_vehicle_rate.nvr_contract_end,
    non_vehicle_rate.nvr_accounting,
    non_vehicle_rate.nvr_telephone,
    non_vehicle_rate.nvr_sundries,
    non_vehicle_rate.nvr_acc_rate_amount,
    non_vehicle_rate.nvr_uniform from
    non_vehicle_rate where
    (non_vehicle_rate.rg_code = @inRGCode or @inRGCode is null) and
    (non_vehicle_rate.nvr_rates_effective_date = @in_EffectDate)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRenewalArtCnts : 
--

CREATE procedure [rd].[sp_GetRenewalArtCnts](
@in_Contract int,
@in_Sequence int)
as
begin
  select artical_count.contract_no,
    artical_count.contract_seq_number,
    artical_count.ac_start_week_period,
    artical_count.ac_w1_medium_letters,
    artical_count.ac_w1_other_envelopes,
    artical_count.ac_w1_small_parcels,
    artical_count.ac_w1_large_parcels,
    artical_count.ac_w1_inward_mail,
    artical_count.ac_w2_medium_letters,
    artical_count.ac_w2_other_envelopes,
    artical_count.ac_w2_small_parcels,
    artical_count.ac_w2_large_parcels,
    artical_count.ac_w2_inward_mail,
    artical_count.ac_scale_factor,
    (select max(address.adr_rd_no) from
      address where
      address.contract_no = @in_Contract) from
    artical_count where
    artical_count.contract_no = @in_Contract and
    artical_count.contract_seq_number = @in_Sequence order by
    artical_count.ac_start_week_period asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--THE EVALUATION VERSION TRIMS COLUMN NAMES AND VARIABLES TO 7 CHARACTERS
--
CREATE function [rd].[f_GetCustomerKiwimailCount](@in_Con INT ,@in_typ CHAR(1))
RETURNS INT
-- TJB  SR4659  July 2005
-- Add count for CMB customers.  Count 1 Kiwimail for each
-- customer (surname and/or initials not null or empty).
   AS
begin
   declare @iCount INT
   if @in_typ = 'R'
   begin
      select   @iCount = sum(rd.rds_customer.cust_adpost_quantity) 
      from rd.address,
      rd.customer_address_moves,
      rd.rds_customer where(rd.customer_address_moves.adr_id = rd.address.adr_id) and(rd.rds_customer.cust_id = rd.customer_address_moves.cust_id) and
      rd.rds_customer.master_cust_id is null and
      rd.customer_address_moves.move_out_date is null and((rd.address.contract_no = @in_Con) and(rd.rds_customer.cust_rural_resident = 'Y'))
   end
   else
   begin
      if @in_typ = 'B'
      begin
         select   @iCount = sum(rd.rds_customer.cust_adpost_quantity) 
         from rd.address,
      rd.customer_address_moves,
      rd.rds_customer where(rd.customer_address_moves.adr_id = rd.address.adr_id) and(rd.rds_customer.cust_id = rd.customer_address_moves.cust_id) and
         rd.rds_customer.master_cust_id is null and
         rd.customer_address_moves.move_out_date is null and((rd.address.contract_no = @in_Con) and(rd.rds_customer.cust_business = 'Y'))
      end
      else
      begin
         if @in_typ = 'F'
         begin
            select   @iCount = sum(rd.rds_customer.cust_adpost_quantity) 
            from rd.address,
      rd.customer_address_moves,
      rd.rds_customer where(rd.customer_address_moves.adr_id = rd.address.adr_id) and(rd.rds_customer.cust_id = rd.customer_address_moves.cust_id) and
            rd.rds_customer.master_cust_id is null and
            rd.customer_address_moves.move_out_date is null and((rd.address.contract_no = @in_Con) and(rd.rds_customer.cust_rural_farmer = 'Y'))
         end
         else
         begin
            if @in_typ = 'X'
            begin
               select   @iCount = Count(rd.rds_customer.cust_id) 
               from rd.address,
      rd.customer_address_moves,
      rd.rds_customer where(rd.customer_address_moves.adr_id = rd.address.adr_id) and(rd.rds_customer.cust_id = rd.customer_address_moves.cust_id) and(rd.rds_customer.master_cust_id is null) and
               rd.rds_customer.master_cust_id is null and
               rd.customer_address_moves.move_out_date is null and((rd.address.contract_no = @in_Con) and(cust_adpost_quantity is null or cust_adpost_quantity = 0))
            end
            else
            begin
               if @in_typ = 'C'
               begin
                  select   @iCount = Count(cmb_id) 
                  from rd.cmb_address where
                  contract_no = @in_Con and((cmb_cust_surname is not null and cmb_cust_surname <> '') or(cmb_cust_initials is not null and cmb_cust_initials <> ''))
               end
               else
               begin
                  set @iCount = 0
               end
            end
         end
      end
   end
   return @iCount
end







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure temp_AddressMerge : 
--

CREATE procedure [rd].[temp_AddressMerge] as
begin
   /*declare
  Watcom only
  err_notfound exception for sqlstate value '02000'
  */
  declare cur_dupAddress cursor for select Id=adr1.adr_id,
      SortField=convert(varchar,adr1.contract_no)+'@'+convert(varchar,adr1.tc_id)+'@'+convert(varchar,adr1.adr_rd_no)+'@'+convert(varchar,adr1.road_id)+'@'+rd.trim(IsNULL(adr1.adr_no,''))+rd.trim(IsNULL(adr1.adr_alpha,'')) from
      address as adr1 where
      0 < (select COUNT(adr2.adr_id) from
        address as adr2 where
        adr1.adr_id <> adr2.adr_id and
        adr1.tc_id = adr2.tc_id and
        adr1.adr_rd_no = adr2.adr_rd_no and
        adr1.road_id = adr2.road_id and
        (rd.trim(IsNULL(adr1.adr_no,''))+rd.trim(IsNULL(adr1.adr_alpha,''))) = (rd.trim(IsNULL(adr2.adr_no,''))+rd.trim(IsNULL(adr2.adr_alpha,''))) and
        rd.trim(IsNULL(adr1.adr_no,''))+rd.trim(IsNULL(adr1.adr_alpha,'')) <> '' and
        adr1.contract_no = adr2.contract_no) order by
      SortField asc,
      Id asc
  declare @primaryAdrId integer,
  @currentAdrId integer,
  @primaryDupTag varchar(255),
  @currentDupTag varchar(255)
  select @primaryAdrId=0
  select @currentAdrId=0
  select @primaryDupTag=''
  select @currentDupTag=''
  open cur_dupAddress
  /* Watcom only
  DupLoop:
  */while 1=1 
    begin
      fetch next from cur_dupAddress into @currentAdrId,@currentDupTag
      if @@fetch_status <0
        break
        /* Watcom only
        DupLoop
        */
      if @primaryDupTag <> @currentDupTag
        begin
          -- this is a different set of addresses
          select @primaryAdrId=@currentAdrId
          select @primaryDupTag=@currentDupTag
        end
      else
        begin
          -- this is a duplicated address
          -- move the customers into the primary address
          insert into customer_address_moves(adr_id,
            cust_id,
            move_in_date)
            select @primaryAdrId,
              cust_id,
              getdate() from
              customer_address_moves where
              adr_id = @currentAdrId and
              move_out_date is null
          -- delete the duplicated address
          delete from address where
            adr_id = @currentAdrId
        end
    end
  close cur_dupAddress
  commit transaction
end
--EXEC temp_AddressMerge









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_cust_list_any]
-- TJB  SR4683  Aug 2006
-- Change customer category counts to use the Kiwimail number at an address
--
-- TJB  Oct 2005
-- Changed: add road_unit and road_alpha as separate returned values and removed from road_no;
--          pad road_no, road_unit with spaces for sorting
--
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added adr_unit number and road_suffix to relevant parts of address returned
as --
begin
  declare
  /* Watcom only
  err_notfound exception for sqlstate value '02000'
  ,*/
  -- TJB : no longer used
  --  declare rec_tmp char(200);
  --  declare cust_tmp integer;
  --  declare master_tmp char(200);
  @cust_count integer,
  @address_count integer,
  @blank_space char(20)
  -- first create a temporary table for recipients at an address
create table #master_temp(
    master_num integer null,
    recip_char char(200) null,
    ) 
  -- TJB: no longer used
  -- declare local temporary table master_temp1
  --               (master_num integer, recip_char char(200));     
  create table #recipient_temp(
    recip_num integer null,
    recip_char_b char(200) null,
    ) 
  -- TJB Sept 2005  Replaced the cursor - see below
  --  declare recipient_list dynamic scroll cursor for 
  --            select recip.recip_num, recip.recip_char_b
  --              from recipient_temp recip;
  --
  --  declare iRecip_num  integer;
  --  declare cRecip_char char(200);
  --  declare cAdd        char(200);
  --  insert into master_temp1 (master_num)
  --         select top 3000 cust.cust_id 
  -- get all master cust_id''s first
  -- TJB Jan 2005: Changed to select distinct customer numbers as one step
  -- TJB SR4644 Jan 2005: Increased limit on number of customers retrieved
  insert into #master_temp(master_num)
    select top 4000 cust.cust_id from
      rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id where
      cam.move_out_date is null and
      cust.master_cust_id is null
  -- get distinct list of customers       
  -- insert into master_temp (master_num)
  --        select distinct(tmp1.master_num)
  --          from master_temp1 tmp1;
  -- get all recipients names
  insert into #recipient_temp(recip_num,recip_char_b)
    select cust.master_cust_id,', '+
      rd.trim(isnull(cust.cust_surname_company,'')+' '+isnull(cust.cust_initials,'')) from
      rds_customer as cust,
      #master_temp as mast where
      cust.master_cust_id = mast.master_num and
      (cust.cust_surname_company is not null or cust.cust_initials is not null) and
      (len(cust.cust_surname_company) > 0 or len(cust.cust_initials) > 0)
  -- TJB Sept 2005 
  -- Add recipients to master list
  -- This replaces the cursor and speeds the procedure up considerably!
  update #master_temp set
    #master_temp.recip_char = #master_temp.recip_char+#recipient_temp.recip_char_b from
    #recipient_temp where
    #master_temp.master_num = #recipient_temp.recip_num
  ------------ cursor attempt
  --  open recipient_list;
  --  CursorLoop: loop
  --      set iRecip_num=0;
  --      set cRecip_char='';
  --      set cAdd = '';  
  --    
  --      fetch next recipient_list into iRecip_num, cRecip_char;
  --      if sqlstate=err_notfound then
  --        leave CursorLoop
  --      end if;
  --    
  --      -- get original char value
  --      select mast.recip_char 
  --        into cAdd     
  --        from master_temp mast
  --       where mast.master_num = iRecip_num;
  --    
  --      set cAdd = cAdd + cRecip_char;
  --    
  --      -- do update to master_temp
  --      update master_temp
  --         set master_temp.recip_char = cAdd
  --       where master_temp.master_num = iRecip_num;
  --    
  --  end loop CursorLoop;
  --  close recipient_list;
  -- get count of customers
  --select count(master_temp.master_num) 
  --into cust_count
  --from master_temp;
  --if cust_count > 1000 then
  --set cust_count = 1000;
  --end if;
  select @cust_count = count(cust.cust_id)
    from rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id where
    cam.move_out_date is null and
    cust.master_cust_id is null
  select @address_count = count(*)
    from address
  -- 20 blank spaces
  select @blank_space=space(20)
  -- main select for the procedure
  -- TJB  SR4683  Aug 2006
  -- Changed the category counts to equal the Kiwimail count, instead of 1
  --
  -- TJB SR4644 Jan 2005: Increase limit on number of customers retrieved
  --
  select top 2000
    seq_no=@address_count,
    sur_comp_name=cust.cust_surname_company,
    initials=cust.cust_initials,
    prop_title=addr.adr_property_identification,
    --substring(blank_space, 1 , (19 - length(ifnull(addr.adr_unit,'',addr.adr_unit+'/')+addr.adr_no+trim(addr.adr_alpha)))) 
    --  + ifnull(addr.adr_unit,'',addr.adr_unit+'/')+upper(addr.adr_no+trim(addr.adr_alpha))  as road_no,
    road_no=right(space(20)+rd.trim(addr.adr_no),20),
    road_name=rd.road_name+
    --ifnull(rt.rt_name,'',' '+rt.rt_name)+
    case when isnull(rt.rt_name,'') = '' then '' else ' '+rt.rt_name end + 
    --ifnull(rs.rs_name,'',' '+rs.rs_name),
    case when isnull(rs.rs_name,'') = '' then '' else ' '+rs.rs_name end,
    locality=sub.sl_name,
    rd_no=addr.adr_rd_no,
    mail_town=tc.tc_name,
    recipients=substring(mast.recip_char,3,len(mast.recip_char)-2),
    categories=(case when cust.cust_business = 'Y' then 'Business' else
      case when cust.cust_rural_farmer = 'Y' then 'Farmer' else
        case when cust.cust_rural_resident = 'Y' then 'Residential'
        end
      end
    end),kiwimail_qty=cust.cust_adpost_quantity,
    business=(case when cust.cust_business = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
    residential=(case when cust.cust_rural_resident = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
    farmer=(case when cust.cust_rural_farmer = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
    cust_counter=@cust_count,
    road_alpha=upper(rd.trim(addr.adr_alpha)),
    road_unit=right(space(10)+addr.adr_unit,10) from
    rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id,
    address as addr left outer join suburblocality as sub on addr.sl_id = sub.sl_id
    left outer join towncity as tc on addr.tc_id = tc.tc_id
    left outer join road as rd on addr.road_id = rd.road_id
    left outer join road_type as rt on rd.rt_id = rt.rt_id
    left outer join road_suffix as rs on rd.rs_id = rs.rs_id,
    #master_temp as mast where
    mast.master_num = cust.cust_id and
    cust.master_cust_id is null and
    cust.master_cust_id is null and
    addr.adr_id = cam.adr_id
--  and addr.adr_alpha is null
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure  [rd].[sp_GetRouteDescription_2002](@inContract int,@inSFKey int,@inDelDays char(7))
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added adr_unit number and road_suffix to relevant parts of address returned
as -- Also added adr_alpha (missing) and fixed spacing on address
begin
  -- PBY 16/10/2002 SR#4462 Terminal points disappeared once you make any changes through the Route Description tab page.
  -- This problem is caused by adr_id not being passed back to the datawindow properly.
  -- PBY 24/07/2002 SR#4437 Address not displayed correctly
  select sf_key,
    contract_no,
    rd_sequence,
    rf_delivery_days,
    rd_description_of_point=left(case when adr_id is null then rd_description_of_point else 
    (select case when addr.adr_unit is null then '' else addr.adr_unit+'/' end+
      ISNULL(addr.adr_no,'')+ISNULL(addr.adr_alpha,'')+
      case when addr.adr_unit+addr.adr_no+addr.adr_alpha is null then '' else ' ' end +
      ISNULL(rd2.Road_name,'')+
      case  when rt.rt_name is null then '' else ' '+rt.rt_name end +
      case  when rs.rs_name is null then '' else ' '+rs.rs_name end  from
      address as addr left outer join road as rd2 on addr.road_id=rd2.road_id
      left outer join road_type as rt on rd2.rt_id=rt.rt_id
      left outer join road_suffix as rs on rd2.rs_id=rs.rs_id where
      addr.adr_id = route_description.adr_id) end ,
    40),
    --PBY 24/07/2002 Commented Out
    --"left"(ifnull(adr_id,rd_description_of_point,(select a.adr_no+' '+r.Road_name+' '+rt.rt_name from Address as a,Road as r,road_type as rt where a.road_id = r.road_id and r.rt_id = rt.rt_id and a.adr_id = route_description.adr_id)),40) as rd_description_of_point,
    rd_time_at_point,
    rfv_id,
    rfpd_id,
    rfpt_description=(select left(rfpt_description,40) from
      route_freq_point_type where
      route_freq_point_type.rfpt_id = route_description.rfpd_id),
    rf_distance_of_leg,
    rf_running_total,
    rfv_id_2,
    cust_id,
    0,
    0,
    Adr_id from
    route_description where
    contract_no = @inContract and
    sf_key = @inSFKey and
    rf_delivery_days = @inDelDays order by
    rd_sequence asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date, ,>
-- Description:	<Description, ,>
-- =============================================
CREATE function [rd].[f_getFrequency](@address_id int,@pi_contract_no int,@ps_terminal char(1))

RETURNS char(8)
AS
BEGIN
  /* If contract number is passed in,
  we are trying to find the frequencies for terminal points */
  declare @lv_Result varchar(8)
  declare @lv_freq char(7)
  declare @lv_temp varchar(7)
  declare @li_x int
  declare @li_total int
  declare @ls_terminal char(1)
  declare c1  cursor for select rf_delivery_days from
      route_description where
      adr_id = @address_id and
      contract_no = @pi_contract_no and
      @ps_terminal = 'Y' union
    select address_frequency_sequence.rf_delivery_days from
      address_frequency_sequence,
      address,
      route_frequency where
      address.adr_id = address_frequency_sequence.adr_id and
      address_frequency_sequence.sf_key = route_frequency.sf_key and
      address_frequency_sequence.rf_delivery_days = route_frequency.rf_delivery_days and
      address_frequency_sequence.contract_no = route_frequency.contract_no and
      route_frequency.rf_active = 'Y' and
      address.adr_id = @address_id and
      @ps_terminal <> 'Y'
  select @lv_result=''
  select @lv_temp=''
  select @lv_freq=''
  open c1
  if @@error <> 0 /* <> was < */
    begin
      --select ''
      return ''
    end
  /* Watcom only
  MAINLOOP:
  */while 1=1 
    begin
      fetch next from c1 into @lv_freq
      if @@FETCH_STATUS = -2
        begin
          --select ''
          return ''
        end
      if @@FETCH_STATUS = -1

        break
        /* Watcom only
        MAINLOOP
        */
      select @lv_freq=rd.TRIM(@lv_freq)
      select @li_x=1
      if @lv_result = ''
        select @lv_result=@lv_freq
      else
        begin
          select @lv_temp=''
          while @li_x <= len(@lv_freq)
            begin
              if substring(@lv_freq,@li_x,1) = 'Y' or substring(@lv_result,@li_x,1) = 'Y'
                if @li_x = 1
                  select @lv_temp='Y'
                else
                  select @lv_temp=(@lv_temp+'Y')
              else
                if @li_x = 1
                  select @lv_temp='N'
                else
                  select @lv_temp=(@lv_temp+'N')
              select @li_x=@li_x+1
            end
          select @lv_result=@lv_temp
        end
    end
  close c1
  DEALLOCATE c1
  -- work out total number of 'Y's anda append this information at the end of the string
  select @li_x=1
  select @li_total=0
  while @li_x <= len(@lv_result)
    begin
      if substring(@lv_result,@li_x,1) = 'Y'
        select @li_total=@li_total+1
      select @li_x=@li_x+1
    end
  --select @lv_result+CAST(@li_total AS VARCHAR)
  return @lv_result+CAST(@li_total AS VARCHAR)
END







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetDeliveryDays : 
--

CREATE function [rd].[f_GetDeliveryDays](@ai_cust_id int)
returns char(7)
as
begin
  declare @sret char(7),
  @stemp1 char(7)
  /*declare Delivery_days  cursor for select address_frequency_sequence.rf_delivery_days from
      address,
      address_frequency_sequence,
      customer_address_moves,
      rds_customer where
      (address_frequency_sequence.adr_id = address.adr_id) and
      (customer_address_moves.adr_id = address.adr_id) and
      (rds_customer.cust_id = customer_address_moves.cust_id) and
      ((rds_customer.master_cust_id is null) and
      (rds_customer.cust_id = @ai_cust_id))
  open Delivery_days
  fetch next from Delivery_days into @stemp1
  select @sret=isnull(@stemp1,'NNNNNNN')
  close Delivery_days*/
select top 1 @stemp1=address_frequency_sequence.rf_delivery_days from
      address,
      address_frequency_sequence,
      customer_address_moves,
      rds_customer where
      (address_frequency_sequence.adr_id = address.adr_id) and
      (customer_address_moves.adr_id = address.adr_id) and
      (rds_customer.cust_id = customer_address_moves.cust_id) and
      ((rds_customer.master_cust_id is null) and
      (rds_customer.cust_id = @ai_cust_id))
  select @sret=isnull(@stemp1,'NNNNNNN')

  return(@sret)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_summary_cust_list_seq](@in_contract_no int,@in_sf_key int,@in_rd_del_days char(7),@in_sortorder char(1))
-- TJB  SR4664  July 2005  - new
-- Replaces the select in r_summary_customer_listing datawindow
-- Dropped use of v_customers view (huge performance improvement)
-- and added union to append unsequenced customers.
-- This is one of three: this one lists the sequenced customers.
-- The others are:
--          sp_summary_cust_list_hdr
--          sp_summary_cust_list_unseq
-----------------------------------------------------------------
-- TJB  Sept 2005  NPAD2 Address schema changes
-- Added adr_unit and road_suffix to addresses
-----------------------------------------------------------------
-- TJB Release 6.8.9 fixup  Nov 2005
-- Added sort order parameter.  Made redundant with
as -- sp_summary_cust_list_cust.
begin
  select afs_seq_num=address_frequency_sequence.seq_num,
    adr_no=case when address.adr_unit is null then '' else address.adr_unit+'/' end+address.adr_no,
    road_name=road.road_name,
    rt_name=road_type.rt_name+case when road_suffix.rs_name is null then '' else ' '+road_suffix.rs_name end,
    sl_name=suburblocality.sl_name,
    cust_title=rds_customer.cust_title,
    cust_surname_company=rds_customer.cust_surname_company,
    cust_initials=rds_customer.cust_initials,
    adr_alpha=address.adr_alpha,
    adr_id=address.adr_id from
    address as addr1 left outer join road on addr1.road_id=road.road_id left outer join
    road_type on road.rt_id=road_type.rt_id left outer join
    road_suffix on road.rs_id=road_suffix.rs_id,
    address as addr2 left outer join suburblocality on
    suburblocality.sl_id = addr2.sl_id,
    address left outer join(
    customer_address_moves join rds_customer on
    customer_address_moves.cust_id = rds_customer.cust_id and
    customer_address_moves.move_out_date is null and
    rds_customer.master_cust_id is null) on
    address.adr_id = customer_address_moves.adr_id,
    address_frequency_sequence where
    address.contract_no = @in_contract_no and
    address_frequency_sequence.adr_id = address.adr_id and
    address_frequency_sequence.sf_key = @in_sf_key and
    address_frequency_sequence.rf_delivery_days = @in_rd_del_days order by
    afs_seq_num asc
end






GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_summary_cust_list_cust](@in_contract_no int,@in_sf_key int,@in_rd_del_days char(7),@in_sortorder char(1))
-- TJB Release 6.8.9 fixup  Nov 2005  NEW
-- Sort sequenced and unsequenced by customer, with no-customer addresses last
-- Use '99999' as sequence number for unsequenced (data window strips these values)
-- and 'ZZZZZ' for customer surname and initials where there''s no customer (again
-- the datawindow strips these values out), so the sorting works.
-- Note: the sortorder parameter is no longer used.
-- see 
--      sp_summary_cust_list
--      sp_summary_cust_list_hdr
--      sp_summary_cust_list_seq
as --      sp_summary_cust_list_unseq
begin
  select afs_seq_num=address_frequency_sequence.seq_num,
    adr_num=case when addr1.adr_unit is null then '' else addr1.adr_unit+'/' end +addr1.adr_no,
    road_name=road.road_name,
    rt_name=road_type.rt_name+case when road_suffix.rs_name is null then '' else ' '+road_suffix.rs_name end,
    sl_name=suburblocality.sl_name,
    cust_title=rds_customer.cust_title,
    cust_surname_company=case  when rds_customer.cust_surname_company is null then 'ZZZZZ' else rds_customer.cust_surname_company end,
    cust_initials=rds_customer.cust_initials,
    adr_alpha=addr1.adr_alpha,
    adr_id=addr1.adr_id from
    address as addr1 left outer join road on addr1.road_id=road.road_id left outer join 
    road_type on road_type.rt_id=road.rt_id left outer join 
    road_suffix on road.rs_id=road_suffix.rs_id,
    address as addr2 left outer join suburblocality on
    suburblocality.sl_id = addr2.sl_id,
    address as addr3 left outer join(
    customer_address_moves join rds_customer on
    customer_address_moves.cust_id = rds_customer.cust_id and
    customer_address_moves.move_out_date is null and
    rds_customer.master_cust_id is null) on
    addr3.adr_id = customer_address_moves.adr_id,
    address_frequency_sequence where
    addr1.contract_no = @in_contract_no and
    address_frequency_sequence.adr_id = addr1.adr_id and
    address_frequency_sequence.sf_key = @in_sf_key and
    address_frequency_sequence.rf_delivery_days = @in_rd_del_days 
union
  select afs_seq_num=99999,
    adr_num=case when addr4.adr_unit is null then '' else addr4.adr_unit+'/' end +addr4.adr_no,
    road_name=road.road_name,
    rt_name=road_type.rt_name+case when road_suffix.rs_name is null then '' else ' '+road_suffix.rs_name end,
    sl_name=suburblocality.sl_name,
    cust_title=rds_customer.cust_title,
    cust_surname_company=case when rds_customer.cust_surname_company is null then 'ZZZZZ' else rds_customer.cust_surname_company end,
    cust_initials=rds_customer.cust_initials,
    adr_alpha=addr4.adr_alpha,
    adr_id=addr4.adr_id from
    address as addr4 left outer join address_frequency_sequence on
    address_frequency_sequence.adr_id = addr4.adr_id,
    address as addr5 left outer join road on addr5.road_id=road.road_id left outer join
    road_type on road.rt_id=road_type.rt_id left outer join
    road_suffix on road.rs_id=road_suffix.rs_id,
    address addr6 left outer join suburblocality on
    suburblocality.sl_id = addr6.sl_id,
    address as addr7 left outer join(
    customer_address_moves join rds_customer on
    customer_address_moves.cust_id = rds_customer.cust_id and
    customer_address_moves.move_out_date is null and
    rds_customer.master_cust_id is null) on
    addr7.adr_id = customer_address_moves.adr_id where
    addr4.contract_no = @in_contract_no and
    address_frequency_sequence.adr_id is null order by
    cust_surname_company asc,cust_initials asc,afs_seq_num asc,road_name asc,rt_name asc,sl_name asc,adr_num asc


end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_summary_cust_list_unseq](@in_contract_no int,@in_sf_key int,@in_rd_del_days char(7),@in_sortorder char(1))
-- TJB  SR4664  July 2005  - new
-- Replaces the select in r_summary_customer_listing datawindow
-- Dropped use of v_customers view (huge performance improvement)
-- and added union to append unsequenced customers.
-- This is one of three: this one lists the unsequenced customers.
-- The others are:
--          sp_summary_cust_list_hdr
--          sp_summary_cust_list_seq
----------------------------------------------------------------
-- TJB  Sept 2005  NPAD2 Address schema changes
-- Added adr_unit and road_suffix to addresses
-----------------------------------------------------------------
-- TJB Release 6.8.9 fixup  Nov 2005
-- Added sort order parameter.  Made redundant with
as -- sp_summary_cust_list_cust.
begin
  select afs_seq_num=99999,
    adr_num=case when address.adr_unit is null then '' else address.adr_unit+'/' end+address.adr_no,
    road_name=road.road_name,
    rt_name=road_type.rt_name+case  when road_suffix.rs_name is null then '' else ' '+road_suffix.rs_name end,
    sl_name=suburblocality.sl_name,
    cust_title=rds_customer.cust_title,
    cust_surname_company=rds_customer.cust_surname_company,
    cust_initials=rds_customer.cust_initials,
    adr_alpha=address.adr_alpha,
    adr_id=address.adr_id from
    address left outer join address_frequency_sequence on
    address_frequency_sequence.adr_id = address.adr_id,
    address as  addr1 left outer join road on addr1.road_id=road.road_id  left outer join
    road_type on road.rt_id=road_type.rt_id left outer join
    road_suffix on road.rs_id=road_suffix.rs_id,
    address as  addr2 left outer join suburblocality on
    suburblocality.sl_id = addr2.sl_id,
    address as addr3 left outer join(
    customer_address_moves join rds_customer on
    customer_address_moves.cust_id = rds_customer.cust_id and
    customer_address_moves.move_out_date is null and
    rds_customer.master_cust_id is null) on
    addr3.adr_id = customer_address_moves.adr_id where
    addr3.contract_no = @in_contract_no and
    address_frequency_sequence.adr_id is null order by
    road_name asc,rt_name asc,sl_name asc,address.adr_no asc,address.adr_alpha asc,address.adr_unit asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRoadMap : 
--

CREATE procedure [rd].[sp_GetRoadMap]
-- TJB  Sept 2005  NPAD2 address schema changes
as -- Add rs_id and rs_name to returned values
begin
  select road.road_id,road.rt_id, road.road_name,road_type.rt_name,
    road.rs_id, road_suffix.rs_name 
  from  road left outer join road_type on road.rt_id=road_type.rt_id left outer join road_suffix 
        on road.rs_id=road_suffix.rs_id
  --order by road.road_name asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_piecerate : 
--

CREATE function [rd].[f_piecerate](@contract int,@mo int,@yr int,@prsk int)
returns decimal
as
begin
  declare @decAmount decimal
  select @decAmount=sum(isnull(prd_quantity,0)) 
    from piece_rate_delivery,
    piece_rate_supplier,
    piece_rate_type where
    @mo < 13 and
    piece_rate_type.prs_key = piece_rate_supplier.prs_key and
    piece_rate_supplier.prs_key = @prsk and
    piece_rate_delivery.prt_key = piece_rate_type.prt_key and
    (month(piece_rate_delivery.prd_date) = @mo and year(piece_rate_delivery.prd_date) = @yr) and
    ((piece_rate_delivery.contract_no = @contract and @contract <> -1) or
    (@contract = -1))
  if @decamount > 0
    return(@decamount)
  select @decAmount=sum(isnull(prd_quantity,0))+isnull(@decAmount,0)
    from piece_rate_delivery,
    piece_rate_supplier,
    piece_rate_type where
    @mo > 12 and
    piece_rate_type.prs_key = piece_rate_supplier.prs_key and
    piece_rate_supplier.prs_key = @prsk and
    piece_rate_delivery.prt_key = piece_rate_type.prt_key and
    (month(piece_rate_delivery.prd_date) = (@mo-12) and year(piece_rate_delivery.prd_date) = @yr+1) and
    ((piece_rate_delivery.contract_no = @contract and @contract <> -1) or
    (@contract = -1))
  return(@decAmount)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_estParcelPostValue : 
--

--
-- Definition for user-defined function f_estParcelPostValue : 
--

CREATE function [rd].[f_estParcelPostValue](@inContract int,@inSequence int,@inRGcode int,@inYearStart datetime,@inMonthEnd datetime,@inRenewalEnd datetime,@inRenewalStart datetime)
returns decimal(12,2)
-- TJB  SR4684  June 2006    -- New --
-- Calculate an estimated Parcel Post value for a current contract
-- using the PP1 rate and the Large Parcel volume.
-- TJB  SR4684 Fixup July 2006
-- Changed parameter list (inRGcode, inRenewalEnd) and value selection
-- TJB  SR4684 Fixup August 2006
as -- Changed 'PP1"" to 'PP4''
begin
  declare @iTotLargeParValue decimal(12,2),
  @iPRKey integer
  select @iPRKey = prt_key 
    from piece_rate_type where
    prt_code = 'PP4'
  select @iTotLargeParValue=sum(((isnull(ac_w1_large_parcels,0)+
    isnull(ac_w2_large_parcels,0))*
    isnull(ac_scale_factor,0))*
    pr.pr_rate)
    from artical_count as ac,
    piece_rate as pr where
    ac.contract_no = @inContract and
    ac.contract_seq_number = @inSequence and
    ac_start_week_period between @inYearStart
    and @inMonthEnd and
    pr.prt_key = @iPRKey and
    pr.rg_code = @inRGcode and
    pr.pr_active_status = 'Y' and
    pr_effective_date = 
    (select max(pr_effective_date) from piece_rate where
      prt_key = @iPRKey and
      rg_code = @inRGcode and
      pr_active_status = 'Y' and
      ((@inRenewalEnd is not null and pr_effective_date <= @inRenewalEnd) or
      (@inRenewalEnd is null and pr_effective_date >= @inRenewalStart)))
  return @iTotLargeParValue
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetPieceRates2001 : 
--

CREATE procedure [rd].[sp_GetPieceRates2001](@inRgCode int,@in_Date datetime)
as
begin
  select piece_rate_type.prt_code + ' (' + piece_rate_type.prt_description + ')',
    piece_rate_type.prt_key,
    piece_rate.pr_effective_date,
    piece_rate.rg_code,
    piece_rate.pr_active_status,
    piece_rate.pr_rate from
    piece_rate_type left outer join
    piece_rate on
    (piece_rate_type.prt_key = piece_rate.prt_key and
    piece_rate.pr_effective_date = @in_Date) and
    (piece_rate.rg_code = @inRgCode or @inRgCode is null)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetPieceRates : 
--

CREATE procedure [rd].[sp_GetPieceRates](@in_Date datetime)
as
begin
  select piece_rate_type.prt_code + ' (' + piece_rate_type.prt_description + ')',
    piece_rate_type.prt_key,
    piece_rate.pr_effective_date,
    piece_rate.rg_code,
    piece_rate.pr_active_status,
    piece_rate.pr_rate 
  from piece_rate_type left outer join
    piece_rate on
    (piece_rate_type.prt_key = piece_rate.prt_key and
    piece_rate.pr_effective_date = @in_Date)
--    and piece_rate.rg_code=in_RenewalGroup
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [odps].[OD_RPS_Invoice_pay_adjustments](@invoiceid int,@in_date datetime)
-- TJB  SR4654  April 2005    Changed.  
-- If the payment_component description is "Global fuel rate changed ..."
-- return either the old worded description, or the truncated new wording 
as -- (the function v_fuelRateDescription decides).
begin
  select @in_date,
    prs_description,
    pvolume=(select sum(payment_component_piece_rates.pcpr_volume) from
      payment,payment_component,payment_component_piece_rates,rd.piece_rate_type where
      (payment.invoice_id = payment_component.invoice_id) and
      (payment_component_piece_rates.pc_id = payment_component.pc_id) and
      (piece_rate_type.prt_key = payment_component_piece_rates.prt_key) and
      (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
      (payment_component.invoice_id = @invoiceid) and
      (payment.POTS = 'N')),
    pvalue=(select sum(payment_component_piece_rates.pcpr_value) from
      payment,payment_component,payment_component_piece_rates,rd.piece_rate_type where
      (payment.invoice_id = payment_component.invoice_id) and
      (payment_component_piece_rates.pc_id = payment_component.pc_id) and
      (piece_rate_type.prt_key = payment_component_piece_rates.prt_key) and
      (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
      (payment_component.invoice_id = @invoiceid) and
      (payment.POTS = 'N')) from
    rd.piece_rate_supplier where
    exists((select payment_component_piece_rates.pcpr_volume from
      payment,payment_component,payment_component_piece_rates,rd.piece_rate_type where
      (payment.invoice_id = payment_component.invoice_id) and
      (payment_component_piece_rates.pc_id = payment_component.pc_id) and
      (piece_rate_type.prt_key = payment_component_piece_rates.prt_key) and
      (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
      (payment_component.invoice_id = @invoiceid) and
      (payment.POTS = 'N'))) union
  select pc.misc_date,
    -- TJB  SR4654  April 2005
    -- pc.misc_string ,
    description=case when CHARINDEX('Global fuel rate changed',pc.misc_string) = 0 then
      pc.misc_string
    else odps.v_fuelRateDescription(pc.misc_string)
    end,0,
    pvalue=(select sum(isnull(pc_amount,0)) from
      payment,
      payment_component_type,
      payment_component where
      payment.POTS = 'N' and
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Contract Adjustment%' or
      ((payment_component_type.pct_description like 'Frequency Adjustment%' or
      payment_component_type.pct_description like 'Contract allowance%') and
      left(payment_component.comments,6) = 'Arrear')) and
      (payment.invoice_id = @invoiceid)) and
      payment_component.pc_id = pc.pc_id) from
    payment_component as pc where
    pc.invoice_id = @invoiceid and
    ((select sum(isnull(pc_amount,0)) from
      payment,
      payment_component_type,
      payment_component where
      payment.POTS = 'N' and
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Contract Adjustment%' or
      ((payment_component_type.pct_description like 'Frequency Adjustment%' or
      payment_component_type.pct_description like 'Contract allowance%') and
      left(payment_component.comments,6) = 'Arrear')) and
      (payment.invoice_id = @invoiceid)) and
      payment_component.pc_id = pc.pc_id) <> 0 or (select sum(isnull(pc_amount,0)) from
      payment,
      payment_component_type,
      payment_component where
      payment.POTS = 'N' and
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Contract Adjustment%' or
      ((payment_component_type.pct_description like 'Frequency Adjustment%' or
      payment_component_type.pct_description like 'Contract allowance%') and
      left(payment_component.comments,6) = 'Arrear')) and
      (payment.invoice_id = @invoiceid)) and
      payment_component.pc_id = pc.pc_id) is not null)
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [odps].[OD_RPS_Invoice_pay_piecerate](@invoiceid int,@in_date datetime)
as
begin
  select @in_date,
    prs_description,
    pvolume=(select sum(payment_component_piece_rates.pcpr_volume) from payment,payment_component,payment_component_piece_rates,rd.piece_rate_type where(payment.invoice_id = payment_component.invoice_id) and(payment_component_piece_rates.pc_id = payment_component.pc_id) and(piece_rate_type.prt_key = payment_component_piece_rates.prt_key) and(piece_rate_supplier.prs_key = piece_rate_type.prs_key) and(payment_component.invoice_id = @invoiceid)),
    pvalue=(select sum(payment_component_piece_rates.pcpr_value) from payment,payment_component,payment_component_piece_rates,rd.piece_rate_type where(payment.invoice_id = payment_component.invoice_id) and(payment_component_piece_rates.pc_id = payment_component.pc_id) and(piece_rate_type.prt_key = payment_component_piece_rates.prt_key) and(piece_rate_supplier.prs_key = piece_rate_type.prs_key) and(payment_component.invoice_id = @invoiceid)) from
    rd.piece_rate_supplier where
    (select sum(payment_component_piece_rates.pcpr_volume) from payment,payment_component,payment_component_piece_rates,rd.piece_rate_type where(payment.invoice_id = payment_component.invoice_id) and(payment_component_piece_rates.pc_id = payment_component.pc_id) and(piece_rate_type.prt_key = payment_component_piece_rates.prt_key) and(piece_rate_supplier.prs_key = piece_rate_type.prs_key) and(payment_component.invoice_id = @invoiceid)) > 0
end







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_moduserlog : 
--

CREATE procedure [rd].[sp_moduserlog](@cuserid char(20),@dExpiryDate datetime,@lGraceLogins int) as
begin
  update userids set
    u_last_login_date = getdate(),
    u_last_login_time = getdate(),
    u_password_expiry = @dExpiryDate,
    u_grace_logins = @lGraceLogins where
    u_userid = @cUserid
  return @@error
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_CTS_PaymentComponents : 
--

CREATE procedure [rd].[OD_CTS_PaymentComponents]
as
begin
  select payment_component_type.pct_id,
    payment_component_type.pct_description,
    payment_component_group.pcg_short_code from
    odps.payment_component_group,
    odps.payment_component_type where
    (payment_component_type.pcg_id = payment_component_group.pcg_id) order by 2 asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_CTS_PaymentComponents : 
--

CREATE procedure [odps].[OD_CTS_PaymentComponents]
as
begin
  select payment_component_type.pct_id,
    payment_component_type.pct_description,
    payment_component_group.pcg_short_code from
    odps.payment_component_group,
    odps.payment_component_type where
    (payment_component_type.pcg_id = payment_component_group.pcg_id) order by 2 asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_BLF_Get_GrossPay : 
--

CREATE function [odps].[OD_BLF_Get_GrossPay](@in_invoice_ID int,@in_contract_no int,@in_contractor_no int)
returns decimal(12,2)
as
begin
  declare @gross_pay decimal(12,2)
  select @gross_pay = sum(pc_amount)
    from payment_component,payment_component_type,payment_component_group where
    (payment_component.invoice_id = @in_invoice_ID) and
    (payment_component.pct_id = payment_component_type.pct_id) and
    (payment_component_type.pcg_id = payment_component_group.pcg_id) and
    (payment_component_group.pcg_short_code in('GP','OGP'))
  if @@error <> 0 /* <> was < */
    begin
      --rollback transaction
      return(-200000)
    end
  return(@gross_pay)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure OD_RPS_IR66N : 
--

CREATE procedure [odps].[OD_RPS_IR66N](@sdate datetime,@edate datetime)
as
begin
  select GrossEarnings=(select sum(payment_component.pc_amount) from
      payment,payment_component,payment_component_type,payment_component_group where
      payment.invoice_id = payment_component.invoice_id and
      payment_component.pct_id = payment_component_type.pct_id and
      payment_component_type.pcg_id = payment_component_group.pcg_id and
      (payment_component_group.pcg_short_code = 'GP' or payment_component_group.pcg_short_code = 'OGP') and
      payment.invoice_date between @sdate and @edate),
    PayeDeductions=(select abs(sum(payment_component.pc_amount)) from
      payment,payment_component,payment_component_type,payment_component_group where
      payment.invoice_id = payment_component.invoice_id and
      payment_component.pct_id = payment_component_type.pct_id and
      payment_component_type.pcg_id = payment_component_group.pcg_id and
      payment_component_group.pcg_short_code = 'TAX' and
      payment.invoice_date between @sdate and @edate) 
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_RPF_PCGetSum : 
--

CREATE function [odps].[OD_RPF_PCGetSum](@Invoice int,@ShortCode char(5))
returns decimal(12,2)
as
begin
  -- TJB SR4611 2 Aug 2004
  -- Add clauses to calculate taxable allowances sttributed to NZH (NZ Herald)
  -- and Guardian (amt2), then deduct this from the gross pay calculated (amt1).
  -- Note: if the '... not like ...' clauses are included in the gross pay
  -- statement, rows with NULL values in the misc_string column are also excluded.
  declare @amt1 decimal(12,2),
  @amt2 decimal(12,2)
  select @amt1 = sum(payment_component.pc_amount) 
    from payment_component,
    payment_component_type,
    payment_component_group where
    payment_component.invoice_id = @invoice and
    --Added 16/09/1999,this stops it from adding Kiwimail, Courierpost and XP.
    --So that the extension, Standard and allowance are the only values that are 
    --calculated.
    -- TJB 2-Aug-2004 - changed to 'not in ...' syntax
    payment_component.pct_id not in(7,9,13) and
    payment_component.pct_id = payment_component_type.pct_id and
    payment_component_type.pcg_id = payment_component_group.pcg_id and
    payment_component_group.pcg_short_code = @ShortCode
  select @amt2 = sum(payment_component.pc_amount) 
    from payment_component,
    payment_component_type,
    payment_component_group where
    payment_component.invoice_id = @invoice and
    payment_component.pct_id not in(7,9,13) and
    (payment_component.misc_string like '%NZH%' or
    payment_component.misc_string like '%Guardian%') and
    payment_component.pct_id = payment_component_type.pct_id and
    payment_component_type.pcg_id = payment_component_group.pcg_id and
    payment_component_group.pcg_short_code = @ShortCode
  select @amt1=isnull(@amt1,0)-isnull(@amt2,0)
  return @amt1
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for user-defined function OD_RPS_AP_Interface_Footer_Amt : 
--

CREATE function  [odps].[OD_RPS_AP_Interface_Footer_Amt](@INV int,@inac int)
returns decimal (18,2)
as
begin 
	declare @damt decimal (18,2)
	(select @damt=sum(case when pcgx.pcg_short_code = 'GST' then abs(pcx.pc_amount) else pcx.pc_amount end)  
		from payment_component as pcx,payment_component_type as pctx,payment_component_group as pcgx where
    pcx.invoice_id = @INV and pcx.pct_id = pctx.pct_id and pctx.pcg_id = pcgx.pcg_id and
    (pctx.ac_id = @inac))
    return @damt
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_BLF_Get_NetPay : 
--

CREATE function [odps].[OD_BLF_Get_NetPay](@in_invoice_ID int,@in_contract_no int,@in_contractor_no int)
returns decimal(12,2)
as
begin
  declare @net_pay decimal(12,2)
  if @in_invoice_ID > 0
    begin
      select @net_pay = sum(case when payment_component_group.pcg_short_code = 'GST' then abs(pc_amount) else pc_amount end)
        from payment_component,payment_component_type,payment_component_group where
        (payment_component.invoice_id = @in_invoice_ID) and
        (payment_component.pct_id = payment_component_type.pct_id) and
        (payment_component_type.pcg_id = payment_component_group.pcg_id)
      if @@error <> 0 /* <> was < */
        begin
          --rollback transaction
          return(-200100)
        end
      return(@net_pay)
    end
  if @in_contract_no > 0
    begin
      select @net_pay = sum(case when payment_component_group.pcg_short_code = 'GST' then abs(pc_amount) else pc_amount end)
        from payment,payment_component,payment_component_type,payment_component_group where
        (payment.contract_no = @in_contract_no) and
        (payment_component.invoice_id = payment.invoice_ID) and
        (payment_component.pct_id = payment_component_type.pct_id) and
        (payment_component_type.pcg_id = payment_component_group.pcg_id)
      if @@error <> 0 /* <> was < */
        begin
          --rollback transaction
          return(-200200)
        end
      return(@net_pay)
    end
  if @in_contractor_no > 0
    begin
      select @net_pay = sum(case when payment_component_group.pcg_short_code = 'GST' then abs(pc_amount) else pc_amount end)
        from payment,payment_component,payment_component_type,payment_component_group where
        (payment.contractor_supplier_no = @in_contractor_no) and
        (payment_component.invoice_id = payment.invoice_ID) and
        (payment_component.pct_id = payment_component_type.pct_id) and
        (payment_component_type.pcg_id = payment_component_group.pcg_id)
      if @@error <> 0 /* <> was < */
        begin
          --rollback transaction
          return(-200300)
        end
      return(@net_pay)
    end
  return(@net_pay)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_BLF_Get_GrossPay_PreAccept : 
--

CREATE function [odps].[OD_BLF_Get_GrossPay_PreAccept](@in_invoice_ID int,@in_contract_no int,@in_contractor_no int)
returns decimal(12,2)
as
begin
  declare @gross_pay decimal(12,2)
  select @gross_pay = sum(pc_amount)
    from t_payment_component,payment_component_type,payment_component_group where
    (t_payment_component.invoice_id = @in_invoice_ID) and
    (t_payment_component.pct_id = payment_component_type.pct_id) and
    (payment_component_type.pcg_id = payment_component_group.pcg_id) and
    (payment_component_group.pcg_short_code in('GP','OGP'))
  if @@error <> 0 /* <> was < */
    begin
      --rollback transaction
      return(-200000)
    end
  return(@gross_pay)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_RPF_PCNegitivePayGetSum : 
--

CREATE function [odps].[OD_RPF_PCNegitivePayGetSum](@Invoice int,@ShortCode char(5))
returns decimal(12,2)
as
begin
  declare @amt decimal(12,2)
  select @amt =  sum(payment_component.pc_amount) 
    from payment_component,payment_component_type,payment_component_group where
    payment_component.invoice_id = @invoice and
    payment_component.pct_id = payment_component_type.pct_id and
    payment_component_type.pcg_id = payment_component_group.pcg_id and
    payment_component_group.pcg_short_code = @ShortCode
  if @amt is null
    return 0
  else
    return @amt
return -1
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_RPF_PCTNegativePayGetSum : 
--

CREATE function [odps].[OD_RPF_PCTNegativePayGetSum](@Invoice int,@ShortCode char(5))
returns decimal(12,2)
as
begin
  declare @amt decimal(12,2)
  select @amt = sum(t_payment_component.pc_amount) 
    from t_payment_component,
    payment_component_type,payment_component_group where
    t_payment_component.invoice_id = @invoice and
    t_payment_component.pct_id = payment_component_type.pct_id and
    payment_component_type.pcg_id = payment_component_group.pcg_id and
    payment_component_group.pcg_short_code = @ShortCode
  if @amt is null
    return 0
  else
    return @amt
return -1
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_RPF_PCTGetSum : 
--

CREATE function [odps].[OD_RPF_PCTGetSum](@Invoice int,@ShortCode char(5))
returns decimal(12,2)
as
begin
  declare @amt decimal(12,2)
  select @amt = sum(t_payment_component.pc_amount) 
    from t_payment_component,payment_component_type,payment_component_group where
    t_payment_component.invoice_id = @invoice and
    t_payment_component.pct_id = payment_component_type.pct_id and
    --Added 16/09/1999,this stops it from adding Kiwimail ,Courierpost and XP.
    --So that the extension ,Standard and allowance are the only values that are 
    --calculated.  
    payment_component_type.pct_id <> 7 and
    payment_component_type.pct_id <> 9 and
    payment_component_type.pct_id <> 13 and
    payment_component_type.pcg_id = payment_component_group.pcg_id and
    payment_component_group.pcg_short_code = @ShortCode
  if @amt is null
    return 0
  else
    return @amt
return -1
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_BLF_Get_NetPay_PreAccept : 
--

CREATE function [odps].[OD_BLF_Get_NetPay_PreAccept](@in_invoice_ID int,@in_contract_no int,@in_contractor_no int)
returns decimal(12,2)
as
begin
  declare @net_pay decimal(12,2)
  if @in_invoice_ID > 0
    begin
      select @net_pay = sum(case when payment_component_group.pcg_short_code = 'GST' then abs(pc_amount) else pc_amount end)
        from t_payment_component,payment_component_type,payment_component_group where
        (t_payment_component.invoice_id = @in_invoice_ID) and
        (t_payment_component.pct_id = payment_component_type.pct_id) and
        (payment_component_type.pcg_id = payment_component_group.pcg_id)
      if @@error <> 0 /* <> was < */
        begin
          --rollback transaction
          return(-200000)
        end
      return(@net_pay)
    end
  if @in_contract_no > 0
    begin
      select @net_pay = sum(case when payment_component_group.pcg_short_code = 'GST' then abs(pc_amount) else pc_amount end)
        from t_payment,t_payment_component,payment_component_type,payment_component_group where
        (t_payment.contract_no = @in_contract_no) and
        (t_payment_component.invoice_id = t_payment.invoice_ID) and
        (t_payment_component.pct_id = payment_component_type.pct_id) and
        (payment_component_type.pcg_id = payment_component_group.pcg_id)
      if @@error <> 0 /* <> was < */
        begin
          --rollback transaction
          return(-200010)
        end
      return(@net_pay)
    end
  if @in_contractor_no > 0
    begin
      select @net_pay = sum(case when payment_component_group.pcg_short_code = 'GST' then abs(pc_amount) else pc_amount end)
        from t_payment,t_payment_component,payment_component_type,payment_component_group where
        (t_payment.contractor_supplier_no = @in_contractor_no) and
        (t_payment_component.invoice_id = t_payment.invoice_ID) and
        (t_payment_component.pct_id = payment_component_type.pct_id) and
        (payment_component_type.pcg_id = payment_component_group.pcg_id)
      if @@error <> 0 /* <> was < */
        begin
          --rollback transaction
          return(-200020)
        end
      return(@net_pay)
    end
  return(@net_pay)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function GetContractDelDays_whatif : 
--

CREATE function [rd].[GetContractDelDays_whatif](
@inContract int,
@inRGCode int,
@inRateDate datetime)
returns int
-- TJB 4635 - Sept 04
-- Variation on GetContractDelDays for whatif calculation
-- Drops RG_Code from selection condition (see below)
-- See also f_getConsumptionRates_whatif, f_getFuelRates_whatif, f_getInsurance_whatif
as -- Called from sp_getWhatifCalc2001c
begin
  declare @iDaysInWeek int
  declare @iMaxDaysInYear int
  select @iDaysInWeek=sum(case substring(rf_delivery_days,1,1) when 'Y' then 1 else 0 end)+
    sum(case substring(rf_delivery_days,2,1) when 'Y' then 1 else 0 end)+
    sum(case substring(rf_delivery_days,3,1) when 'Y' then 1 else 0 end)+
    sum(case substring(rf_delivery_days,4,1) when 'Y' then 1 else 0 end)+
    sum(case substring(rf_delivery_days,5,1) when 'Y' then 1 else 0 end)+
    sum(case substring(rf_delivery_days,6,1) when 'Y' then 1 else 0 end)+
    sum(case substring(rf_delivery_days,7,1) when 'Y' then 1 else 0 end)  
    from route_frequency where
    contract_no = @inContract and
    rf_active <> 'N'
  select @iMaxDaysInYear=max(rtd_days_per_annum)
    from standard_frequency join rate_days on
    standard_frequency.sf_key = rate_days.sf_key and
    rate_days.rr_rates_effective_date = @inRateDate and
    standard_frequency.sf_days_week = @iDaysInWeek
  -- TJB 4635
  --and rate_days.rg_code=inRgCode
  return @iMaxDaysInYear
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function GetContractDelDays : 
--

CREATE function [rd].[GetContractDelDays]
(@inContract int,
@inSequence int,
@inRGCode int,
@inRateDate datetime)
returns int
as
begin
  declare @iMonday int
  declare @iTuesday int
  declare @iWednesday int
  declare @iThursday int
  declare @iFriday int
  declare @iSaturday int
  declare @iSunday int
  declare @iDaysInWeek int
  declare @iMaxDaysInYear int
  select @iMonday=sum(case substring(rf_delivery_days,1,1) when 'Y' then 1 else 0 end),
    @iTuesday=sum(case substring(rf_delivery_days,2,1) when 'Y' then 1 else 0 end),
    @iWednesday=sum(case substring(rf_delivery_days,3,1) when 'Y' then 1 else 0 end),
    @iThursday=sum(case substring(rf_delivery_days,4,1) when 'Y' then 1 else 0 end),
    @iFriday=sum(case substring(rf_delivery_days,5,1) when 'Y' then 1 else 0 end),
    @iSaturday=sum(case substring(rf_delivery_days,6,1) when 'Y' then 1 else 0 end),
    @iSunday=sum(case substring(rf_delivery_days,7,1) when 'Y' then 1 else 0 end) 
     from route_frequency where
    contract_no = @inContract and
    rf_active <> 'N'
  select @iDaysInWeek=(case when @iMonday > 0 then 1 else 0 end)+
    (case when @iTuesday > 0 then 1 else 0 end)+
    (case when @iWednesday > 0 then 1 else 0 end)+
    (case when @iThursday > 0 then 1 else 0 end)+
    (case when @iFriday > 0 then 1 else 0 end)+
    (case when @iSaturday > 0 then 1 else 0 end)+
    (case when @iSunday > 0 then 1 else 0 end)
  select @iMaxDaysInYear= max(rtd_days_per_annum) 
    from standard_frequency join
    rate_days on
    standard_frequency.sf_key = rate_days.sf_key and
    rate_days.rg_code = @inRgCode and
    rate_days.rr_rates_effective_date = @inRateDate and
    standard_frequency.sf_days_week = @iDaysInWeek
  return @iMaxDaysInYear
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_DDDW_RB_StandardFrequency : 
--

CREATE procedure [rd].[sp_DDDW_RB_StandardFrequency]
as
begin
  select sf_key,sf_description,bull='z' from
    standard_frequency union
  select-1,'<All>','a'   order by
    3 asc,2 asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_StandardFrequency : 
--

CREATE procedure [rd].[sp_DDDW_StandardFrequency]
as
begin
  select sf_key,
    sf_description,
    sf_days_week from
    standard_frequency order by
    sf_description asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRateDays2001 : 
--

CREATE procedure [rd].[sp_GetRateDays2001](
@inRgCode int,
@in_Date datetime)
as
begin
  select rate_days.rg_code,
    rate_days.rr_rates_effective_date,
    standard_frequency.sf_key,
    rate_days.rtd_days_per_annum,
    standard_frequency.sf_description,
    standard_frequency.sf_days_week from
    standard_frequency left outer join rate_days on 
    standard_frequency.sf_key = rate_days.sf_key and
    rate_days.rr_rates_effective_date = @in_Date and
    rate_days.rg_code = @inRgCode
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetVehicleRate : 
--

CREATE procedure [rd].[sp_GetVehicleRate](@in_vt_key int,@in_effective_date datetime)
as
begin
  select vehicle_rate.vt_key,
    vehicle_rate.vr_rates_effective_date,
    vehicle_rate.vr_nominal_vehicle_value,
    vehicle_rate.vr_repairs_maintenance_rate,
    vehicle_rate.vr_tyre_tubes_rate,
    vehicle_rate.vr_vehicle_allowance_rate,
    vehicle_rate.vr_licence_rate,
    vehicle_rate.vr_vehicle_rate_of_return_pct,
    vehicle_rate.vr_salvage_ratio,
    vehicle_rate.vr_ruc,
    vehicle_rate.vr_sundries_k,
    vehicle_rate.vr_vehicle_value_insurance_pct,
    vehicle_rate.vr_livery from
    vehicle_rate where
    vehicle_rate.vt_key = @in_vt_key and
    vehicle_rate.vr_rates_effective_date = @in_effective_date
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_rd_auditlog : 
--

CREATE procedure [odps].[sp_rd_auditlog](@fromdate datetime,@todate datetime)
as
begin
  declare @sfromdate char(20),
  @stodate char(20)
  select @sfromdate=convert(datetime,rd.Date(@fromdate),120)
  select @stodate=convert(datetime,@todate,120)
  select a_key,
    a_datetime,
    a_userid,rds_audit.a_contract,
    a_contractor,rds_audit.a_comment,
    a_oldvalue,
    a_newvalue,
ddate=CONVERT(varchar(12),a_datetime,111)  from  
    rd.rds_audit where
    a_datetime between cast(@sfromdate as datetime) and cast (@stodate as datetime) and
    a_userid <> 'DB Trigger' order by ddate desc,
    a_contract asc,a_contractor asc
end


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_rd_auditlog : 
--

CREATE procedure [rd].[sp_rd_auditlog](@fromdate datetime,@todate datetime)
as
begin
  declare @sfromdate char(20),
  @stodate char(20)
  select @sfromdate=convert(datetime,rd.Date(@fromdate),120)
  select @stodate=convert(datetime,@todate,120)
  select a_key,
    a_datetime,
    a_userid,rds_audit.a_contract,
    a_contractor,rds_audit.a_comment,
    a_oldvalue,
    a_newvalue,
    ddate=cast(a_datetime as datetime) from
    rd.rds_audit where
    a_datetime between cast(@sfromdate as datetime) and cast (@stodate as datetime) and
    a_userid <> 'DB Trigger' order by ddate desc,
    a_contract asc,a_contractor asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_rd_auditlog_addresschange : 
--

CREATE procedure [rd].[sp_rd_auditlog_addresschange](@fromdate datetime,@todate datetime)
as
begin
    declare @sfromdate char(20),
  @stodate char(20)
  select @sfromdate=convert(datetime,rd.Date(@fromdate),120)
  select @stodate=convert(datetime,@todate,120)
  select a_key,
    a_datetime,
    a_userid,
    rds_audit.a_contract,
    a_contractor,
    rds_audit.a_comment,
    a_oldvalue,
    a_newvalue,
    ddate=rd.date(a_datetime) from
    rd.rds_audit where
    a_datetime between cast(@sfromdate as datetime) and cast(@stodate as datetime) and
    a_userid <> 'DB Trigger' and
    left(a_newvalue,8) = 'Address:' order by
    ddate desc,
    a_contract asc,
    a_contractor asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [odps].[OD_BLF_Mainrun_WithHoldingTax]
as
begin
  declare @v_pcfaker integer,
  @v_ctr integer,
  @v_invoiceid integer,
  @v_taxrate decimal(12,4),
  @v_gross decimal(12,2)
  declare vc_invoice_list cursor for select invoice_id,(witholding_tax_rate_applied/100.0)*-1.0 from t_payment
  select @v_pcfaker = count(*) from t_payment_component
  select @v_ctr=0

  open vc_invoice_list
  /* Watcom only
  iloop:
  */while 1=1 
    begin
      fetch next from vc_invoice_list into @v_invoiceid,@v_taxrate
      if @@error <> 0
        begin
          rollback transaction
          return(-808)
        end
      if @v_taxrate is null
        select @v_taxrate=0
      if @@FETCH_STATUS <0
        break
        /* Watcom only
        iloop
        */
      select @v_ctr=@v_ctr+1
      select @v_gross = sum(tpc.pc_amount) from t_payment_component as tpc where tpc.invoice_id = @v_invoiceid
      insert into t_payment_component(/*pc_id,*/ --Cannot insert explicit value for identity column in table 't_payment_component' when IDENTITY_INSERT is set to OFF.
        pct_id,
        invoice_id,
        pc_amount,comments,misc_string,misc_decimal)
        select /*@v_pcfaker+@v_ctr,*/ 
          (select pct_id from payment_component_type where pct_description like 'Withholding Tax%'),
          t_payment.invoice_id,
          (@v_gross)*@v_taxrate,'Withholding Tax - ' + 
          convert(varchar,t_payment.witholding_tax_rate_applied) + '%','Tax rate applied',@v_taxrate from
          t_payment where
          t_payment.invoice_id = @v_invoiceid and
          exists(select tc.pc_amount from t_payment_component as tc,payment_component_type as pctt where
            tc.pct_id = pctt.pct_id and pctt.pct_description not like 'Post-Tax%' and tc.invoice_id = @v_invoiceid and tc.pc_amount > 0)
      if @@error <> 0
		begin
		rollback transaction
        return(@@error)
		end
    end
  close vc_invoice_list
deallocate vc_invoice_list
  if @@error <> 0
    begin
      rollback transaction
      return(-101)
    end
--!commit transaction
  return(0)
/* Watcom only
exception
  when others then
    rollback transaction
    resignal
    return(-1)
*/
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for user-defined function f_GetMailCategory : 
--

CREATE function [rd].[f_GetMailCategory](@ai_cust_id int)
returns char(2000)
as
begin
  declare @sret varchar(2000),
  @stemp varchar(100)
  declare mail_cat cursor for select 'Business' from
      rd.rds_customer where
      rds_customer.cust_business = 'Y' and
      (rds_customer.cust_id = @ai_cust_id) union
    select 'Rural Residential' from
      rd.rds_customer where
      rds_customer.cust_rural_resident = 'Y' and
      (rds_customer.cust_id = @ai_cust_id) union
    select 'Rural Farmer' from
      rd.rds_customer where
      rds_customer.cust_rural_farmer = 'Y' and
      (rds_customer.cust_id = @ai_cust_id)
  open mail_cat
  fetch next from mail_cat into @stemp
  select @sret=@stemp
  close mail_cat
  return(@sret)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for user-defined function f_GetRecipients : 
--

CREATE function [rd].[f_GetRecipients](@ai_cust_id int)
returns char(2000)
as
begin
  declare @sret varchar(2000),
  @stemp1 varchar(100),
  @stemp2 varchar(100)
  declare mail_recp /*dynamic scroll mkwang_msd*/ cursor for select rds_customer.cust_initials,
      rds_customer.cust_surname_company from
      rds_customer where
      (rds_customer.master_cust_id = @ai_cust_id)
  open mail_recp
  /* Watcom only
  myloop:
  while 1=1 
    begin*/
      fetch next from  mail_recp into @stemp1,@stemp2
      while @@fetch_status = 0
       begin
        /*break*/
        /* Watcom only
        myloop
        */
      -- TJB 30-Sep-2004 SR4637
      -- Changed to improve performance
      -- (tjb) Trailing linefeed on last recipient irrelevant so don''t need test to eliminate it.
      -- if length(sret) > 0 then
      -- PBY SR#4373,4368 Commented out char(13) so only a newline is used. (char13 is carriage return)
      -- set sret=sret || "char"(10) -- || "char"(13)
      -- end if;
      -- (tjb) Note: Probably meant "ifnull" with stemp1 and stemp2 switched around
      --    set sret=sret+' '+stemp1+' '+isnull(stemp2,'',', '+' '+stemp2)
      select @sret=isnull(@sret,'')+isnull(@stemp1,'')+' '+isnull(@stemp2,'')+char(10)
      fetch next from  mail_recp into @stemp1,@stemp2
    end
  close mail_recp
  return(@sret)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_PointTypes : 
--

CREATE procedure -- TJB 16 Mar 04 SR4607
-- Update database tables used to populate dropdown lists in 
--     dw_frequency_description window
-- Update stored procedures  used for retrieval to put blank
--     entries first
[rd].[sp_DDDW_PointTypes]
as
begin
  select rfpt_id,rfpt_description from
    route_freq_point_type order by
    rfpt_id asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_PieceRates : 
--

CREATE procedure [rd].[sp_DDDW_PieceRates]
as
begin
  select prt_key,
    prt_code + ' (' + prt_description + ')',
    prs_description from
    piece_rate_type join piece_rate_supplier on piece_rate_type.prs_key = piece_rate_supplier.prs_key
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_postcode_list : 
--

CREATE procedure -- Tim Chan 24/03/2003
-- This is a new procedure written as part of the resolution to service request 4474_01
-- 
[rd].[sp_postcode_list]
as
begin
  select pc.post_code+'   '+pc.post_mail_town,pc.post_code_id from
    post_code as pc order by
    pc.post_code asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_MiscF_Get_PCT_SequenceConsolidated : 
--

CREATE function [odps].[OD_MiscF_Get_PCT_SequenceConsolidated](@inInvoice_id int,@inacid_id int)
returns int
as
begin 
	declare @iSeqCount int 
	select @iSeqCount = count(distinct pct.ac_id) 
    from payment_component as pc,
    payment_component_type as pct where pc.invoice_id = @inInvoice_id and pc.pct_id = pct.pct_id and
    pct.ac_id < @inacid_id
  if @iSeqCount is null or @iSeqCount = 0
    return(1)
  else return(@iSeqCount+1)
  --if @@fetch_status < 0 -- by fyb
   -- begin
    --  rollback transaction
   --   return(-1)
  --  end
 -- return(InvoiceNumber) 
 return (-1)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_CTS_PaymentComponentType : 
--

CREATE procedure [odps].[OD_CTS_PaymentComponentType]
as
begin
  select pct_id,
    pct_description from
    payment_component_type order by 2 asc
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_DDDW_Verbs : 
--

CREATE procedure  [rd].[sp_DDDW_Verbs]
as
begin
  select rfv_id,rfv_description from
    route_freq_verbs order by
    rfv_description asc
end













GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_AllowanceType : 
--

CREATE procedure [rd].[sp_DDDW_AllowanceType]
as
begin
  select alt_key,
    alt_description from
    allowance_type
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractAllowance : 
--

--
-- Definition for stored procedure sp_GetContractAllowance : 
--

CREATE procedure [rd].[sp_GetContractAllowance](@in_Contract int)
as
begin
  select ca.alt_key,
    ca.contract_no,
    ca.ca_effective_date,
    ca.ca_annual_amount,
    ca.ca_notes,
    ca.ca_paid_to_date,
    ca.pct_id from
    contract_allowance as ca join allowance_type as at on ca.alt_key=at.alt_key where
    ca.contract_no = @in_Contract and
    ca.ca_annual_amount is not null and
    ca.ca_annual_amount <> 0 order by
    at.alt_description asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_cust_list_con : 
--

CREATE procedure [rd].[sp_cust_list_con](
@con_id int)
-- TJB  SR4683  Aug 2006
-- Change customer category counts to use the Kiwimail number at an address
--
-- TJB  Oct 2005
-- Changed: add adr_unit as separate returned value and removed from road_no;
--          pad road_no, road_unit with spaces for sorting
--
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added adr_unit number and road_suffix to relevant parts of address returned
--
-- TJB  SR4659  July 2005
-- Added section for CMB numbers and cmb_seq return value
--
as -- Surname/company
begin
  declare
  /* Watcom only
  err_notfound exception for sqlstate value '02000'
  ,*/
  @rec_tmp char(200),
  @cust_tmp int,
  @master_tmp char(200),
  @cust_count_master int,
  @cust_count_recip int,
  @cust_count_cmb int,
  @cust_count int,
  @del_pt_count int
  -- temp table for the all occupied addresses
  create table #occ_temp(
    adr_id integer null,
    sur_comp_name char(45) null,
    initials char(30) null,
    prop_title char(100) null,
    road_no char(20) null,
    road_alpha char(20) null,
    road_name char(61) null,
    locality char(50) null,
    rd_no char(40) null,
    mail_town char(50) null,
    recipients char(200) null,
    categories char(15) null,
    kiwimail_qty integer null,
    business integer null,
    residential integer null,
    farmer integer null,
    cust_counter integer null,
    cmb_seq integer null,
    road_unit char(10) null,
    )
  -- first create temporary tables for master customers 
  -- and recipients at an address
  create table #master_temp(
    master_num integer null,
    recip_char char(200) null,
    ) 
  create table #recipient_temp(
    recip_num integer null,
    recip_char_b char(200) null,
    ) 
  -- TJB Sept 2005  Replaced the cursor - see below
  --  declare recipient_list dynamic scroll cursor for 
  --            select recip.recip_num, recip.recip_char_b
  --              from #recipient_temp recip;
  --
  --  declare iRecip_num integer;
  --  declare cRecip_char char(200);
  --  declare cAdd  char(200);
  -- get all master cust_id''s first
  insert into #master_temp(master_num)
    select distinct(cust.cust_id) from
      rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id
      join address as addr on addr.adr_id = cam.adr_id where
      addr.contract_no = @con_id and
      --and cam.adr_id = addr.adr_id
      cam.move_out_date is null and
      --and cust.cust_id = cam.cust_id
      cust.master_cust_id is null
  -- get all recipient names
  insert into #recipient_temp(recip_num,recip_char_b)
    select cust.master_cust_id,', '+
      rd.trim(isnull(cust.cust_surname_company,'')+' '+isnull(cust.cust_initials,'')) from
      rds_customer as cust where
      cust.master_cust_id = any(select tmp.master_num from #master_temp as tmp) and
      (cust.cust_surname_company is not null or cust.cust_initials is not null) and
      (len(cust.cust_surname_company) > 0 or len(cust.cust_initials) > 0)
  -- TJB Sept 2005 
  -- Add recipients to master list
  -- This replaces the cursor and speeds the procedure up considerably!
  update #master_temp set
    #master_temp.recip_char = #master_temp.recip_char+#recipient_temp.recip_char_b from
    #recipient_temp where
    #master_temp.master_num = #recipient_temp.recip_num
  ------------ cursor attempt
  --
  --  set iRecip_num=0;
  --  set cRecip_char='';
  --  
  --  open recipient_list;
  --  CursorLoop: loop
  --    fetch next recipient_list into iRecip_num, cRecip_char;
  --    if sqlstate=err_notfound then
  --      leave CursorLoop
  --    end if;
  --    
  --    set cAdd = '';  
  --
  --    -- get original char value
  --
  --    select mast.recip_char 
  --      into cAdd     
  --      from #master_temp mast
  --     where mast.master_num = iRecip_num;
  --    
  --    set cAdd = cAdd + cRecip_char;
  --    
  --    -- do update to #master_temp
  --
  --    update #master_temp
  --       set #master_temp.recip_char = cAdd
  --     where #master_temp.master_num = iRecip_num;
  --    
  --    set iRecip_num=0;
  --    set cRecip_char='';
  --    
  --  end loop CursorLoop;
  --  close recipient_list;
  select @cust_count_master = count(*)
    from #master_temp
  /******************************************************
  *          main select for the procedure             *
  ******************************************************/
  -- populate the temp table for occupants
  -- TJB  SR4683  Aug 2006
  -- Changed the category counts to equal the Kiwimail count, instead of 1
  --
  -- TJB Sept 2005
  --     Removed the 'group by' clause. Redundant.
  --     Combined tables in to joins - it improved performance
  --     Added "mast_cust_id is null" - also improved performance
  insert into #occ_temp(adr_id,
    sur_comp_name,initials,prop_title,
    road_no,road_alpha,road_name,
    locality,rd_no,mail_town,
    recipients,categories,
    business,residential,farmer,
    kiwimail_qty,
    cmb_seq,road_unit)
    select distinct addr.adr_id,
      cust.cust_surname_company,
      cust.cust_initials,
      addr.adr_property_identification,
      --upper(ifnull(addr.adr_unit,'',addr.adr_unit+'/')+trim(addr.adr_no)), 
      rd.trim(addr.adr_no),
      upper(rd.trim(addr.adr_alpha)),
      rd.road_name+/*ifnull(rt.rt_name,'',' '+rt.rt_name)*/case when isnull(rt.rt_name,'') = '' then '' else ' '+rt.rt_name end +
      --ifnull(rs.rs_name,'',' '+rs.rs_name),
      case when isnull(rs.rs_name,'') = '' then '' else ' '+rs.rs_name end,
      sub.sl_name,
      addr.adr_rd_no,
      tc.tc_name,
      substring(mast.recip_char,3,len(mast.recip_char)-2),
      (case when cust.cust_business = 'Y' then 'Business' else
        case when cust.cust_rural_farmer = 'Y' then 'Farmer' else
          case when cust.cust_rural_resident = 'Y' then 'Residential'
          end
        end
      end),(case when cust.cust_business = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
      (case when cust.cust_rural_resident = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
      (case when cust.cust_rural_farmer = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
      kiwimail_qty=cust.cust_adpost_quantity,
      0, -- cmb_seq
      addr.adr_unit from -- road_unit
      rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id
      join address as addr on addr.adr_id = cam.adr_id
      left outer join suburblocality as sub on addr.sl_id = sub.sl_id
      join towncity as tc on addr.tc_id = tc.tc_id
      join road as rd  on addr.road_id =rd.road_id
      left outer join road_type as rt on rd.rt_id = rt.rt_id
      left outer join road_suffix as rs on rd.rs_id = rs.rs_id,
      #master_temp as mast where
      cust.cust_id = mast.master_num and
      cam.move_out_date is null and
      cust.master_cust_id is null
  -- and cust.cust_id = cam.cust_id
  -- and addr.adr_id = cam.adr_id 
  -- and tc.tc_id = addr.tc_id 
  -- and rd.road_id = addr.road_id
  -- group by addr.adr_id, cust.cust_surname_company, cust.cust_initials, 
  --       addr.adr_property_identification, addr.adr_unit, addr.adr_no, 
  --       upper(trim(addr.adr_alpha)), rd.road_name, rt.rt_name, rs.rs_name, 
  --       sub.sl_name, addr.adr_rd_no, tc.tc_name, substr(mast.recip_char, 3),
  --       cust.cust_business, cust.cust_rural_resident, cust_rural_farmer, 
  --       cust.cust_adpost_quantity;
  -- insert the unoccupied entries into the table
  -- TJB Sept 2005
  --     Removed the 'group by' clause. Redundant.
  --     Combined tables into joins - it improved performance
  insert into #occ_temp(adr_id,
    prop_title,
    road_no,road_alpha,road_name,
    locality,rd_no,mail_town,
    business,residential,farmer,
    cmb_seq,road_unit)
    select distinct(addr.adr_id),
      addr.adr_property_identification,
      --upper(ifnull(addr.adr_unit,'',addr.adr_unit+'/')+trim(addr.adr_no)), 
      rd.trim(addr.adr_no),
      upper(rd.trim(addr.adr_alpha)),
      rd.road_name+/*ifnull(rt.rt_name,'',' '+rt.rt_name)*/case when isnull(rt.rt_name,'') = '' then '' else ' '+rt.rt_name end+
      --ifnull(rs.rs_name,'',' '+rs.rs_name),
      case when isnull(rs.rs_name,'') = '' then '' else ' '+rs.rs_name end,
      sub.sl_name,
      addr.adr_rd_no,
      tc.tc_name,
      0, -- Business
      0, -- Resident
      0, -- Farmer 
      0, -- cmb_seq
      addr.adr_unit from -- road_unit
      address as addr left outer join suburblocality as sub on addr.sl_id = sub.sl_id
      join towncity as tc on addr.tc_id = tc.tc_id
      join road as rd on addr.road_id = rd.road_id
      left outer join road_type as rt on rd.rt_id = rt.rt_id
      left outer join road_suffix as rs on rd.rs_id = rs.rs_id where
      addr.contract_no = @con_id and
      not addr.adr_id = any(select occ.adr_id from #occ_temp as occ)
  -- and addr.road_id = rd.road_id
  -- and addr.tc_id = tc.tc_id
  -- group by addr.adr_id, addr.adr_property_identification, addr.adr_unit,
  --    addr.adr_no, upper(trim(addr.adr_alpha)), rd.road_name, rt.rt_name, 
  --    rs.rs_name, sub.sl_name, addr.adr_rd_no, tc.tc_name;
  -- Get the total number of delivery points (excluding the CMBs)
  select @del_pt_count = count(distinct(adr_id))
    from #occ_temp
  -- insert the CMB entries into the table
  insert into #occ_temp(sur_comp_name,
    initials,
    road_no,
    rd_no,mail_town,
    categories,
    business,residential,farmer,
    kiwimail_qty,
    cmb_seq)
    select cmb.cmb_cust_surname,
      cmb.cmb_cust_initials,
      cmb.cmb_box_no,
      cmb.adr_rd_no,
      tc.tc_name,'CMB',
      0, -- Business
      0, -- Resident
      0, -- Farmer 
      kiwimail_qty=(case when(cmb_cust_surname is null or cmb_cust_surname = '') and
      (cmb_cust_initials is null or cmb_cust_initials = '') then
        null else 1 end),
      row_number() over (order by cmb.adr_rd_no asc) from -- cmb_seq
      cmb_address as cmb,
      towncity as tc where
      cmb.contract_no = @con_id and
      cmb.tc_id = tc.tc_id order by
      tc.tc_name asc,cmb.cmb_box_no asc
  -- Count the CMB customers
  select @cust_count_cmb = count(*)
    from cmb_address where
    contract_no = @con_id and
    ((cmb_cust_surname is not null and cmb_cust_surname <> '') or
    (cmb_cust_initials is not null and cmb_cust_initials <> ''))
  -- Calculate the total customer count
  select @cust_count=isnull(@cust_count_master,0)+isnull(@cust_count_cmb,0)
  select sur_comp_name,
    initials,
    prop_title,
    road_no=right(space(20)+road_no,20),
    road_alpha,
    road_name,
    locality,
    rd_no,
    mail_town,
    recipients,
    categories,
    kiwimail_qty,
    business,
    residential,
    farmer,
    @cust_count,
    @del_pt_count,
    cmb_seq,
    road_unit=right(space(10)+road_unit,10) from
    #occ_temp
end


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_cust_list_town](
@town_id int)
-- TJB  SR4683  Aug 2006
-- Change customer category counts to use the Kiwimail number at an address
--
-- TJB  Oct 2005
-- Changed: add adr_unit as separate returned value and removed from road_no;
--          pad road_no, road_unit with spaces for sorting
--
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added adr_unit number and road_suffix to relevant parts of address returned
--
-- TJB  SR4659  July 2005
-- Added section for CMB numbers and cmb_seq return value
as --
begin
  declare
   /*Watcom only
  err_notfound exception for sqlstate value '02000'
  ,*/
  @rec_tmp char(200),
  @cust_tmp int,
  @master_tmp char(200),
  @cust_count int,
  @cust_count_master int,
  @cust_count_recip int,
  @cust_count_cmb int,
  @del_pt_count int
  -- temp table for the all occupied address''
  create table #occ_temp(
    adr_id integer null,
    sur_comp_name char(45) null,
    initials char(30) null,
    prop_title char(100) null,
    road_no char(20) null,
    road_alpha char(20) null,
    road_name char(61) null,
    locality char(50) null,
    rd_no char(40) null,
    mail_town char(50) null,
    recipients char(200) null,
    categories char(15) null,
    kiwimail_qty integer null,
    business integer null,
    residential integer null,
    farmer integer null,
    cust_counter integer null,
    cmb_seq integer null,
    road_unit char(10) null,
    ) 
  
  -- first create a temporary table for recipients at an address
  create table #master_temp(
    master_num integer null,
    recip_char varchar(200) null,
    )
 
 create table #recipient_temp(
    recip_num integer null,
    recip_char_b char(200) null,
    ) 
  -- TJB Sept 2005  Replaced the cursor - see below
  --  declare recipient_list dynamic scroll cursor for 
  --            select recip.recip_num, recip.recip_char_b
  --              from #recipient_temp recip;
  --
  --  declare iRecip_num  integer;
  --  declare cRecip_char char(200);
  --  declare cAdd        char(200);
  -- get all master cust_id''s first
  insert into #master_temp(master_num)
    select distinct(cust.cust_id) from
      (rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id)join
      address as addr on addr.adr_id = cam.adr_id where
      addr.tc_id = @town_id and
      cam.move_out_date is null and
      cust.master_cust_id is null
  --and addr.adr_id = cam.adr_id
  --and cust.cust_id = cam.cust_id;
  -- get all recipients'' names
  insert into #recipient_temp(recip_num,recip_char_b)
    select cust.master_cust_id,', '+
      rd.trim(isnull(cust.cust_surname_company,'')+' '+isnull(cust.cust_initials,'')) from
      rds_customer as cust where
      cust.master_cust_id = any(select tmp.master_num from #master_temp as tmp) and
      (cust.cust_surname_company is not null or cust.cust_initials is not null) and
      (len(cust.cust_surname_company) > 0 or len(cust.cust_initials) > 0)
  -- TJB Sept 2005 
  -- Add recipients to master list
  -- This replaces the cursor and speeds the procedure up considerably!
  update #master_temp set
    #master_temp.recip_char = ISNULL(#master_temp.recip_char,'')+#recipient_temp.recip_char_b from
    #recipient_temp where
    #master_temp.master_num = #recipient_temp.recip_num
  ------------ cursor attempt
  --
  --  set iRecip_num=0;
  --  set cRecip_char='';
  --
  --  open recipient_list;
  --  CursorLoop: loop
  --    fetch next recipient_list into iRecip_num, cRecip_char;
  --    if sqlstate=err_notfound then
  --      leave CursorLoop
  --    end if;
  --
  --        set cAdd = '';  
  --    -- get original char value
  --
  --    select mast.recip_char 
  --      into cAdd     
  --      from #master_temp mast
  --     where mast.master_num = iRecip_num;
  --
  --    set cAdd = cAdd + cRecip_char;
  --
  --    -- do update to #master_temp
  --
  --    update #master_temp
  --       set #master_temp.recip_char = cAdd
  --     where #master_temp.master_num = iRecip_num;
  --
  --    set iRecip_num=0;
  --    set cRecip_char='';
  --
  --  end loop CursorLoop;
  --  close recipient_list;
  -- Count the number of customers in the occupied addresses
  -- TJB  SR4683  Aug 2006
  select @cust_count_master = count(*)
    from #master_temp
  -- main select for the procedure
  -- populate the temp table for occupants
  -- TJB  SR4683  Aug 2006
  -- Changed the category counts to equal the Kiwimail count, instead of 1
  --
  insert into #occ_temp(adr_id,
    sur_comp_name,initials,prop_title,
    road_no,road_alpha,road_name,locality,rd_no,mail_town,
    recipients,categories,
    business,residential,farmer,
    kiwimail_qty,
    cmb_seq,road_unit)
    select addr.adr_id,
      cust.cust_surname_company,
      cust.cust_initials,
      addr.adr_property_identification,
      --upper(ifnull(addr.adr_unit,'',addr.adr_unit+'/')+trim(addr.adr_no)), 
      rd.trim(addr.adr_no),
      upper(rd.trim(addr.adr_alpha)),
      rd.road_name + case when isnull(rt.rt_name,'')='' then '' else ' '+rt.rt_name end + case when isnull(rs.rs_name,'') = '' then '' else ' '+rs.rs_name end,
      sub.sl_name,
      addr.adr_rd_no,
      tc.tc_name,
     substring(mast.recip_char,3,len(mast.recip_char) - 2),
      (case when cust.cust_business = 'Y' then 'Business' else
        case when cust.cust_rural_farmer = 'Y' then 'Farmer' else
          case when cust.cust_rural_resident = 'Y' then 'Residential'
          end
        end
      end),(case when cust.cust_business = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
      (case when cust.cust_rural_resident = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
      (case when cust.cust_rural_farmer = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
      kiwimail_qty=cust.cust_adpost_quantity,
      0, -- cmb_seq
      addr.adr_unit from -- road_unit
      rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id 
      join address as addr on addr.adr_id = cam.adr_id
      left outer join suburblocality as sub on addr.sl_id = sub.sl_id
      join towncity as tc on addr.tc_id = tc.tc_id
      join road as rd on addr.road_id = rd.road_id
      left outer join road_type as rt on rd.rt_id = rt.rt_id
      left outer join road_suffix as rs on rd.rs_id = rs.rs_id ,
      #master_temp as mast where
      addr.tc_id = @town_id and
      cam.move_out_date is null and
      cust.master_cust_id is null and
      mast.master_num = cust.cust_id
  --and addr.adr_id = cam.adr_id 
  --and cust.cust_id = cam.cust_id
  --and tc.tc_id = addr.tc_id 
  --and rd.road_id = addr.road_id;
  -- insert the unoccupied entries into the table
  insert into #occ_temp(adr_id,
    prop_title,
    road_no,road_alpha,road_name,locality,rd_no,mail_town,
    business,residential,farmer,
    cmb_seq,road_unit)
    select distinct addr.adr_id,
      addr.adr_property_identification,
      --upper(ifnull(addr.adr_unit,'',addr.adr_unit+'/')+trim(addr.adr_no)), 
      rd.trim(addr.adr_no),
      upper(rd.trim(addr.adr_alpha)),
      rd.road_name+/*ifnull(rt.rt_name,'',' '+rt.rt_name)*/case when isnull(rt.rt_name,'') = '' then '' else ' '+rt.rt_name end
+/*ifnull(rs.rs_name,'',' '+rs.rs_name)*/case when isnull(rs.rs_name,'') = '' then '' else ' '+rs.rs_name end,
      sub.sl_name,
      addr.adr_rd_no,
      tc.tc_name,
      0, -- Business
      0, -- Resident
      0, -- Farmer 
      0, -- cmb_seq
      addr.adr_unit from -- road_unit
      address as addr left outer join suburblocality as sub on addr.sl_id = sub.sl_id
      join towncity as tc on addr.tc_id = tc.tc_id
      join road as rd on addr.road_id = rd.road_id
      left outer join road_type as rt on rd.rt_id = rt.rt_id
      left outer join road_suffix as rs on rd.rs_id = rs.rs_id where
      addr.tc_id = @town_id and
      not addr.adr_id = any(select occ.adr_id from #occ_temp as occ)
  --and addr.road_id = rd.road_id
  --and addr.tc_id = tc.tc_id;
  -- Get the total number of delivery points (excluding the CMBs)
   select @del_pt_count =count(distinct(adr_id))
    from #occ_temp
  -- insert the CMB entries into the table
  insert into #occ_temp(sur_comp_name,
    initials,
    road_no,
    rd_no,mail_town,
    categories,
    business,residential,farmer,
    kiwimail_qty,
    cmb_seq)
    select cmb.cmb_cust_surname,
      cmb.cmb_cust_initials,
      cmb.cmb_box_no,
      cmb.adr_rd_no,
      tc.tc_name,'CMB',
      0, -- Business
      0, -- Resident
      0, -- Farmer 
      (case when(cmb_cust_surname is null or cmb_cust_surname = '') and
      (cmb_cust_initials is null or cmb_cust_initials = '') then
        null else 1 end) as kiwimail_qty,
      row_number() over (order by cmb.adr_rd_no asc) from -- cmb_seq
      cmb_address as cmb ,
      towncity as tc where
      cmb.tc_id = @town_id and
      cmb.tc_id = tc.tc_id order by
      tc.tc_name asc,cmb.cmb_box_no asc
  -- Count the CMB customers
     select @cust_count_cmb = count(*)
    from cmb_address where
    tc_id = @town_id and
    ((cmb_cust_surname is not null and cmb_cust_surname <> '') or
    (cmb_cust_initials is not null and cmb_cust_initials <> ''))
  -- Calculate the total customer count
  select @cust_count=isnull(@cust_count_master,0)+isnull(@cust_count_cmb,0)
  -- Return the results
  select distinct sur_comp_name,
    initials,
    prop_title,
    road_no=right(space(20)+road_no,20),
    road_alpha,
    road_name,
    locality,
    rd_no,
    mail_town,
    recipients,
    categories,
    kiwimail_qty,
    business,
    residential,
    farmer,
    @cust_count,
    @del_pt_count,
    cmb_seq,
    road_unit=right(space(10)+road_unit,10) from
    #occ_temp
end


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_deed_compliance_cust : 
--

CREATE procedure [rd].[sp_deed_compliance_cust]
as
begin
  -- the table to hold address id''s and their standard frequencies
create table #cust_freq(
    cust_id integer null,
    sf_days_week integer null,
    region_id integer null,
    )
  declare
  @reg_id integer,
  -- private bag counts
  @pvt_one integer,
  @pvt_two integer,
  @pvt_three integer,
  @pvt_four integer,
  @pvt_five integer,
  @pvt_six integer,
  -- count figures national
  @one_nat integer,
  @two_nat integer,
  @three_nat integer,
  @four_nat integer,
  @five_nat integer,
  @six_nat integer,
  @total_nat integer,
  -- Christchurch
  @one_ch integer,
  @two_ch integer,
  @three_ch integer,
  @four_ch integer,
  @five_ch integer,
  @six_ch integer,
  @total_ch integer,
  -- Dunedin
  @one_dun integer,
  @two_dun integer,
  @three_dun integer,
  @four_dun integer,
  @five_dun integer,
  @six_dun integer,
  @total_dun integer,
  -- Hamilton
  @one_ham integer,
  @two_ham integer,
  @three_ham integer,
  @four_ham integer,
  @five_ham integer,
  @six_ham integer,
  @total_ham integer,
  -- Palmerston North
  @one_p integer,
  @two_p integer,
  @three_p integer,
  @four_p integer,
  @five_p integer,
  @six_p integer,
  @total_p integer,
  -- Rotorua
  @one_rot integer,
  @two_rot integer,
  @three_rot integer,
  @four_rot integer,
  @five_rot integer,
  @six_rot integer,
  @total_rot integer,
  -- Whangarei
  @one_w integer,
  @two_w integer,
  @three_w integer,
  @four_w integer,
  @five_w integer,
  @six_w integer,
  @total_w integer
  ------------------------------------------------------------------------
  insert into #cust_freq(sf_days_week,
    cust_id,region_id)
    select sum(sf.sf_days_week),cust.cust_id,tc.region_id from
      rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id 
      join address as addr on addr.adr_id = cam.adr_id
      join address_frequency_sequence on address_frequency_sequence.adr_id = addr.adr_id 
      join route_frequency on route_frequency.contract_no = addr.contract_no  
      join standard_frequency as sf on sf.sf_key =route_frequency.sf_key  ,towncity as tc
      where
      cust.master_cust_id is null and
      cam.move_out_date is null and
      addr.tc_id = tc.tc_id
      group by cust.cust_id,tc.region_id
  -- change so that max is 6
  update #cust_freq set
    sf_days_week = 6 where
    sf_days_week > 6
  ------------------------------------------------------------------------
  -----------------------------------------------------------------
  -- Christchurch
  select @reg_id=6
  select @one_ch = count(*)
    from #cust_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_ch = count(*)
    from #cust_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_ch = count(*)
    from #cust_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_ch = count(*)
    from #cust_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_ch = count(*)
    from #cust_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_ch = count(*)
    from #cust_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_ch = count(*)
    from #cust_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- Dunedin
  select @reg_id=7
  select @one_dun = count(*) 
    from #cust_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_dun = count(*)
    from #cust_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_dun = count(*)
    from #cust_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_dun = count(*)
    from #cust_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_dun = count(*)
    from #cust_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_dun = count(*)
    from #cust_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_dun = count(*)
    from #cust_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- Hamilton
  select @reg_id=2
  select @one_ham = count(*)
    from #cust_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_ham = count(*)
    from #cust_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_ham = count(*)
    from #cust_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_ham = count(*)
    from #cust_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_ham = count(*)
    from #cust_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_ham = count(*) 
    from #cust_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_ham = count(*) 
    from #cust_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- Palmerston North
  select @reg_id=4
  select @one_p = count(*) 
    from #cust_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_p = count(*) 
    from #cust_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_p = count(*) 
    from #cust_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_p = count(*) 
    from #cust_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_p = count(*) 
    from #cust_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_p = count(*) 
    from #cust_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_p = count(*) 
    from #cust_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- Rotorua
  select @reg_id=3
  select @one_rot = count(*) 
    from #cust_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_rot = count(*)
    from #cust_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_rot = count(*) 
    from #cust_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_rot = count(*) 
    from #cust_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_rot = count(*) 
    from #cust_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_rot = count(*) 
    from #cust_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_rot = count(*) 
    from #cust_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- Whangarei
  select @reg_id=1
  select @one_w = count(*) 
    from #cust_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_w = count(*) 
    from #cust_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_w = count(*) 
    from #cust_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_w = count(*) 
    from #cust_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_w = count(*) 
    from #cust_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_w = count(*) 
    from #cust_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_w = count(*) 
    from #cust_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- national
  -- do the same for the national
  select @one_nat = count(*) 
    from #cust_freq where
    sf_days_week = 1
  select @two_nat = count(*) 
    from #cust_freq where
    sf_days_week = 2
  select @three_nat = count(*) 
    from #cust_freq where
    sf_days_week = 3
  select @four_nat = count(*) 
    from #cust_freq where
    sf_days_week = 4
  select @five_nat = count(*) 
    from #cust_freq where
    sf_days_week = 5
  select @six_nat = count(*) 
    from #cust_freq where
    sf_days_week = 6
  select @total_nat = count(*) 
    from #cust_freq
  ----------------------------------------------------------------
  -- get latest private bag counts
  -- TJB SR4601 - Add region condition to date selection to get all
  --              Pvt Bags accross all regions.
  select @pvt_one = sum(pvt_bag_count) 
    from private_bags as pb1 where
    pvt_frequency = 1 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  -- select max(pvt_bag_count) 
  -- into pvt_one
  -- from private_bags
  -- where pvt_frequency = 1
  -- and pvt_date = (select max(pvt_date) from private_bags
  --                  where pvt_frequency = 1);
  select @pvt_two = sum(pvt_bag_count) 
    from private_bags as pb1 where
    pvt_frequency = 2 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_three = sum(pvt_bag_count) 
    from private_bags as pb1 where
    pvt_frequency = 3 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_four = sum(pvt_bag_count) 
    from private_bags as pb1 where
    pvt_frequency = 4 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_five = sum(pvt_bag_count) 
    from private_bags as pb1 where
    pvt_frequency = 5 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_six = sum(pvt_bag_count) 
    from private_bags as pb1 where
    pvt_frequency = 6 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  -- return all the individual results
  select @one_nat,@two_nat,@three_nat,@four_nat,@five_nat,@six_nat,@total_nat,@one_ch,@two_ch,@three_ch,@four_ch,@five_ch,@six_ch,@total_ch,
    @one_dun,@two_dun,@three_dun,@four_dun,@five_dun,@six_dun,@total_dun,@one_ham,@two_ham,@three_ham,@four_ham,@five_ham,@six_ham,@total_ham,
    @one_p,@two_p,@three_p,@four_p,@five_p,@six_p,@total_p,@one_rot,@two_rot,@three_rot,@four_rot,@five_rot,@six_rot,@total_rot,
    @one_w,@two_w,@three_w,@four_w,@five_w,@six_w,@total_w,@pvt_one,@pvt_two,@pvt_three,@pvt_four,@pvt_five,@pvt_six
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_deed_compliance_addr]
as
begin
  -- the table to hold address id''s and their standard frequencies
create table #addr_freq(
    adr_id integer null,
    sf_days_week integer null,
    region_id integer null,
    ) 
  declare
  @reg_id int,
  -- private bag counts
  @pvt_one int,
  @pvt_two int,
  @pvt_three int,
  @pvt_four int,
  @pvt_five int,
  @pvt_six int,
  -- count figures national
  @one_nat int,
  @two_nat int,
  @three_nat int,
  @four_nat int,
  @five_nat int,
  @six_nat int,
  @total_nat int,
  -- Christchurch
  @one_ch int,
  @two_ch int,
  @three_ch int,
  @four_ch int,
  @five_ch int,
  @six_ch int,
  @total_ch int,
  -- Dunedin
  @one_dun int,
  @two_dun int,
  @three_dun int,
  @four_dun int,
  @five_dun int,
  @six_dun int,
  @total_dun int,
  -- Hamilton
  @one_ham int,
  @two_ham int,
  @three_ham int,
  @four_ham int,
  @five_ham int,
  @six_ham int,
  @total_ham int,
  -- Palmerston North
  @one_p int,
  @two_p int,
  @three_p int,
  @four_p int,
  @five_p int,
  @six_p int,
  @total_p int,
  -- Rotorua
  @one_rot int,
  @two_rot int,
  @three_rot int,
  @four_rot int,
  @five_rot int,
  @six_rot int,
  @total_rot int,
  -- Whangarei
  @one_w int,
  @two_w int,
  @three_w int,
  @four_w int,
  @five_w int,
  @six_w int,
  @total_w int
  insert into #addr_freq(sf_days_week,
    adr_id,region_id)
    select sum(sf.sf_days_week),addr.adr_id,tc.region_id from
      towncity as tc join address as addr on tc.tc_id = addr.tc_id 
      join address_frequency_sequence on addr.adr_id =address_frequency_sequence.adr_id  
      join route_frequency on addr.contract_no = route_frequency.contract_no 
      join standard_frequency as sf on sf.sf_key = route_frequency.sf_key
      group by addr.adr_id, tc.region_id
  -- change so that max is 6
  update #addr_freq set
    sf_days_week = 6 where
    sf_days_week > 6
  -----------------------------------------------------------------
  -- Christchurch
  select @reg_id=6
  select @one_ch = count(*) 
    from #addr_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_ch = count(*)
    from #addr_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_ch = count(*)
    from #addr_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_ch = count(*)
    from #addr_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_ch = count(*) 
    from #addr_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_ch = count(*)
    from #addr_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_ch = count(*)
    from #addr_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- Dunedin
  select @reg_id=7
  select @one_dun = count(*)
    from #addr_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_dun = count(*)
    from #addr_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_dun = count(*)
    from #addr_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_dun = count(*)
    from #addr_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_dun = count(*)
    from #addr_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_dun = count(*) 
    from #addr_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_dun = count(*)
    from #addr_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- Hamilton
  select @reg_id=2
  select @one_ham = count(*)
    from #addr_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_ham = count(*) 
    from #addr_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_ham = count(*)
    from #addr_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_ham = count(*)
    from #addr_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_ham = count(*)
    from #addr_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_ham = count(*)
    from #addr_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_ham = count(*)
    from #addr_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- Palmerston North
  select @reg_id=4
  select @one_p = count(*)
    from #addr_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_p = count(*)
    from #addr_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_p = count(*)
    from #addr_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_p = count(*)
    from #addr_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_p = count(*)
    from #addr_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_p = count(*)
    from #addr_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_p = count(*)
    from #addr_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- Rotorua
  select @reg_id=3
  select @one_rot = count(*)
    from #addr_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_rot = count(*)
    from #addr_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_rot = count(*) 
    from #addr_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_rot = count(*)
    from #addr_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_rot = count(*) 
    from #addr_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_rot = count(*)
    from #addr_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_rot = count(*) 
    from #addr_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- Whangarei
  select @reg_id=1
  select @one_w = count(*)
    from #addr_freq where
    sf_days_week = 1 and
    region_id = @reg_id
  select @two_w = count(*)
    from #addr_freq where
    sf_days_week = 2 and
    region_id = @reg_id
  select @three_w = count(*) 
    from #addr_freq where
    sf_days_week = 3 and
    region_id = @reg_id
  select @four_w = count(*)
    from #addr_freq where
    sf_days_week = 4 and
    region_id = @reg_id
  select @five_w = count(*)
    from #addr_freq where
    sf_days_week = 5 and
    region_id = @reg_id
  select @six_w = count(*)
    from #addr_freq where
    sf_days_week = 6 and
    region_id = @reg_id
  select @total_w = count(*)
    from #addr_freq where
    region_id = @reg_id
  ----------------------------------------------------------------
  -- national
  -- do the same for the national
  select @one_nat = count(*) 
    from #addr_freq where
    sf_days_week = 1
  select @two_nat = count(*) 
    from #addr_freq where
    sf_days_week = 2
  select @three_nat = count(*) 
    from #addr_freq where
    sf_days_week = 3
  select @four_nat = count(*)
    from #addr_freq where
    sf_days_week = 4
  select @five_nat = count(*) 
    from #addr_freq where
    sf_days_week = 5
  select @six_nat = count(*)
    from #addr_freq where
    sf_days_week = 6
  select @total_nat = count(*)
    from #addr_freq
  ----------------------------------------------------------------
  -- get latest private bag counts
  -- TJB SR4601 - Add region condition to date selection to get all Pvt Bags
  --              accross all regions.
  select @pvt_one = sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 1 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  -- select max(pvt_bag_count) 
  -- into pvt_one
  -- from private_bags
  -- where pvt_frequency = 1
  -- and pvt_date = (select max(pvt_date) from private_bags
  --                  where pvt_frequency = 1);
  select @pvt_two = sum(pvt_bag_count) 
    from private_bags as pb1 where
    pvt_frequency = 2 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_three = sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 3 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_four = sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 4 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_five = sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 5 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_six = sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 6 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  -- return all the individual results
  select @one_nat,@two_nat,@three_nat,@four_nat,@five_nat,@six_nat,@total_nat,@one_ch,@two_ch,@three_ch,@four_ch,@five_ch,@six_ch,@total_ch,
    @one_dun,@two_dun,@three_dun,@four_dun,@five_dun,@six_dun,@total_dun,@one_ham,@two_ham,@three_ham,@four_ham,@five_ham,@six_ham,@total_ham,
    @one_p,@two_p,@three_p,@four_p,@five_p,@six_p,@total_p,@one_rot,@two_rot,@three_rot,@four_rot,@five_rot,@six_rot,@total_rot,
    @one_w,@two_w,@three_w,@four_w,@five_w,@six_w,@total_w,@pvt_one,@pvt_two,@pvt_three,@pvt_four,@pvt_five,@pvt_six
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_deed_compliance_occupied]
as
begin
  -- TJB  SR4676  Feb 2006    - New
  -- Collect address statistics similar to sp_deed_compliance_addr
  -- but filtered by whether the address is occupied or not.
  declare @reg_id integer
  -- private bag counts
  declare @pvt_one integer
  declare @pvt_two integer
  declare @pvt_three integer
  declare @pvt_four integer
  declare @pvt_five integer
  declare @pvt_six integer
  -- count figures national
  declare @one_nat integer
  declare @two_nat integer
  declare @three_nat integer
  declare @four_nat integer
  declare @five_nat integer
  declare @six_nat integer
  declare @total_nat integer
  -- Christchurch
  declare @one_ch integer
  declare @two_ch integer
  declare @three_ch integer
  declare @four_ch integer
  declare @five_ch integer
  declare @six_ch integer
  declare @total_ch integer
  -- Dunedin
  declare @one_dun integer
  declare @two_dun integer
  declare @three_dun integer
  declare @four_dun integer
  declare @five_dun integer
  declare @six_dun integer
  declare @total_dun integer
  -- Hamilton
  declare @one_ham integer
  declare @two_ham integer
  declare @three_ham integer
  declare @four_ham integer
  declare @five_ham integer
  declare @six_ham integer
  declare @total_ham integer
  -- Palmerston North
  declare @one_p integer
  declare @two_p integer
  declare @three_p integer
  declare @four_p integer
  declare @five_p integer
  declare @six_p integer
  declare @total_p integer
  -- Rotorua
  declare @one_rot integer
  declare @two_rot integer
  declare @three_rot integer
  declare @four_rot integer
  declare @five_rot integer
  declare @six_rot integer
  declare @total_rot integer
  -- Whangarei
  declare @one_w integer
  declare @two_w integer
  declare @three_w integer
  declare @four_w integer
  declare @five_w integer
  declare @six_w integer
  declare @total_w integer
  -- the table to hold address id''s and their standard frequencies
 
    create table #addr_occ_freq(
    adr_id integer null,
    sf_days_week integer null,
    region_id integer null,
    occupied char(1) null default 'N',
    )
	insert into #addr_occ_freq (sf_days_week,
    adr_id,region_id) select sum(sf.sf_days_week),addr.adr_id,tc.region_id from
      towncity as tc join address as addr on tc.tc_id=addr.tc_id join
      address_frequency_sequence on address_frequency_sequence.adr_id=addr.adr_id join
      route_frequency on route_frequency.sf_key=address_frequency_sequence.sf_key and route_frequency.rf_delivery_days=address_frequency_sequence.rf_delivery_days and route_frequency.contract_no=address_frequency_sequence.contract_no join
      standard_frequency as sf on route_frequency.sf_key=sf.sf_key  group by addr.adr_id,tc.region_id
  -- change so that max is 6
  update #addr_occ_freq set
    sf_days_week = 6 where
    sf_days_week > 6
  -- Flag the occupied addresses
  update #addr_occ_freq  set
    occupied = 'Y' from
    #addr_occ_freq as af,customer_address_moves as cam where
    af.adr_id = cam.adr_id and
    move_out_date is null
  -----------------------------------------------------------------
  -- Christchurch
  select @reg_id=6
  select @one_ch=count(*) 
    from #addr_occ_freq where
    sf_days_week = 1 and
    region_id = @reg_id and
    occupied = 'Y'
  select @two_ch=count(*) 
    from #addr_occ_freq where
    sf_days_week = 2 and
    region_id = @reg_id and
    occupied = 'Y'
  select @three_ch=count(*) 
    from #addr_occ_freq where
    sf_days_week = 3 and
    region_id = @reg_id and
    occupied = 'Y'
  select @four_ch=count(*) 
    from #addr_occ_freq where
    sf_days_week = 4 and
    region_id = @reg_id and
    occupied = 'Y'
  select @five_ch=count(*) 
    from #addr_occ_freq where
    sf_days_week = 5 and
    region_id = @reg_id and
    occupied = 'Y'
  select @six_ch=count(*) 
    from #addr_occ_freq where
    sf_days_week = 6 and
    region_id = @reg_id and
    occupied = 'Y'
  select @total_ch=count(*) 
    from #addr_occ_freq where
    region_id = @reg_id and
    occupied = 'Y'
  ----------------------------------------------------------------
  -- Dunedin
  select @reg_id=7
  select @one_dun=count(*) 
    from #addr_occ_freq where
    sf_days_week = 1 and
    region_id = @reg_id and
    occupied = 'Y'
  select @two_dun=count(*) 
    from #addr_occ_freq where
    sf_days_week = 2 and
    region_id = @reg_id and
    occupied = 'Y'
  select @three_dun=count(*) 
    from #addr_occ_freq where
    sf_days_week = 3 and
    region_id = @reg_id and
    occupied = 'Y'
  select @four_dun=count(*) 
    from #addr_occ_freq where
    sf_days_week = 4 and
    region_id = @reg_id and
    occupied = 'Y'
  select @five_dun=count(*) 
    from #addr_occ_freq where
    sf_days_week = 5 and
    region_id = @reg_id and
    occupied = 'Y'
  select @six_dun=count(*) 
    from #addr_occ_freq where
    sf_days_week = 6 and
    region_id = @reg_id and
    occupied = 'Y'
  select @total_dun=count(*) 
    from #addr_occ_freq where
    region_id = @reg_id and
    occupied = 'Y'
  ----------------------------------------------------------------
  -- Hamilton
  select @reg_id=2
  select @one_ham=count(*) 
    from #addr_occ_freq where
    sf_days_week = 1 and
    region_id = @reg_id and
    occupied = 'Y'
  select @two_ham=count(*) 
    from #addr_occ_freq where
    sf_days_week = 2 and
    region_id = @reg_id and
    occupied = 'Y'
  select @three_ham=count(*) 
    from #addr_occ_freq where
    sf_days_week = 3 and
    region_id = @reg_id and
    occupied = 'Y'
  select @four_ham=count(*)
    from #addr_occ_freq where
    sf_days_week = 4 and
    region_id = @reg_id and
    occupied = 'Y'
  select @five_ham=count(*)
    from #addr_occ_freq where
    sf_days_week = 5 and
    region_id = @reg_id and
    occupied = 'Y'
  select @six_ham=count(*)
    from #addr_occ_freq where
    sf_days_week = 6 and
    region_id = @reg_id and
    occupied = 'Y'
  select @total_ham=count(*)
    from #addr_occ_freq where
    region_id = @reg_id and
    occupied = 'Y'
  ----------------------------------------------------------------
  -- Palmerston North
  select @reg_id=4
  select @one_p=count(*)
    from #addr_occ_freq where
    sf_days_week = 1 and
    region_id = @reg_id and
    occupied = 'Y'
  select @two_p=count(*)
    from #addr_occ_freq where
    sf_days_week = 2 and
    region_id = @reg_id and
    occupied = 'Y'
  select @three_p=count(*)
    from #addr_occ_freq where
    sf_days_week = 3 and
    region_id = @reg_id and
    occupied = 'Y'
  select @four_p=count(*)
    from #addr_occ_freq where
    sf_days_week = 4 and
    region_id = @reg_id and
    occupied = 'Y'
  select @five_p=count(*)
    from #addr_occ_freq where
    sf_days_week = 5 and
    region_id = @reg_id and
    occupied = 'Y'
  select @six_p=count(*)
    from #addr_occ_freq where
    sf_days_week = 6 and
    region_id = @reg_id and
    occupied = 'Y'
  select @total_p=count(*)
    from #addr_occ_freq where
    region_id = @reg_id and
    occupied = 'Y'
  ----------------------------------------------------------------
  -- Rotorua
  select @reg_id=3
  select @one_rot=count(*)
    from #addr_occ_freq where
    sf_days_week = 1 and
    region_id = @reg_id and
    occupied = 'Y'
  select @two_rot=count(*)
    from #addr_occ_freq where
    sf_days_week = 2 and
    region_id = @reg_id and
    occupied = 'Y'
  select @three_rot=count(*)
    from #addr_occ_freq where
    sf_days_week = 3 and
    region_id = @reg_id and
    occupied = 'Y'
  select @four_rot=count(*)
    from #addr_occ_freq where
    sf_days_week = 4 and
    region_id = @reg_id and
    occupied = 'Y'
  select @five_rot=count(*)
    from #addr_occ_freq where
    sf_days_week = 5 and
    region_id = @reg_id and
    occupied = 'Y'
  select @six_rot=count(*)
    from #addr_occ_freq where
    sf_days_week = 6 and
    region_id = @reg_id and
    occupied = 'Y'
  select @total_rot=count(*)
    from #addr_occ_freq where
    region_id = @reg_id and
    occupied = 'Y'
  ----------------------------------------------------------------
  -- Whangarei
  select @reg_id=1
  select @one_w=count(*)
    from #addr_occ_freq where
    sf_days_week = 1 and
    region_id = @reg_id and
    occupied = 'Y'
  select @two_w=count(*)
    from #addr_occ_freq where
    sf_days_week = 2 and
    region_id = @reg_id and
    occupied = 'Y'
  select @three_w=count(*)
    from #addr_occ_freq where
    sf_days_week = 3 and
    region_id = @reg_id and
    occupied = 'Y'
  select @four_w=count(*)
    from #addr_occ_freq where
    sf_days_week = 4 and
    region_id = @reg_id and
    occupied = 'Y'
  select @five_w=count(*)
    from #addr_occ_freq where
    sf_days_week = 5 and
    region_id = @reg_id and
    occupied = 'Y'
  select @six_w=count(*)
    from #addr_occ_freq where
    sf_days_week = 6 and
    region_id = @reg_id and
    occupied = 'Y'
  select @total_w=count(*)
    from #addr_occ_freq where
    region_id = @reg_id and
    occupied = 'Y'
  ----------------------------------------------------------------
  -- national
  -- do the same for the national
  select @one_nat=count(*)
    from #addr_occ_freq where
    sf_days_week = 1 and
    occupied = 'Y'
  select @two_nat=count(*)
    from #addr_occ_freq where
    sf_days_week = 2 and
    occupied = 'Y'
  select @three_nat=count(*)
    from #addr_occ_freq where
    sf_days_week = 3 and
    occupied = 'Y'
  select @four_nat=count(*)
    from #addr_occ_freq where
    sf_days_week = 4 and
    occupied = 'Y'
  select @five_nat=count(*)
    from #addr_occ_freq where
    sf_days_week = 5 and
    occupied = 'Y'
  select @six_nat=count(*)
    from #addr_occ_freq where
    sf_days_week = 6 and
    occupied = 'Y'
  select @total_nat=count(*)
    from #addr_occ_freq where
    occupied = 'Y'
  ----------------------------------------------------------------
  -- get latest private bag counts
  -- TJB SR4601 - Add region condition to date selection to get all Pvt Bags
  --              accross all regions.
  select @pvt_one=sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 1 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  -- select max(pvt_bag_count)
  -- into pvt_one
  -- from private_bags
  -- where pvt_frequency = 1
  -- and pvt_date = (select max(pvt_date) from private_bags
  --                  where pvt_frequency = 1);
  select @pvt_two=sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 2 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_three=sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 3 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_four=sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 4 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_five=sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 5 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  select @pvt_six=sum(pvt_bag_count)
    from private_bags as pb1 where
    pvt_frequency = 6 and
    pvt_date = (select max(pvt_date) from private_bags as pb2 where
      pb2.pvt_frequency = pb1.pvt_frequency and
      pb2.region_id = pb1.region_id)
  -- return all the individual results
  select @one_nat,@two_nat,@three_nat,@four_nat,@five_nat,@six_nat,@total_nat,
    @one_ch,@two_ch,@three_ch,@four_ch,@five_ch,@six_ch,@total_ch,
    @one_dun,@two_dun,@three_dun,@four_dun,@five_dun,@six_dun,@total_dun,
    @one_ham,@two_ham,@three_ham,@four_ham,@five_ham,@six_ham,@total_ham,
    @one_p,@two_p,@three_p,@four_p,@five_p,@six_p,@total_p,
    @one_rot,@two_rot,@three_rot,@four_rot,@five_rot,@six_rot,@total_rot,
    @one_w,@two_w,@three_w,@four_w,@five_w,@six_w,@total_w,
    @pvt_one,@pvt_two,@pvt_three,@pvt_four,@pvt_five,@pvt_six
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure f_getNextSequence : 
--

CREATE procedure  [rd].[f_getNextSequence](@sequencename char(20),@update_flag int,@wrapValue int)
/******************************************************************
* Description
*    This function returns the next ID value from the id_codes table.
*
* Parameters
*    sequencename  - The name of the ID
*    update_flag   - 1 = update the table to the next value
*                    0 = just return the current value
*    wrapValue     - Wrap value: reset to 1 at this value
*
* Returns
*    Current next_value value for the named sequence
*    -1   if error (eg sequencename not found)
*
* System
*    NPAD2 - NZ Post
*
* Author
*    Tom Britton, Synergy International
*
* Created on
*    November 2005
*
* Modification history
* 10 Apr 2006  TJB  Added 3rd parameter: wrap value
* 19 May 2006  TJB  Added table lock
*
*****************************************************************/

as
begin
  declare @nextValue int
  declare @newValue int
set nocount on
  /* Watcom only
  lock table rd.id_codes in exclusive mode
  */
BEGIN TRANSACTION
  select @nextValue = next_value from
    rd.id_codes where
    sequence_name = @sequencename
  if @@error <> 0
    begin 
      -- Some error including sequencename doesn''t exist
      rollback tran
      return(-1)
    end
  if @update_flag = 1
    begin
      select @newValue=@nextValue+1
      if @wrapValue > 0 and @newValue >= @wrapValue
        select @newValue=1
      update id_codes set
        next_value = @newValue where
        sequence_name = @sequencename
      if @@error <> 0
        begin
          rollback transaction
          return(-1)
        end
    end
  commit tran
  return(@nextValue)
end





set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_BLF_GetNextSequence : 
--

CREATE procedure [odps].[OD_BLF_GetNextSequence](@sequencename varchar(20))
as
begin
  declare @nNextValue int
  declare @rowcnt int
  declare @err    int
  select @nNextValue = next_value 
    from rd.id_codes where
    sequence_name = @sequencename
  select @rowcnt=@@rowcount,@err=@@error
  if @err <> 0
    return(-1)
  if @rowcnt = 0
    begin
      insert into rd.id_codes(sequence_name,
        next_value) values(@sequencename,2)
      if @@ROWCOUNT = 0
        return(-1)
      return(1)
    end
  else
    begin
      update rd.id_codes set
        next_value = @nNextValue+1 where
        sequence_name = @sequencename
      if @@ROWCOUNT = 0
        return(-1)
      return (@nNextValue)
    end
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function GetContractDistance : 
--

CREATE function [rd].[GetContractDistance](
@inContract int,
@inSequence int)
returns decimal(10,2)
as
begin
  declare @nReturn decimal(10,2)
  select @nReturn=sum(route_frequency.rf_distance*rate_days.rtd_days_per_annum) 
    from route_frequency join
    rate_days on
    route_frequency.sf_key = rate_days.sf_key join
    contract_renewals on
    route_frequency.contract_no = contract_renewals.contract_no and
    contract_seq_number = @inSequence where
    route_frequency.contract_no = @inContract and
    route_frequency.rf_active = 'Y' and
    rate_days.rg_code = contract_renewals.con_rg_code_at_renewal and
    rate_days.rr_rates_effective_date = contract_renewals.con_rates_effective_date
  return @nReturn
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for view v_Customers : 
--

--
-- Definition for stored procedure anzac_fix : 
--

CREATE procedure -- Tim Chan
-- Initial version : 21/11/2003
-- This function update the rate_days of contracts and create the corresponding frequency adjustment
-- according to the benchmark change amount
[rd].[anzac_fix](@days_to_makeup real,@in_rg_code int)

as
begin
  declare @return_val integer
  declare @latest_rate_date datetime
  declare @effective_date datetime
  declare @sf_key1 int
  declare @sf_key2 int
  declare @old_rate_days real
  declare @multiplier real
  -- temp table for holding contract numbers seq and distances etc before any changes
  -- temp table for holding max unique seq numbers for entry into the frequency_adjustments table
  create table #con_temp (
    contract_no int null,
    contract_seq int null,
    old_benchmark int null,
    new_benchmark int null,
    "difference" int null,
    )

    create table #uniq_temp(
    contract_no int null,
    max_unique_seq int null,
    )
  -- kill this function if the date is not within 2003 (this function expires at the end of 2003)
  if datepart(year,getdate()) <> 2003
    return-1
  -- set the effective_date
  if @in_rg_code = 2
    select @effective_date='2003-08-01' else
  if @in_rg_code = 3
    select @effective_date='2003-11-01'
  select @sf_key1=1
  select @sf_key2=8
  insert into #con_temp 
    select con.contract_no,con.con_active_sequence,rd.BenchmarkCalc2001(con.contract_no,con.con_active_sequence),0,0 from 
      "contract" as con join route_frequency as rf on con.contract_no=rf.contract_no where
      con.con_date_terminated is null and
      con.rg_code = @in_rg_code and
      rf.rf_active = 'Y' and
      rf.rf_distance > 0 and
      rf.sf_key in(1,8)
      group by con.contract_no,con.con_active_sequence
  insert into uniq_temp
    select fa.contract_no,max(fd_unique_seq_number)+1 from
      con_temp as ct,frequency_adjustments as fa where
      ct.contract_no = fa.contract_no and
      ct.contract_seq = fa.contract_seq_number
      group by fa.contract_no
  -- set the unique seq as 1 if was not in uniq_temp already
  insert into uniq_temp
    select ct.contract_no,1 from
      con_temp as ct where
      not ct.contract_no = any(select contract_no from uniq_temp)
  select @latest_rate_date=max(rr_rates_effective_date) 
    from rate_days where
    rg_code = @in_rg_code and
    sf_key = @sf_key1
  -- save the old rate days count
  select @old_rate_days=max(rtd_days_per_annum) 
    from rate_days where
    rg_code = @in_rg_code and
    sf_key = @sf_key1 and
    rr_rates_effective_date = @latest_rate_date
  -- do update of rate_days
  update rate_days set
    rtd_days_per_annum = rtd_days_per_annum+@days_to_makeup where
    rg_code = @in_rg_code and
    sf_key = @sf_key1 and
    rr_rates_effective_date = @latest_rate_date
  -- do it all again if sf_key2 is non - zero
  if @sf_key2 > 0
    begin
      select @latest_rate_date=max(rr_rates_effective_date) 
        from rate_days where
        rg_code = @in_rg_code and
        sf_key = @sf_key2
      -- do update of rate_days
      update rate_days set
        rtd_days_per_annum = rtd_days_per_annum+@days_to_makeup where
        rg_code = @in_rg_code and
        sf_key = @sf_key2 and
        rr_rates_effective_date = @latest_rate_date
    end
  select @multiplier=(@days_to_makeup+@old_rate_days)/@old_rate_days
  -- update the contract renewals - renewal distances
  update contract_renewals set
    con_distance_at_renewal = round((con_distance_at_renewal*@multiplier)+.49,0) where
    contract_no = any(select con_temp.contract_no from con_temp) and
    contract_seq_number = any(select contract.con_active_sequence from contract where contract.contract_no = contract_renewals.contract_no)
  -- figure out benchmark change
  update con_temp set
    new_benchmark = rd.BenchmarkCalc2001(contract_no,contract_seq)
  update con_temp set
    difference = new_benchmark-old_benchmark
  -- for each row where there is a difference - create an adjustment
  insert into frequency_adjustments
    --(contract_no, contract_seq_number, fd_unique_seq_number, fd_adjustment_amount, fd_paid_to_date, fd_bm_after_extn,
    --fd_confirmed, fd_amount_to_pay, fd_effective_date)
    --values
    select ct.contract_no,ct.contract_seq,ut.max_unique_seq,ct.difference,null,ct.new_benchmark,'Y',
      ct.difference,@effective_date,null from
      con_temp as ct,uniq_temp as ut where
      ct.difference <> 0 and
      ct.contract_no = ut.contract_no
  return 1
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRouteFrequency : 
--

CREATE procedure [rd].[sp_GetRouteFrequency](@in_Contract int)
as
begin
  select contract_no,
    sf_key,
    rf_delivery_days,
    rf_active,
    rf_monday=substring(rf_delivery_days,1,1),
    rf_tuesday=substring(rf_delivery_days,2,1),
    rf_wednesday=substring(rf_delivery_days,3,1),
    rf_thursday=substring(rf_delivery_days,4,1),
    rf_friday=substring(rf_delivery_days,5,1),
    rf_saturday=substring(rf_delivery_days,6,1),
    rf_sunday=substring(rf_delivery_days,7,1),
    rf_distance from
    route_frequency where
    contract_no = @in_Contract
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Route_Frequency : 
--

CREATE procedure [rd].[sp_Route_Frequency](@in_Contract int)
as
begin
  select contract_no,
    sf_key,
    rf_delivery_days,
    rf_active,
    rf_monday=substring(rf_delivery_days,1,1),
    rf_tuesday=substring(rf_delivery_days,2,1),
    rf_wednesday=substring(rf_delivery_days,3,1),
    rf_thursday=substring(rf_delivery_days,4,1),
    rf_friday=substring(rf_delivery_days,5,1),
    rf_saturday=substring(rf_delivery_days,6,1),
    rf_sunday=substring(rf_delivery_days,7,1),
    rf_distance from
    route_frequency where
    contract_no = @in_Contract
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Extension_RFDistance : 
--

CREATE procedure [rd].[sp_Extension_RFDistance](@inContract int,@inKey int,@indays char(100))
as
begin
  select rf_distance from
    route_frequency where
    contract_no = @inContract and
    sf_key = @inkey and
    rf_delivery_days = @indays
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_Routefreq_new : 
--

CREATE procedure [rd].[sp_DDDW_Routefreq_new](@cno int,@sfk int)
as
begin
  select route_frequency.contract_no,
    route_frequency.sf_key,
    route_frequency.rf_delivery_days from
    route_frequency where
    (route_frequency.rf_active = 'Y') and
    ((route_frequency.contract_no = @cno and @cno is not null and @cno > -1) or
    (1 = 1 and @cno = -1)) and
    ((route_frequency.sf_key = @sfk and @sfk is not null and @sfk > -1) or
    (@sfk = -1))
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_GetArticalCount] @in_Contract INT 

AS
begin
   select   contract_no ,ac_start_week_period ,contract_seq_number,ac_w1_medium_letters ,
   ac_w1_other_envelopes ,
   ac_w1_small_parcels ,ac_w1_large_parcels ,
   ac_w1_inward_mail ,ac_scale_factor from
   rd.artical_count where
   contract_no = @in_Contract order by ac_start_week_period asc
end







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_contract_voldetails : 
--

CREATE procedure [rd].[sp_contract_voldetails](
@inContract int,
@inSequence int)
as
begin
  -- TJB  SR4684  June 2006
  -- Removed Large Parcels from totals calculations
  declare @StartDate datetime

CREATE TABLE #tmp_articals(
    sortorder integer null,
    description char(20) null,
    dispdecs char(1) null,
    displine char(1) null,
    medium_env decimal(10,2) null,
    other_env decimal(10,2) null,
    small_par decimal(10,2) null,
    large_par decimal(10,2) null,
    total_vol decimal(10,2) null,
    )

  select @startdate = max(ac_start_week_period)
    from artical_count where
    contract_no = @inContract
  insert into #tmp_articals
    select sortorder=10,description='Latest Mail Count',dispdecs='N',displine='N',
      medium=round((isNull(ac_w1_medium_letters,0)+
      isNull(ac_w2_medium_letters,0))*
      isNull(ac_scale_factor,0),0),
      other_env=round((isNull(ac_w1_other_envelopes,0)+
      isNull(ac_w2_other_envelopes,0))*
      isNull(ac_scale_factor,0),0),
      small_par=round((isNull(ac_w1_small_parcels,0)+
      isNull(ac_w2_small_parcels,0))*
      isNull(ac_scale_factor,0),0),
      large_par=round((isNull(ac_w1_large_parcels,0)+
      isNull(ac_w2_large_parcels,0))*
      isNull(ac_scale_factor,0),0),
      -- medium + other_env + small_par + large_par           as total_vol
      total_vol=round((isNull(ac_w1_medium_letters,0)+
      isNull(ac_w2_medium_letters,0))*
      isNull(ac_scale_factor,0),0)
		       +round((isNull(ac_w1_other_envelopes,0)+
      isNull(ac_w2_other_envelopes,0))*
      isNull(ac_scale_factor,0),0)
			+round((isNull(ac_w1_small_parcels,0)+
      isNull(ac_w2_small_parcels,0))*
      isNull(ac_scale_factor,0),0) 
from
      artical_count where
      contract_no = @inContract and
      ac_start_week_period = @startdate
  -- union 
  insert into #tmp_articals
    select sortorder=20,description='Previous Mail Count',dispdecs='N',displine='N',
      medium=round((isNull(ac_w1_medium_letters,0)+
      isNull(ac_w2_medium_letters,0))*
      isNull(ac_scale_factor,0),0),
      other_env=round((isNull(ac_w1_other_envelopes,0)+
      isNull(ac_w2_other_envelopes,0))*
      isNull(ac_scale_factor,0),0),
      small_par=round((isNull(ac_w1_small_parcels,0)+
      isNull(ac_w2_small_parcels,0))*
      isNull(ac_scale_factor,0),0),
      large_par=round((isNull(ac_w1_large_parcels,0)+
      isNull(ac_w2_large_parcels,0))*
      isNull(ac_scale_factor,0),0),
      -- medium + other_env + small_par + large_par           as total_vol
      total_vol=round((isNull(ac_w1_medium_letters,0)+
      isNull(ac_w2_medium_letters,0))*
      isNull(ac_scale_factor,0),0)
				+round((isNull(ac_w1_other_envelopes,0)+
      isNull(ac_w2_other_envelopes,0))*
      isNull(ac_scale_factor,0),0)
				+round((isNull(ac_w1_small_parcels,0)+
      isNull(ac_w2_small_parcels,0))*
      isNull(ac_scale_factor,0),0)
 from
      artical_count as ac1 where
      contract_no = @inContract and
      ac_start_week_period = (select max(ac2.ac_start_week_period) from
        artical_count as ac2 where
        ac2.contract_no = ac1.contract_no and
        ac2.ac_start_week_period < @StartDate)
  insert into #tmp_articals
    select 30,'Variance','N','Y',
      isnull((select medium_env from #tmp_articals where sortorder = 10),0)-
      isnull((select medium_env from #tmp_articals where sortorder = 20),0),
      isnull((select other_env from #tmp_articals where sortorder = 10),0)-
      isnull((select other_env from #tmp_articals where sortorder = 20),0),
      isnull((select small_par from #tmp_articals where sortorder = 10),0)-
      isnull((select small_par from #tmp_articals where sortorder = 20),0),
      isnull((select large_par from #tmp_articals where sortorder = 10),0)-
      isnull((select large_par from #tmp_articals where sortorder = 20),0),
      isnull((select total_vol from #tmp_articals where sortorder = 10),0)-
      isnull((select total_vol from #tmp_articals where sortorder = 20),0) 
  insert into #tmp_articals
    select 40,'Variance (%)','Y','N',
      case when isnull((select medium_env from #tmp_articals where sortorder = 20),0) = 0 then
        0
      else isnull((select medium_env from #tmp_articals where sortorder = 30),0)/
        (select medium_env from #tmp_articals where sortorder = 20)*100
      end,
      case when isnull((select other_env from #tmp_articals where sortorder = 20),0) = 0 then
        0
      else isnull((select other_env from #tmp_articals where sortorder = 30),0)/
        (select other_env from #tmp_articals where sortorder = 20)*100
      end,
      case when isnull((select small_par from #tmp_articals where sortorder = 20),0) = 0 then
        0
      else isnull((select small_par from #tmp_articals where sortorder = 30),0)/
        (select small_par from #tmp_articals where sortorder = 20)*100
      end,
      case when isnull((select large_par from #tmp_articals where sortorder = 20),0) = 0 then
        0
      else isnull((select large_par from #tmp_articals where sortorder = 30),0)/
        (select large_par from #tmp_articals where sortorder = 20)*100
      end,
      case when isnull((select total_vol from #tmp_articals where sortorder = 20),0) = 0 then
        0
      else isnull((select total_vol from #tmp_articals where sortorder = 30),0)/
        (select total_vol from #tmp_articals where sortorder = 20)*100
      end 
  select* from #tmp_articals order by
    sortorder asc
end












	
  


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRawArticalCounts : 
--

CREATE procedure [rd].[sp_GetRawArticalCounts](
@in_Contract int,
@in_WeekPeriod int)
as
begin
  select contract_no,
    ac_start_week_period,
    ac_w1_medium_letters,
    ac_w1_other_envelopes,
    ac_w1_small_parcels,
    ac_w1_large_parcels,
    ac_w1_inward_mail,
    ac_w2_medium_letters,
    ac_w2_other_envelopes,
    ac_w2_small_parcels,
    ac_w2_large_parcels,
    ac_w2_inward_mail from
    artical_count where
    contract_no = @in_Contract and
    ac_start_week_period = @in_WeekPeriod
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractArtCnts : 
--

--
-- Definition for stored procedure sp_GetContractArtCnts : 
--

CREATE procedure [rd].[sp_GetContractArtCnts](@in_Contract int)
as
begin
  declare @maxcust integer
  /*  select max(customer.cust_rd_number) into maxcust
  from customer where
  customer.contract_no = in_Contract; */
  select artical_count.contract_no,
    artical_count.contract_seq_number,
    artical_count.ac_start_week_period,
    artical_count.ac_w1_medium_letters,
    artical_count.ac_w1_other_envelopes,
    artical_count.ac_w1_small_parcels,
    artical_count.ac_w1_large_parcels,
    artical_count.ac_w1_inward_mail,
    artical_count.ac_w2_medium_letters,
    artical_count.ac_w2_other_envelopes,
    artical_count.ac_w2_small_parcels,
    artical_count.ac_w2_large_parcels,
    artical_count.ac_w2_inward_mail,
    artical_count.ac_scale_factor,
    @maxcust from
    artical_count where
    artical_count.contract_no = @in_Contract order by
    artical_count.ac_start_week_period desc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_contract_renewals : 
--

CREATE procedure [rd].[sp_DDDW_contract_renewals](@contractno int)
as
begin select contract_seq_number,sdate='Renewal '+convert(varchar(20),contract_seq_number),con_start_date from contract_renewals where((contract_no = @contractno and @contractno is not null and @contractno <> -1)) order by 2 asc end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_ContractSummaryList : 
--

CREATE procedure [rd].[sp_ContractSummaryList](@inContract int,@inSequence int,@indate datetime)
as
begin
  declare @outdate datetime
  select @outdate=@indate
  select contract_renewals.contract_no,
    contract_renewals.contract_seq_number,@outdate from
    rd.contract_renewals where
    (contract_renewals.contract_no = @incontract) and
    (contract_renewals.contract_seq_number = @insequence)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRenewal : 
--

CREATE procedure [rd].[sp_GetRenewal](
@in_ContractNo int,
@in_ContractSeq int)
as
begin
  select contract_no,
    contract_seq_number,
    con_start_date,
    con_rates_effective_date,
    con_rg_code_at_renewal,
    con_expiry_date,
    con_start_pay_date,
    con_last_paid_date,
    con_processing_hours_per_week,
    con_renewal_benchmark_price,
    con_renewal_payment_value,
    con_relief_driver_name,
    con_relief_driver_address,
    con_relief_driver_home_phone,
    con_date_last_assigned,
    con_acceptance_flag,
    con_volume_at_renewal,
    con_del_hrs_week_at_renewal,
    con_distance_at_renewal,
    con_no_customers_at_renewal,
    con_no_rural_private_bags_at_renewal,
    con_no_other_bags_at_renewal,
    con_no_private_bags_at_renewal,
    con_no_post_offices_at_renewal,
    con_no_cmbs_at_renewal,
    con_no_cmb_custs_at_renewal from
    contract_renewals where
    (contract_no = @in_ContractNo) and
    (contract_seq_number = @in_ContractSeq)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRenewalListing : 
--

CREATE procedure [rd].[sp_GetRenewalListing](@in_Contract int)
as
begin
  select contract_seq_number from
    contract_renewals where
    contract_no = @in_Contract order by contract_seq_number desc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_interest : 
--

CREATE procedure [rd].[sp_interest]
as
begin
  select interest.interest_id,
    interest.interest_description from
    interest order by
    interest.interest_description asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_interest_list : 
--

CREATE procedure -- Tim Chan 24/03/2003
-- This is a new procedure written as part of the resolution to service request 4474_01
-- 
[rd].[sp_interest_list]
as
begin
  select interest.interest_description,interest.interest_id from
    interest order by
    interest.interest_description asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_v_exp_region : 
--

CREATE procedure [rd].[sp_v_exp_region](@reg_id int)
as
begin
  declare @month_6 datetime,
  @count_final int
  -- table to hold end results and allow the filtering of results
  -- first create a temporary table for unique contract_vehicle
  -- temp table for max renewals
  create table #final_temp(
    reg_name char(40) null,
    expiry datetime null,
    con_num integer null,
    rego char(8) null,
    vmake char(20) null,
    vmodel char(20) null,
    vyear smallint null,
    vdesc char(30) null,
    vfuel char(35) null,
    ) 
create table #cv_temp(
    v_num integer null,
    c_num integer null,
    start_num integer null,
    seq_no integer null,
    dist_renew numeric(10,2) null,
    ) 
create table #cr_temp(
    c_num integer null,
    cd_num numeric(10,2) null,
    ) 
create table #con_temp(
    contract_no integer null,
    active_seq integer null,
    ) 
create table #veh_min_temp(
    contract_no integer null,
    veh_seq integer null,
    )
insert into #con_temp(contract_no,active_seq)
select distinct(con.contract_no),con.con_active_sequence 
from
  contract_renewals as cr join contract as con
on cr.contract_no = con.contract_no
join outlet as outl
on(con.con_lodgement_office = outl.outlet_id),
types_for_contract as tfc
 where
      (@reg_id is null or @reg_id = 0 or outl.region_id = @reg_id) and
      con.contract_no = tfc.contract_no and
      con.con_base_cont_type = 1 and
      tfc.ct_key = 1 and
      cr.con_expiry_date > rd.today()
  insert into #veh_min_temp(contract_no,
    veh_seq)
    select cv.contract_no,min(contract_seq_number) from
      contract_vehical as cv,#con_temp as con where
      cv.contract_no = con.contract_no and
      cv.vehicle_number = rd.f_GetLatestConVehicle(cv.contract_no)
      group by cv.contract_no
  insert into #cv_temp(v_num,
    c_num,start_num,dist_renew)
    select distinct(cv.vehicle_number),cv.contract_no,min(cv.start_kms),max(cr.con_distance_at_renewal) from
      contract_vehical as cv,contract_renewals as cr,#con_temp as con,#veh_min_temp as vmt where
      con.contract_no = vmt.contract_no and
      cv.contract_no = con.contract_no and
      cv.contract_no = cr.contract_no and
      cv.contract_seq_number = vmt.veh_seq and
      cv.vehicle_number = rd.f_GetLatestConVehicle(cv.contract_no) and
      cr.contract_seq_number = vmt.veh_seq
      group by cv.vehicle_number,cv.contract_no,cv.start_kms,cr.con_distance_at_renewal
  -- set any milages over 200000 to limit of 200000
  update #cv_temp set
    start_num = 200000 where
    start_num > 200000
  insert into #final_temp(expiry,
    con_num,rego,vmake,vmodel,vyear,vdesc,vfuel,reg_name)
    select distinct  expiry=(
case when cv.start_num > 5000 and cv.start_num is not null then
 rd.date(dateadd(day,(((200000-cv.start_num)/cv.dist_renew)*365),v.v_purchased_date))
else 
rd.date(dateadd(day,((200000/cv.dist_renew)*365),v.v_purchased_date))end),
      con.contract_no,v.v_vehicle_registration_number,
      v.v_vehicle_make,v.v_vehicle_model,v.v_vehicle_year,vs.vs_description,ft.ft_description,reg.rgn_name 
from
      vehicle as v left outer join fuel_type as ft on v.ft_key = ft.ft_key,
      #con_temp as con,vehicle_style as vs,#cv_temp as cv,
      contract as cont join outlet as outl on cont.con_base_office = outl.outlet_id
      join region as reg  on outl.region_id = reg.region_id
where
      cv.c_num = con.contract_no and
      v.vehicle_number = cv.v_num and
      v.v_purchased_date is not null and
      vs.vs_key = v.vs_key and
      v.vs_key not in(3,8,12,16,15) and
      cont.contract_no = con.contract_no order by
      expiry asc
  -- get the date 6 months ago
  select @month_6=dateadd(month,6,rd.today())
  -- get rid of entries where the expiry is more than 6 months in the future
  delete from #final_temp where
    expiry > @month_6
  -- get count of final_temp
  select @count_final=count(*) 
    from #final_temp
  if @count_final = 0
    insert into #final_temp(reg_name,
      vmodel)
      select rgn_name,'0 Vehicles' from
        region where
        region_id = @reg_id
  select max(expiry),con_num,rego,vmake,vmodel,vyear,vdesc,vfuel,reg_name,@month_6 from
    #final_temp
    group by reg_name,con_num,rego,vmake,vmodel,vyear,vdesc,vfuel order by
    reg_name asc,max(expiry) asc,con_num asc,rego asc
end






GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_cust_list_con_export]
-- TJB  SR4683  Aug 2006
-- Change customer category counts to use the Kiwimail number at an address
--
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added adr_unit number and road_suffix to relevant parts of address returned
--
-- TJB  SR4659  July 2005
-- Added section for CMB numbers and cmb_seq return value
as --
begin
  declare
  /* Watcom only
  err_notfound exception for sqlstate value '02000'
  ,*/
  @rec_tmp char(200),
  @cust_tmp integer,
  @master_tmp char(200),
  @cust_count_master integer,
  @cust_count_recip integer,
  @cust_count_cmb integer,
  @cust_count integer,
  @blank_space char(40),
  @del_pt_count integer,
  @get_recip integer
  -- temp table for the all occupied addresses
  create
    table #occ_temp(
    contract_no integer null,
    con_title char(60) null,
    adr_id integer null,
    sur_comp_name char(45) null,
    initials char(30) null,
    prop_title char(100) null,
    road_no char(20) null,
    road_alpha char(20) null,
    road_name char(61) null,
    locality char(50) null,
    rd_no char(40) null,
    mail_town char(50) null,
    recipients char(200) null,
    categories char(15) null,
    kiwimail_qty integer null,
    business integer null,
    residential integer null,
    farmer integer null,
    cust_counter integer null,
    cmb_seq integer null,
    )
  
  -- first create a temporary table for recipients at an address
  create
    table #master_temp(
    master_num integer null,
    recip_char nvarchar(200) null,
    ) 
  
  create
    table #recipient_temp(
    recip_num integer null,
    recip_char_b char(200) null,
    ) 
  -- TJB Sept 2005  Replaced the cursor - see below
  --  declare recipient_list dynamic scroll cursor for 
  --            select recip.recip_num, recip.recip_char_b
  --              from recipient_temp recip;
  --
  --  declare iRecip_num integer;
  --  declare cRecip_char char(200);
  --  declare cAdd  char(200);
  -- get all master cust_id''s first
  insert into #master_temp(master_num)
    select distinct(cust.cust_id) from
      rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id
      join address as addr on addr.adr_id = cam.adr_id where
      addr.contract_no = any(select rds_id from rds_temp) and -- get contract numbers from the temp table
      cam.move_out_date is null and
      cust.master_cust_id is null
  --and cam.adr_id = addr.adr_id
  --and cust.cust_id = cam.cust_id;
  -- don''t do anything if there is no need for recipients
  select @get_recip = sum(rds_code)  
    from rds_temp
  if @get_recip > 0
    begin
      -- get all recipients names       
      insert into #recipient_temp(recip_num,recip_char_b)
        select cust.master_cust_id,', '+
          rd.trim(isnull(cust.cust_surname_company,'')+' '+isnull(cust.cust_initials,'')) from
          rds_customer as cust where
          cust.master_cust_id = any(select tmp.master_num from #master_temp as tmp) and
          (cust.cust_surname_company is not null or cust.cust_initials is not null) and
          (len(cust.cust_surname_company) > 0 or len(cust.cust_initials) > 0)
      -- TJB Sept 2005 
      -- Add recipients to master list
      -- This replaces the cursor and speeds the procedure up considerably!
      update #master_temp set
        #master_temp.recip_char = ISNULL(#master_temp.recip_char,'')+#recipient_temp.recip_char_b from
        #recipient_temp where
        #master_temp.master_num = #recipient_temp.recip_num
    end
  ------------- cursor attempt
  --    set iRecip_num=0;
  --    set cRecip_char='';
  --  
  --    open recipient_list;
  --    CursorLoop: loop
  --      fetch next recipient_list into iRecip_num, cRecip_char;
  --      if sqlstate=err_notfound then
  --        leave CursorLoop
  --      end if;
  --    
  --      set cAdd = '';  
  --      
  --      -- get original char value
  --      select mast.recip_char 
  --        into cAdd     
  --        from master_temp mast
  --       where mast.master_num = iRecip_num;
  --    
  --      set cAdd = cAdd + cRecip_char;
  --    
  --      -- do update to master_temp
  --      update master_temp
  --         set master_temp.recip_char = cAdd
  --       where master_temp.master_num = iRecip_num;
  --    
  --      set iRecip_num=0;
  --      set cRecip_char='';
  --    
  --    end loop CursorLoop;
  --  close recipient_list;
  -- Get the number of customers at the occupied addresses
  select @cust_count_master = count(*) 
    from #master_temp
  -- ***********************************************
  --        main select for the procedure
  -- ***********************************************
  -- Populate the temp table for occupants
  -- TJB  SR4683  Aug 2006
  -- Changed the category counts to equal the Kiwimail count, instead of 1
  --
  -- TJB Sept 2005
  --     Removed the 'group by' clause. Redundant.
  --     Combined tables in to joins - it improved performance
  --     Added "mast_cust_id is null" - also improved performance
  --
  insert into #occ_temp(contract_no,
    con_title,
    adr_id,sur_comp_name,initials,prop_title,
    road_no,road_alpha,road_name,locality,rd_no,mail_town,
    recipients,categories,
    business,residential,farmer,
    kiwimail_qty,
    cust_counter,cmb_seq)
    select distinct con.contract_no,
      con.con_title,
      addr.adr_id,
      cust.cust_surname_company,
      cust.cust_initials,
      addr.adr_property_identification,
      upper(/*ifnull(addr.adr_unit,'',addr.adr_unit+'/')*/case when isnull(addr.adr_unit,'') = '' then '' else addr.adr_unit+'/' end +rd.trim(addr.adr_no)),
      upper(rd.trim(addr.adr_alpha)),
      rd.road_name+/*ifnull(rt.rt_name,'',' '+rt.rt_name)*/case when isnull(rt.rt_name,'') = '' then '' else ' '+rt.rt_name end +/*ifnull(rs.rs_name,'',' '+rs.rs_name)*/case when isnull(rs.rs_name,'') = '' then '' else ' '+rs.rs_name end ,
      sub.sl_name,
      addr.adr_rd_no,
      tc.tc_name,substring(mast.recip_char,2,len(mast.recip_char)-2),
      (case when cust.cust_business = 'Y' then 'Business' else
        case when cust.cust_rural_farmer = 'Y' then 'Farmer' else
          case when cust.cust_rural_resident = 'Y' then 'Residential'
          end
        end
      end),
    (case when cust.cust_business = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
     (case when cust.cust_rural_resident = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
      (case when cust.cust_rural_farmer = 'Y' then isnull(cust.cust_adpost_quantity,0) else 0 end),
      kiwimail_qty=cust.cust_adpost_quantity,
      @cust_count,
      0 from -- cmb_seq
      rds_customer as cust join customer_address_moves as cam on cust.cust_id = cam.cust_id
      join address as addr  on addr.adr_id = cam.adr_id
      left outer join suburblocality as sub on addr.sl_id = sub.sl_id
      join towncity as tc on addr.tc_id = tc.tc_id
      join road as rd on addr.road_id = rd.road_id
      join contract as con on addr.contract_no = con.contract_no
      left outer join road_type as rt on rd.rt_id = rt.rt_id
      left outer join road_suffix as rs on rd.rs_id = rs.rs_id,
      #master_temp as mast
      where
      cust.cust_id = mast.master_num and
      cam.move_out_date is null and
      cust.master_cust_id is null
  --and cust.cust_id = cam.cust_id
  --and addr.adr_id = cam.adr_id 
  --and tc.tc_id = addr.tc_id 
  --and rd.road_id = addr.road_id
  --group by con.contract_no, con.con_title, addr.adr_id, cust.cust_surname_company, cust.cust_initials, 
  --      addr.adr_property_identification, upper(trim(addr.adr_no)), upper(trim(addr.adr_alpha)), 
  --      rd.road_name + ' ' + rt.rt_name , sub.sl_name, addr.adr_rd_no, tc.tc_name, substr(mast.recip_char, 3),
  --      cust.cust_business, cust.cust_rural_resident, cust_rural_farmer, cust.cust_adpost_quantity, cust_count;
  -- Insert the unoccupied entries into the table
  -- TJB Sept 2005
  --     Removed the 'group by' clause. Redundant.
  --     Combined tables into joins - it improved performance
  insert into #occ_temp(adr_id,
    contract_no,con_title,prop_title,
    road_no,road_alpha,road_name,locality,rd_no,mail_town,
    business,residential,farmer,
    cust_counter,cmb_seq)
    select distinct addr.adr_id,
      con.contract_no,
      con.con_title,
      addr.adr_property_identification,
      upper(/*ifnull(addr.adr_unit,'',addr.adr_unit+'/')*/case when isnull(addr.adr_unit,'')= '' then '' else addr.adr_unit+'/' end
      +rd.trim(addr.adr_no)),
      upper(rd.trim(addr.adr_alpha)),
      rd.road_name+/*ifnull(rt.rt_name,'',' '+rt.rt_name)*/case when isnull(rt.rt_name,'') = '' then '' else ' '+rt.rt_name end+/*ifnull(rs.rs_name,'',' '+rs.rs_name)*/
      case when isnull(rs.rs_name,'') = '' then '' else ' '+rs.rs_name end,
      sub.sl_name,
      addr.adr_rd_no,
      tc.tc_name,
      0, -- Business
      0, -- Resident
      0, -- Farmer 
      @cust_count,
      0 from -- cmb_seq
      address as addr left outer join suburblocality as sub on addr.sl_id = sub.sl_id
      join towncity as tc on addr.tc_id = tc.tc_id
      join road as rd on addr.road_id = rd.road_id
      join contract as con on addr.contract_no = con.contract_no
      left outer join road_type as rt on rd.rt_id = rt.rt_id
      left outer join road_suffix as rs on rd.rs_id = rs.rs_id where
      addr.contract_no = any(select rds_id from rds_temp) and
      not addr.adr_id = any(select occ.adr_id from #occ_temp as occ)
  --and addr.road_id = rd.road_id
  --and addr.tc_id   = tc.tc_id
  --group by addr.adr_id, con.contract_no, con.con_title, addr.adr_property_identification, upper(trim(addr.adr_no)),
  --      upper(trim(addr.adr_alpha)), rd.road_name + ' ' + rt.rt_name , sub.sl_name, addr.adr_rd_no, tc.tc_name,
  --      cust_count;
  -- Get the total number of delivery points
  select @del_pt_count = count(distinct(adr_id))
    from #occ_temp
  -- insert the CMB entries into the table
  insert into #occ_temp(sur_comp_name,
    initials,
    road_no,
    rd_no,mail_town,
    categories,
    business,residential,farmer,
    kiwimail_qty,cmb_seq)
    select cmb.cmb_cust_surname,
      cmb.cmb_cust_initials,
      cmb.cmb_box_no,
      cmb.adr_rd_no,
      tc.tc_name,'CMB',
      -- Catagories
      0, -- Business
      0, -- Resident
      0, -- Farmer
      kiwimail_qty=(case when(cmb_cust_surname is null or cmb_cust_surname = '') and
      (cmb_cust_initials is null or cmb_cust_initials = '') then
        null else 1 end),
      row_number() over (order by cmb.cmb_cust_surname asc) from -- cmb_seq
      cmb_address as cmb,
      towncity as tc where
      cmb.contract_no = any(select rds_id from rds_temp) and
      cmb.tc_id = tc.tc_id order by
      tc.tc_name asc,cmb.cmb_box_no asc
  -- Get the number of cmb customers
  select @cust_count_cmb = count(*)
    from #occ_temp where
    cmb_seq > 0 and
    ((sur_comp_name is not null and sur_comp_name != '') or
    (initials is not null and initials != ''))
  -- Calculate the total number of customers
  select @cust_count=isnull(@cust_count_master,0)+isnull(@cust_count_cmb,0)
  -- 20 blank spaces
  select @blank_space=space(20)
  -- Output the result
  select sur_comp_name,
    initials,
    prop_title,
    road_no=substring(@blank_space,1,(20-len(road_no)))+road_no,
    road_alpha=road_alpha,
    road_name,
    locality,
    rd_no,
    mail_town,
    recipients,
    categories,
    kiwimail_qty,
    business,
    residential,
    farmer,
    @cust_count as cust_count ,
    @del_pt_count as del_pt_count,
    contract_no,
    con_title from
    #occ_temp 
    order by
    cmb_seq asc,contract_no asc
end



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_transform_telno : 
--

CREATE function [rd].[f_transform_telno](@oldtelno char(20))
returns char(20)
as
begin
  declare @newtelno char(20),
  @temptelno char(20),
  @ii integer,
  @newtelno2 char(20),
  @ismobile char(1)
  if @oldtelno is null
    return @oldtelno
  select @temptelno=rd.trim(@oldtelno)
  select @newtelno2=''
  select @newtelno=''
  if left(@temptelno,4) = '021 ' or left(@temptelno,4) = '025 ' or left(@temptelno,4) = '021-' or left(@temptelno,4) = '025-'
    select @ismobile='Y'
  while len(@temptelno) > 0
    begin
      if ascii(left(@temptelno,1)) > 47 and ascii(left(@temptelno,1)) < 58
        begin
          select @newtelno=@newtelno + left(@temptelno,1)
          if left(@newtelno,2) = '00'
            select @newtelno=right(@newtelno,len(@newtelno)-1)
        end
      select @temptelno=right(@temptelno,len(@temptelno)-1)
    end
  if @newtelno = '0'
    return null
  select @newtelno2=@newtelno
  if @ismobile = 'Y'
    select @newtelno=left(@newtelno2,3) + '-' + SUBSTRING (@newtelno2,4,3) + '-' + case when len(@newtelno2) > 6 then right(@newtelno2,len(@newtelno2)-6) else '' end
  else
    if left(@newtelno,1) = '0'
      select @newtelno=left(@newtelno2,2) + '-' + SUBSTRING (@newtelno2,3,3) + '-' + case when len(@newtelno2) > 5 then right(@newtelno2,len(@newtelno2)-5) else '' end
    else
      select @newtelno=left(@newtelno2,3) + '-' + case when len(@newtelno2) > 3 then right(@newtelno2,len(@newtelno2)-3) else '' end
  if @newtelno = '--' or @newtelno = '-'
    return null
  return @newtelno
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRenewalFreqAdjust : 
--

CREATE procedure [rd].[sp_GetRenewalFreqAdjust](
@in_Contract int,
@in_Sequence int)
as
begin
  select frequency_adjustments.contract_no,
    frequency_adjustments.contract_seq_number,
    frequency_adjustments.fd_unique_seq_number,
    frequency_adjustments.fd_adjustment_amount,
    frequency_adjustments.fd_paid_to_date,
    frequency_adjustments.fd_bm_after_extn,
    frequency_adjustments.fd_confirmed,line_type='D',
    frequency_adjustments.fd_amount_to_pay from
    frequency_adjustments where
    frequency_adjustments.contract_no = @in_Contract and
    frequency_adjustments.contract_seq_number =@in_Sequence --modify inSequence to @in_sequency by jlwang_msd 
union all
  select frequency_adjustments.contract_no,
    frequency_adjustments.contract_seq_number,
    null,
    sum(frequency_adjustments.fd_adjustment_amount),
    null,
    null,'T','S',
    sum(frequency_adjustments.fd_amount_to_pay) from
    frequency_adjustments where
    frequency_adjustments.contract_no = @in_Contract and
    frequency_adjustments.contract_seq_number = @in_Sequence --modify inSequence to @in_sequency by jlwang_msd 

    group by frequency_adjustments.contract_no,frequency_adjustments.contract_seq_number order by
    1 desc,2 desc,8 asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function get_prev_bench : 
--

--
-- Definition for user-defined function get_prev_bench : 
--

CREATE function [rd].[get_prev_bench](@con_no int)
returns numeric(10,2)
as
begin
  declare @former_bench numeric(10,2),
  @active_con_seq int,
  @latest_con_seq int,
  @latest_uni_seq int
  -- get latest contract_sequence number
  select @latest_con_seq=max(fa.contract_seq_number) 
    from frequency_adjustments as fa where
    fa.contract_no = @con_no
  -- if is zero - set former to zero
  if @latest_con_seq is null or @latest_con_seq = 0
    select @former_bench=0
  else
    begin
      -- get the latest unique sequence number
      select @latest_uni_seq= max(fa.fd_unique_seq_number)
        from frequency_adjustments as fa where
        fa.contract_no = @con_no and
        fa.contract_seq_number = @latest_con_seq
      -- get the latest benchmark figure from the table
      select @former_bench=max(fd_bm_after_extn) 
        from frequency_adjustments as fa where
        fa.contract_no = @con_no and
        fa.contract_seq_number = @latest_con_seq and
        fa.fd_unique_seq_number = @latest_uni_seq
    end
  if @former_bench is null
    select @former_bench=0
  return @former_bench
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetContractAdjust : 
--

--
-- Definition for stored procedure sp_GetContractAdjust : 
--

CREATE procedure [rd].[sp_GetContractAdjust](@in_Contract int)
as
begin
  select frequency_adjustments.contract_no,
    frequency_adjustments.contract_seq_number,
    frequency_adjustments.fd_unique_seq_number,
    frequency_adjustments.fd_adjustment_amount,
    frequency_adjustments.fd_paid_to_date,
    frequency_adjustments.fd_bm_after_extn,
    frequency_adjustments.fd_confirmed,line_type='D',
    frequency_adjustments.fd_amount_to_pay from
    frequency_adjustments where
    frequency_adjustments.contract_no = @in_Contract union all
  select frequency_adjustments.contract_no,
    frequency_adjustments.contract_seq_number,
    null,
    sum(frequency_adjustments.fd_adjustment_amount),
    null,
    null,'T','S',
    sum(frequency_adjustments.fd_amount_to_pay) from
    frequency_adjustments where
    frequency_adjustments.contract_no = @in_Contract
    group by frequency_adjustments.contract_no,frequency_adjustments.contract_seq_number order by
    1 desc,2 desc,8 asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for user-defined function GetLastDayofMonth : 
--

CREATE function [rd].[GetLastDayofMonth](@indate datetime)
returns datetime
as
begin
  declare @p_temp datetime,
  @p_temp2 datetime
  select @p_temp = rd.ymd(year(@indate),month(@indate),28) 
 
  select @p_temp2 = dateadd(day,1,@p_temp) 
 
  if month(@p_temp) <> month(@p_temp2)
    return(dateadd(day,-1,@p_temp2))
  select @p_temp2 = dateadd(day,2,@p_temp) 
 
  if month(@p_temp) <> month(@p_temp2)
    return(dateadd(day,-1,@p_temp2))
  select @p_temp2 = dateadd(day,3,@p_temp) 
 
  if month(@p_temp) <> month(@p_temp2)
    return(dateadd(day,-1,@p_temp2))
  return(rd.ymd(year(@indate),month(@indate),31))
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure ps_Customers : 
--

CREATE procedure [rd].[ps_Customers](@inRegion int,@inYearStart datetime,@inMonthEnd datetime,@outYTDStart int output,@outYTDTransfer int output,@outYTDStopped int output,@outMonthStart int output,@outMonthTransfer int output,@outMonthStopped int output)
as
begin
  declare @dMonthStart datetime
  select @dMonthStart=rd.ymd(year(@inMonthEnd),month(@inMonthEnd),1)
  select @outYTDStart = sum(case when cust_date_first_loaded > @inYearStart and cust_date_first_loaded < @inMonthEnd then 1 else 0 end),
    @outYTDTransfer = sum(case when cust_date_last_transfered > @inYearStart and cust_date_last_transfered < @inMonthEnd then 1 else 0 end),
    @outYTDStopped = sum(case when cust_date_left > @inYearStart and cust_date_left < @inMonthEnd then 1 else 0 end),
    @outMonthStart = sum(case when cust_date_first_loaded > @dMonthStart and cust_date_first_loaded < @inMonthEnd then 1 else 0 end),
    @outMonthTransfer = sum(case when cust_date_last_transfered > @dMonthStart and cust_date_last_transfered < @inMonthEnd then 1 else 0 end),
    @outMonthStopped = sum(case when cust_date_left > @dMonthStart and cust_date_left < @inMonthEnd then 1 else 0 end) 
    from customer join
    contract on
    customer.contract_no = contract.contract_no,
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) where
    (contract.con_date_terminated is null or
    contract.con_date_terminated > @inYearStart)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for user-defined function GetFirstDayofMonth : 
--

CREATE function [rd].[GetFirstDayofMonth](@indate datetime)
returns datetime
as
begin
  declare @p_firstdayofmonth datetime
  select @p_firstdayofmonth = rd.ymd(year(@indate),month(@indate),1) 
  
  return(@p_firstdayofmonth)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetTypesForContract : 
--

CREATE procedure [rd].[sp_GetTypesForContract](@in_Contract int)
as
begin
  select tfc.ct_key,
    tfc.contract_no from
    types_for_contract as tfc join contract_type as ct on tfc.ct_key=ct.ct_key where
    tfc.contract_no = @in_Contract order by
    ct.contract_type asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_DDDW_ContractTypes_new : 
--

CREATE procedure [rd].[sp_DDDW_ContractTypes_new]
as
begin select ct_key,contract_type from contract_type union select-1,'<All>' order by 2 asc end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_ContractTypes : 
--

CREATE procedure [rd].[sp_DDDW_ContractTypes]
as
begin
  select ct_key,contract_type,ct_rd_ref_mandatory from
    contract_type union
  select 0,'','N' order by
    1 asc
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_MiscF_Get_PCT_Sequence : 
--

CREATE function [odps].[OD_MiscF_Get_PCT_Sequence](@inInvoice_id int,@inpct_id int)
returns int
as
begin
  declare @iSeqCount int
  select @iSeqCount = count(*) 
    from payment_component where
    invoice_id = @inInvoice_id and
    pc_id < @inpct_id
  if @iSeqCount is null or @iSeqCount = 0
    return(1)
  else
    return(@iSeqCount+1)
  --if @@fetch_status < 0// by fyb
   -- begin
      -- rollback transaction 
    --  return(-1)
   -- end
 return(1)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_Invoice_deductions : 
--

CREATE procedure [odps].[OD_RPS_Invoice_deductions](@invoiceid int)
as
begin
  select post_tax_deductions_applied.pcd_date,
    post_tax_deductions.ded_description,
    post_tax_deductions_applied.pcd_amount*-1 from
    post_tax_deductions,
    post_tax_deductions_applied where
    (post_tax_deductions.ded_id = post_tax_deductions_applied.ded_id) and
    ((post_tax_deductions_applied.invoice_id = @invoiceid))
end
 








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_SequenceCust](@inContract int,@inSfKey int,@inDays char(7),@inCustid integer,@inPreCustid integer,@inSeq int) as
begin
  insert into cust_frequency_order(contract_no,sf_key,rf_delivery_days,cust_id,cfo_previous_customer,cfo_sequence) values(
    @inContract,@inSfKey,@inDays,@inCustid,@inPreCustid,@inSeq)
  if @inSfKey = 1
    update customer set
      sf_key1 = 1 where
      cust_id = @inCustid
  if @inSfKey = 2
    update customer set
      sf_key2 = 1 where
      cust_id = @inCustid
  if @inSfKey = 3
    update customer set
      sf_key3 = 1 where
      cust_id = @inCustid
  if @inSfKey = 4
    update customer set
      sf_key4 = 1 where
      cust_id = @inCustid
  if @inSfKey = 5
    update customer set
      sf_key5 = 1 where
      cust_id = @inCustid
  if @inSfKey = 6
    update customer set
      sf_key6 = 1 where
      cust_id = @inCustid
  if @inSfKey = 7
    update customer set
      sf_key7 = 1 where
      cust_id = @inCustid
  if @inSfKey = 8
    update customer set
      sf_key8 = 1 where
      cust_id = @inCustid
  if @inSfKey = 9
    update customer set
      sf_key9 = 1 where
      cust_id = @inCustid
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_UnsequenceCust : 
--

CREATE procedure [rd].[sp_UnsequenceCust](@inContract int,@inSfKey int,@inCustid int,@inRf_delivery_days char(7)) 
as
begin
  if @inSfKey = 1
    begin
      delete from cust_frequency_order where
        contract_no = @inContract and
        cust_id = @inCustid and
        sf_key = @inSfKey and
        rf_delivery_days = @inRf_delivery_days
      update customer set
        sf_key1 = 0 where
        contract_no = @inContract and
        cust_id = @inCustid
    end
  if @inSfKey = 2
    begin
      delete from cust_frequency_order where
        contract_no = @inContract and
        cust_id = @inCustid and
        sf_key = @inSfKey and
        rf_delivery_days = @inRf_delivery_days
      update customer set
        sf_key2 = 0 where
        contract_no = @inContract and
        cust_id = @inCustid
    end
  if @inSfKey = 3
    begin
      delete from cust_frequency_order where
        contract_no = @inContract and
        cust_id = @inCustid and
        sf_key = @inSfKey and
        rf_delivery_days = @inRf_delivery_days
      update customer set
        sf_key3 = 0 where
        contract_no = @inContract and
        cust_id = @inCustid
    end
  if @inSfKey = 4
    begin
      delete from cust_frequency_order where
        contract_no = @inContract and
        cust_id = @inCustid and
        sf_key = @inSfKey and
        rf_delivery_days = @inRf_delivery_days
      update customer set
        sf_key4 = 0 where
        contract_no = @inContract and
        cust_id = @inCustid
    end
  if @inSfKey = 5
    begin
      delete from cust_frequency_order where
        contract_no = @inContract and
        cust_id = @inCustid and
        sf_key = @inSfKey and
        rf_delivery_days = @inRf_delivery_days
      update customer set
        sf_key5 = 0 where
        contract_no = @inContract and
        cust_id = @inCustid
    end
  if @inSfKey = 6
    begin
      delete from cust_frequency_order where
        contract_no = @inContract and
        cust_id = @inCustid and
        sf_key = @inSfKey and
        rf_delivery_days = @inRf_delivery_days
      update customer set
        sf_key6 = 0 where
        contract_no = @inContract and
        cust_id = @inCustid
    end
  if @inSfKey = 7
    begin
      delete from cust_frequency_order where
        contract_no = @inContract and
        cust_id = @inCustid and
        sf_key = @inSfKey and
        rf_delivery_days = @inRf_delivery_days
      update customer set
        sf_key7 = 0 where
        contract_no = @inContract and
        cust_id = @inCustid
    end
  if @inSfKey = 8
    begin
      delete from cust_frequency_order where
        contract_no = @inContract and
        cust_id = @inCustid and
        sf_key = @inSfKey and
        rf_delivery_days = @inRf_delivery_days
      update customer set
        sf_key8 = 0 where
        contract_no = @inContract and
        cust_id = @inCustid
    end
  if @inSfKey = 9
    begin
      delete from cust_frequency_order where
        contract_no = @inContract and
        cust_id = @inCustid and
        sf_key = @inSfKey and
        rf_delivery_days = @inRf_delivery_days
      update customer set
        sf_key9 = 0 where
        contract_no = @inContract and
        cust_id = @inCustid
    end
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_resequencecusts](@inContract int,@inSfKey int,@inDays char(7)) as
begin
  declare @nSequence integer,
  @nCustomer integer,
  @nCount integer
  select @nSequence=0
  select @nCustomer=0
  select @nCount=count(*) 
    from cust_frequency_order where
    contract_no = @inContract and
    sf_key = @inSFKey and
    rf_delivery_days = @inDays
  if @nCount > 0
    /* Watcom only
    SequenceLoop:
    */while 1=1 
      begin
        select @nCustomer=cust_id 
          from cust_frequency_order where
          contract_no = @inContract and
          sf_key = @inSFKey and
          rf_delivery_days = @inDays and
          cfo_previous_customer = @nCustomer
        select @nSequence=@nSequence+1
        update cust_frequency_order set
          cfo_sequence = @nSequence where
          contract_no = @inContract and
          sf_key = @inSFKey and
          rf_delivery_days = @inDays and
          cust_id = @nCustomer
        if @inSFKey = 1
          update customer set
            sf_key1 = 1 where
            cust_id = @nCustomer
        if @inSFKey = 2
          update customer set
            sf_key2 = 1 where
            cust_id = @nCustomer
        if @inSFKey = 3
          update customer set
            sf_key3 = 1 where
            cust_id = @nCustomer
        if @inSFKey = 4
          update customer set
            sf_key4 = 1 where
            cust_id = @nCustomer
        if @inSFKey = 5
          update customer set
            sf_key5 = 1 where
            cust_id = @nCustomer
        if @inSFKey = 6
          update customer set
            sf_key6 = 1 where
            cust_id = @nCustomer
        if @inSFKey = 7
          update customer set
            sf_key7 = 1 where
            cust_id = @nCustomer
        if @inSFKey = 8
          update customer set
            sf_key8 = 1 where
            cust_id = @nCustomer
        if @inSFKey = 9
          update customer set
            sf_key9 = 1 where
            cust_id = @nCustomer
        if @nSequence = @nCount
          break
          /* Watcom only
          SequenceLoop
          */
      end
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_DDDW_PieceRateSuppliers : 
--

CREATE procedure [rd].[sp_DDDW_PieceRateSuppliers]
as
begin
  select prs_key,
    prs_description from
    piece_rate_supplier
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_BLF_MaxDate : 
--

CREATE function [odps].[OD_BLF_MaxDate](@sdate datetime,@edate datetime)
returns datetime
as
begin
  declare @l_date datetime
  select @l_date = max(nat_effective_date) 
    from "national" where
    nat_effective_date >= @sdate and
    nat_effective_date <= @edate
  return(@l_date)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_NationalChangesHistory : 
--

CREATE procedure [odps].[OD_RPS_NationalChangesHistory](@sdate datetime,@edate datetime)
as
begin
  select nat_ac_id_gst_gl,
    nat_ac_id_whtax_gl,
    nat_ac_id_postax_adj_gl,
    nat_rural_post_gst_no,
    nat_gst_rate,
    nat_ird_no,
    nat_rural_post_address,
    nat_rural_post_payer_name,
    nat_acc_percentage,
    nat_standard_tax_rate,
    nat_day_of_month,
    nat_message_for_invoice,
    nat_net_pct_change_warn,
    nat_seq_no_for_keys,
    nat_od_standard_gst_rate,
    nat_od_tax_rate_ir13,
    nat_od_tax_rate_no_ir13,
    ap_net_pay_clearing_account,
    nat_effective_date,
    nat_ac_id_contprice_gl,
    nat_ac_id_netpay_gl,
    nat_ac_id_accrualbalance_gl,
    nat_pbu_code_postax_gl,
    nat_pbu_code_whtax_gl,
    nat_pbu_code_gst_gl,
    nat_pbu_code_netpay_gl,
    nat_invoice_number_prefix from
    [national] where
    nat_effective_date = (select max(nat_effective_date) from
      [national] where
      nat_effective_date between @Sdate and @Edate) union
  select nat_ac_id_gst_gl,
    nat_ac_id_whtax_gl,
    nat_ac_id_postax_adj_gl,
    nat_rural_post_gst_no,
    nat_gst_rate,
    nat_ird_no,
    nat_rural_post_address,
    nat_rural_post_payer_name,
    nat_acc_percentage,
    nat_standard_tax_rate,
    nat_day_of_month,
    nat_message_for_invoice,
    nat_net_pct_change_warn,
    nat_seq_no_for_keys,
    nat_od_standard_gst_rate,
    nat_od_tax_rate_ir13,
    nat_od_tax_rate_no_ir13,
    ap_net_pay_clearing_account,
    nat_effective_date,
    nat_ac_id_contprice_gl,
    nat_ac_id_netpay_gl,
    nat_ac_id_accrualbalance_gl,
    nat_pbu_code_postax_gl,
    nat_pbu_code_whtax_gl,
    nat_pbu_code_gst_gl,
    nat_pbu_code_netpay_gl,
    nat_invoice_number_prefix from
    [national] where
    nat_effective_date = (select max(nat_effective_date) from
      [national] where
      nat_effective_date < (select max(nat_effective_date) from
        [national] where
        nat_effective_date between @Sdate and @Edate))
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function OD_BLF_GetWhichNational : 
--

CREATE function [odps].[OD_BLF_GetWhichNational](@indate datetime)
returns int
as
begin
  declare @v_nat_id int
  select @v_nat_id = max("national".nat_id)
    from "national" where
    "national".nat_effective_date = 
    (select max(n.nat_effective_date) from
      "national" as n where n.nat_effective_date <= @indate)
  return(@v_nat_id)
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetCustOccupation : 
--

--
-- Definition for stored procedure sp_GetCustOccupation : 
--

CREATE procedure [rd].[sp_GetCustOccupation](@in_Cust_Id int)
as
begin
  select cust_id,
    occupation_id from
    customer_occupation where
    cust_id = @in_cust_id
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetCustInterest : 
--

--
-- Definition for stored procedure sp_GetCustInterest : 
--

CREATE procedure [rd].[sp_GetCustInterest](@in_Cust_Id int)
as
begin
  select cust_id,
    interest_id from
    rd.customer_interest where
    cust_id = @in_cust_id
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_sync : 
--

CREATE procedure [odps].[sp_sync](@a_sync_name char(30)= 'ALL') 
as
if upper(@a_sync_name) <> 'ALL' 
select sync_no,sync_name,sync_value 
from sync 
where 
sync_name = @a_sync_name
else 
select sync_no,sync_name,sync_value
 from sync








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_Get_other_override_rates : 
--

CREATE procedure [rd].[sp_Get_other_override_rates](@incontract_no int,@incontract_seq_no int)
as
begin
  select misc_override_rate.contract_no,
    misc_override_rate.contract_seq_number,
    misc_override_rate.mor_name,
    misc_override_rate.mor_value,
    misc_override_rate.mor_km_flag,
    misc_override_rate.mor_annual_flag from
    misc_override_rate where
    (misc_override_rate.contract_no = @incontract_no) and
    (misc_override_rate.contract_seq_number = @incontract_seq_no)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE function [rd].[BenchmarkCalc](@inContract int,@inSequence int) 
RETURNS real
AS
BEGIN
  declare @nNominalVehical numeric(10,2)
  declare @nWageHourlyRate numeric(10,2)
  declare @nRepairsMaint numeric(10,2)
  declare @nTyreTubes numeric(10,2)
  declare @nVehicalAllow numeric(10,2)
  declare @nVehicalInsure numeric(10,2)
  declare @nPublicLia numeric(10,2)
  declare @nCarrierRisk numeric(10,2)
  declare @nACCRate numeric(10,2)
  declare @nLicence numeric(10,2)
  declare @nRateOfReturn numeric(10,2)
  declare @nSalvageRatio numeric(10,2)
  declare @nItemsHour numeric(10,2)
  declare @nFuel numeric(10,2)
  declare @nConsumption numeric(10,2)
  declare @dStartDate datetime
  declare @dEndDate datetime
  declare @nNumRows int 
  declare @nRouteDistance numeric(10,2)
  declare @nDeliveryHours numeric(10,3)
  declare @nProcessingHours numeric(10,2)
  declare @nVolume numeric(10,2)
  declare @nDeliveryDays numeric(10,2)
  declare @nMaxDeliveryDays numeric(10,2)
  declare @nRouteDistancePerDay real
  declare @nVehicleDepreciation real
  declare @nFuelCostPerAnnum real
  declare @nRepairsPerAnnum real
  declare @nTyresTubesPerAnnum real
  declare @nDeliveryCost real
  declare @nProcessingCost real
  declare @nPublicLiabilityCost real
  declare @nACCPerAnnum real
  declare @nBenchmark real
  declare @nVehicleInsurance real
  declare @nLicensing real
  declare @nCarrierRiskRate real
  declare @nRateReturn real
  declare @nRGCode int
  declare @dEffectDate datetime
  declare @nTempint int
  declare @Tempdec numeric(10,2)
  declare @nRUC numeric(8,2)
  declare @nRUCRate numeric(8,2)
  declare @nAccounting numeric(8,2)
  declare @nTelephone numeric(8,2)
  declare @nSundries numeric(8,2)
  declare @nSundriesK numeric(8,2)
  select @nNominalVehical=isnull(contract_rates.rr_nominal_vehical_value,renewal_rate.rr_nominal_vehical_value),
    @nWageHourlyRate=isnull(contract_rates.rr_wage_hourly_rate,renewal_rate.rr_wage_hourly_rate),
    @nRepairsMaint=isnull(contract_rates.rr_repairs_maintenance_rate,renewal_rate.rr_repairs_maintenance_rate),
    @nTyreTubes=isnull(contract_rates.rr_tyre_tubes_rate,renewal_rate.rr_tyre_tubes_rate),
    @nVehicalAllow=isnull(contract_rates.rr_vehical_allowance_rate,renewal_rate.rr_vehical_allowance_rate),
    @nVehicalInsure=isnull(contract_rates.rr_vehical_insurance_premium,renewal_rate.rr_vehical_insurance_premium),
    @nPublicLia=isnull(contract_rates.rr_public_liability_rate_2,renewal_rate.rr_public_liability_rate),
    @nCarrierRisk=isnull(contract_rates.rr_carrier_risk_rate,renewal_rate.rr_carrier_risk_rate),
    @nACCRate=isnull(contract_rates.rr_acc_rate,renewal_rate.rr_acc_rate),
    @nLicence=isnull(contract_rates.rr_licence_rate,renewal_rate.rr_licence_rate),
    @nRateOfReturn=isnull(contract_rates.rr_vehical_rate_of_return_pct,renewal_rate.rr_vehical_rate_of_return_pct),
    @nSalvageRatio=isnull(contract_rates.rr_salvage_ratio,renewal_rate.rr_salvage_ratio),
    @nItemsHour=isnull(contract_rates.rr_item_proc_rate_per_hour,renewal_rate.rr_item_proc_rate_per_hr),
    @nFuel=isnull(contract_rates.rr_fuel_rate,fuel_rates.fr_fuel_rate),
    @nConsumption=isnull(contract_rates.rr_consumption_rate,fuel_rates.fr_fuel_consumtion_rate),
    @nAccounting=isnull(contract_rates.rr_accounting,renewal_rate.rr_accounting),
    @nTelephone=isnull(contract_rates.rr_Telephone,renewal_rate.rr_Telephone),
    @nSundries=isnull(contract_rates.rr_Sundries,renewal_rate.rr_Sundries),
    @nRucRate=isnull(contract_rates.rr_RUC,renewal_rate.rr_RUC),
    @nSundriesK=isnull(contract_rates.rr_sundries_k,renewal_rate.rr_sundries_k) 
    from contract_renewals left outer join
    contract_rates on
    contract_renewals.contract_no = contract_rates.contract_no and
    contract_renewals.contract_seq_number = contract_rates.contract_seq_number join
    renewal_rate on
    contract_renewals.con_rg_code_at_renewal = renewal_rate.rg_code and
    contract_renewals.con_rates_effective_date = renewal_rate.rr_rates_effective_date join
    contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.cv_vehical_status = 'A'
	 join vehicle on
    contract_vehical.vehicle_number = vehicle.vehicle_number
	 join fuel_type on
    vehicle.ft_key = fuel_type.ft_key
	join fuel_rates on
    fuel_type.ft_key = fuel_rates.ft_key where
    fuel_rates.rg_code = renewal_rate.rg_code and
    fuel_rates.rr_rates_effective_date = renewal_rate.rr_rates_effective_date and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  if @@error <> 0 /* <> was < */	--RAISERROR('',10,1)
    /* Watcom only
    resignal
    */
  return -1
  select @dStartDate=con_start_date 
    from contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  select @dEndDate=con_start_date,
    @nRGCode=con_rg_code_at_renewal,
    @dEffectDate=con_rates_effective_date
    from contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence+1
  select  @nNumRows=count(*),
    @nDeliveryDays=rd.GetContractDelDays(contract_renewals.contract_no,contract_renewals.contract_seq_number,contract_renewals.con_rg_code_at_renewal,contract_renewals.con_rates_effective_date),
    @nRouteDistance=contract_renewals.con_distance_at_renewal+sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum),
    @nDeliveryHours=contract_renewals.con_del_hrs_week_at_renewal+sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
    @nProcessingHours=contract_renewals.con_processing_hours_per_week+sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
    @nVolume=contract_renewals.con_volume_at_renewal+sum(isnull(frequency_distances.fd_volume,0))
    from contract_renewals,
    route_frequency left outer join
    frequency_distances on
    route_frequency.contract_no = frequency_distances.contract_no and
    route_frequency.sf_key = frequency_distances.sf_key and
    route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days and
    frequency_distances.fd_effective_date >= @dStartDate and
    @dStartDate is not null and
    (@dEndDate is null or
    @dEndDate >= frequency_distances.fd_effective_date),
    rate_days where
    (contract_renewals.contract_no = route_frequency.contract_no) and
    (route_frequency.sf_key = rate_days.sf_key) and
    (contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date) and
    (contract_renewals.con_rg_code_at_renewal = rate_days.rg_code) and
    (contract_renewals.contract_no = @inCOntract) and
    (contract_renewals.contract_seq_number = @inSequence)
    group by contract_renewals.contract_no,
    contract_renewals.contract_seq_number,
    contract_renewals.con_rg_code_at_renewal,
    contract_renewals.con_rates_effective_date,
    contract_renewals.con_distance_at_renewal,
    contract_renewals.con_del_hrs_week_at_renewal,
    contract_renewals.con_processing_hours_per_week,
    contract_renewals.con_volume_at_renewal
  select @nMaxDeliveryDays=max(rate_days.rtd_days_per_annum)
    from contract_renewals join
    rate_days on
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  select @nRouteDistancePerDay=@nRouteDistance/@nDeliveryDays 
  select @nVehicleDepreciation=@nRouteDistance*(@nVehicalAllow/1000)  
  select @nFuelCostPerAnnum=(@nConsumption/100)*@nRouteDistance*(@nFuel/100) 
  select  @nRepairsPerAnnum=@nRouteDistance*(@nRepairsMaint/1000) 
  select @nTyresTubesPerAnnum=@nTyreTubes*(@nRouteDistance/1000)  
  select @nDeliveryCost=((@nDeliveryHours)*56)*@nWageHourlyRate  
  select @nProcessingCost=((((@nVolume/@nItemsHour)/365)*7)*56)*@nWageHourlyRate 
  select @nPublicLiabilityCost=@nPublicLia*(@nDeliveryDays/@nMaxDeliveryDays)  
  select @nACCPerAnnum=(@nAccRate/100)*(@nDeliveryCost+@nProcessingCost) 
  select @nVehicleInsurance=@nVehicalInsure*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nLicensing=@nLicence*(@nDeliveryDays/@nMaxDeliveryDays)  
  select @nCarrierRiskRate=@nCarrierRisk*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nRateReturn=rd.GetRateReturn(@nNominalVehical,@nRateOfReturn,@nSalvageRatio) 
  select @nRateReturn=@nRateReturn*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nAccounting=@nAccounting*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nTelephone=@nTelephone*(@nDeliveryDays/@nMaxDeliveryDays)  
  select @nSundries=@nSundries*(@nDeliveryDays/@nMaxDeliveryDays) 
  select  @nTempint=count(contractor_renewals.contract_no) 
    from rd.contractor_renewals,
    rd.contract_vehical,
    rd.vehicle,
    rd.fuel_type where
    (contractor_renewals.contract_no = @inContract) and
    (contractor_renewals.contract_seq_number = @inSequence) and
    (contractor_renewals.contract_no = contract_vehical.contract_no) and
    (contractor_renewals.contract_seq_number = contract_vehical.contract_seq_number) and
    (contract_vehical.vehicle_number = vehicle.vehicle_number) and
    (vehicle.ft_key = fuel_type.ft_key) and
    (fuel_type.ft_description like 'diesel%') and
    (contract_vehical.cv_vehical_status = 'A')
  if @@error <> 0 /* <> was < */	--RAISERROR('',10,1)
    /* Watcom only
    resignal
    */
   return -1
  if @ntempint = 0
    select @nRUC=0.0
  else
    select @nRUC=@nRUCRate*(@nRouteDistance/1000)
  select @nSundriesK=@nSundriesK*(@nRouteDistance/1000) 
  select @nBenchmark=isnull(@nVehicleDepreciation,0)+
    isnull(@nFuelCostPerAnnum,0)+
    isnull(@nRepairsPerAnnum,0)+
    isnull(@nTyresTubesPerAnnum,0)+
    isnull(@nDeliveryCost,0)+
    isnull(@nProcessingCost,0)+
    isnull(@nPublicLiabilityCost,0)+
    isnull(@nACCPerAnnum,0)+
    isnull(@nVehicleInsurance,0)+
    isnull(@nLicensing,0)+
    isnull(@nCarrierRiskRate,0)+
    isnull(@nRateReturn,0)+
    isnull(@nRUC,0)+
    isnull(@nTelephone,0)+
    isnull(@nSundries,0)+
    isnull(@nAccounting,0)+
    isnull(@nSundriesK,0)
  select @nBenchmark=Round(@nBenchmark+.5,0)
  return(@nBenchmark)

END







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_VehicleAging : 
--
CREATE procedure [rd].[sp_VehicleAging](@inRegion int,@inOutlet int,@inRenewalGroup int,@inContractType int)
as
begin
   
select 
contract_no,
rgn_name,
con_expiry_date,
con_distance_at_renewal,  
    -- PBY 12/06/2002 SR#4401
    --    (select isnull((select max(cv.vehicle_number) 
    --                    from contract_vehical as cv 
    --                    where cv.contract_seq_number=contract.con_active_sequence 
    --                    and cv.contract_no=contract.contract_no 
    --                    and cv_vehical_status='N' 
    --                    and cv.contract_seq_number=(select max(cv2.contract_seq_number) 
    --                                                from contract_vehical as cv2 
    --                                                where cv.contract_no=cv2.contract_no 
    --                                                and cv.cv_vehical_status=cv2.cv_vehical_status)),
    --                    (select max(cv.vehicle_number) 
    --                    from contract_vehical as cv 
    --                    where cv.contract_no=contract.contract_no 
    --                    and cv_vehical_status='A' 
    --                    and cv.contract_seq_number=(select max(cv2.contract_seq_number) 
    --                                                from contract_vehical as cv2 
    --                                                where cv.contract_no=cv2.contract_no 
    --                                                and cv.cv_vehical_status=cv2.cv_vehical_status))) 
    --     from dummy) as vehicle_no,  
vehicle_no,
rg_description,
con_active_sequence,
contract_type,
vage
from 
(
select [contract].contract_no,
    region.rgn_name,
    contract_renewals.con_expiry_date,
    contract_renewals.con_distance_at_renewal,    
vehicle_no=rd.f_GetLatestVehicle(contract_renewals.contract_no,contract_renewals.contract_seq_number),
    renewal_group.rg_description,
    con_active_sequence=contract.con_active_sequence,
    contract_type.contract_type,
    vage=(select(year(con_expiry_date)-v_vehicle_year) from vehicle where vehicle.vehicle_number = rd.f_GetLatestVehicle(contract_renewals.contract_no,contract_renewals.contract_seq_number)) 
,cr_contract_no = contract_renewals.contract_no
,cr_contract_seq_number = contract_renewals.contract_seq_number
,con_start_date
from
    [contract],
    contract_renewals,
    outlet,
    region,
    renewal_group,
    types_for_contract,
    contract_type 
where
    (contract_renewals.contract_no = contract.contract_no) and
    (region.region_id = outlet.region_id) and
    (contract.con_base_office = outlet.outlet_id) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = renewal_group.rg_code) and
    (contract.contract_no = types_for_contract.contract_no) and
    (contract_type.ct_key = types_for_contract.ct_key) and
    ((types_for_contract.ct_key = @inContractType and @inContractType > 0) or(@inContractType = 0)) and
    ((outlet.outlet_id = @inOutlet and @inOutlet > 0) or(@inOutlet = 0)) and
    ((outlet.region_id = @inRegion and @inRegion > 0) or(@inRegion = 0)) and
    ((contract.rg_code = @inRenewalGroup and @inRenewalGroup > 0) or(@inRenewalGroup = 0)) and
    contract_renewals.con_expiry_date > rd.today()
) as atable
where
(vehicle_no > 0) and
    exists(select vehicle.vehicle_number from vehicle where(vehicle.vehicle_number = vehicle_no 
 and
      ((year(con_expiry_date)-v_vehicle_year) > 5) or
      ((select isnull(contract_vehical.start_kms,0) from
        contract_vehical where
        contract_vehical.contract_no = cr_contract_no and
        contract_vehical.contract_seq_number = cr_contract_seq_number and
        contract_vehical.vehicle_number = vehicle_no )+
      isnull((con_distance_at_renewal*datediff(day,con_start_date,con_expiry_date)/365),200001) > 200000))) 
order by
rgn_name asc,
con_expiry_date asc,
vage desc,
contract_no asc 



end













GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetCustomerCount : 
--

--
-- Definition for stored procedure sp_GetCustomerCount : 
--

CREATE procedure [rd].[sp_GetCustomerCount](@inRegion int,@inOutlet int,@inContractType int,@inRenewalGroup int)
-- TJB  SR4659  July 2005
as -- Added lookup and return of CMB kiwimail count.
begin
  select region.rgn_name,
    outlet.o_name,
    contract.con_title,
    contract.contract_no,
    resident=rd.f_GetCustomerKiwimailCount(contract.contract_no,'R'),
    business=rd.f_GetCustomerKiwimailCount(contract.contract_no,'B'),
    farmer=rd.f_GetCustomerKiwimailCount(contract.contract_no,'F'),
    unclassified=rd.f_GetCustomerKiwimailCount(contract.contract_no,'X'),
    cmb=rd.f_GetCustomerKiwimailCount(contract.contract_no,'C') from
    contract,
    outlet,
    region where
    region.region_id = outlet.region_id and
    contract.con_base_office = outlet.outlet_id and
    ((region.region_id = @inRegion and @inRegion > 0) or(@inRegion is null)) and
    ((outlet.outlet_id = @inOutlet and @inOutlet > 0) or(@inOutlet is null)) and
    (rg_code = @inRenewalGroup or @inRenewalGroup = -1) and
    contract.contract_no > 0 and
    con_date_terminated is null and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) order by
    region.rgn_name asc,
    outlet.o_name asc,
    contract.contract_no asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure updatephones : 
--

CREATE procedure [rd].[updatephones]
as
begin
  update contractor set c_phone_day = rd.f_transform_telno(c_phone_day) where c_phone_day is not null
  if @@ERROR < 0
    begin
      rollback transaction
      return(-1)
    end
  commit transaction
  update contractor set c_phone_night = rd.f_transform_telno(c_phone_night) where c_phone_night is not null
  if @@ERROR < 0
    begin
      rollback transaction
      return(-2)
    end
  commit transaction
  update contract_renewals set con_relief_driver_home_phone = rd.f_transform_telno(con_relief_driver_home_phone) where con_relief_driver_home_phone is not null
  if @@ERROR < 0
    begin
      rollback transaction
      return(-3)
    end
  commit transaction
  update outlet set o_telephone = rd.f_transform_telno(o_telephone) where o_telephone is not null
  if @@ERROR < 0
    begin
      rollback transaction
      return(-4)
    end
  commit transaction
  update outlet set o_fax = rd.f_transform_telno(o_fax) where o_fax is not null
  if @@ERROR < 0
    begin
      rollback transaction
      return(-5)
    end
  commit transaction
  update region set rgn_telephone = rd.f_transform_telno(rgn_telephone) where rgn_telephone is not null
  if @@ERROR < 0
    begin
      rollback transaction
      return(-6)
    end
  commit transaction
  update region set rgn_fax = rd.f_transform_telno(rgn_fax) where rgn_fax is not null
  if @@ERROR < 0
    begin
      rollback transaction
      return(-7)
    end
  commit transaction
  update userids set u_phone = rd.f_transform_telno(u_phone) where u_phone is not null
  if @@ERROR < 0
    begin
      rollback transaction
      return(-8)
    end
  commit transaction
  update customer set cust_phone_day = rd.f_transform_telno(cust_phone_day) where cust_phone_day is not null
  if @@ERROR < 0
    begin
      rollback transaction
      return(-9)
    end
  commit transaction
  update customer set cust_phone_night = rd.f_transform_telno(cust_phone_night) where cust_phone_night is not null
  if @@ERROR < 0
    begin
      rollback transaction
      return(-10)
    end
  commit transaction
  return 0
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure  [odps].[OD_RPS_YearlyEarnings](@sdate datetime,@edate datetime,@inregion int)
as
begin
 
    select distinct region=(select rgn_name from rd.region where region.region_id = outlet.region_id),
    [contract].contract_no,
    name=c_surname_company + case  when c_initials is null then '' else ', ' + c_initials end,
    contractor.c_ird_no,
    grossearnings=(select odps.OD_RPF_PCYearlyEarnings(contractor.contractor_supplier_no,[contract].contract_no,contractor_renewals.contract_seq_number,@sdate,@edate,'GP',null)+odps.OD_RPF_PCYearlyEarnings(contractor.contractor_supplier_no,[contract].contract_no,contractor_renewals.contract_seq_number,@sdate,@edate,'OGP',null)  ), --!added 2 null in 2 functions' parameter lists
    WithholdingTax=(select odps.OD_RPF_PCGetSumYear(contractor.contractor_supplier_no,[contract].contract_no,contractor_renewals.contract_seq_number,@sdate,@edate,'TAX',null)  ),
    GST=(select-1* odps.OD_RPF_PCGetSumYear(contractor.contractor_supplier_no,[contract].contract_no,contractor_renewals.contract_seq_number,@sdate,@edate,'GST',null)  ) from
    rd.[contract],
    rd.outlet,
    rd.contractor,
    rd.contractor_renewals where
    ([contract].con_base_office = outlet.outlet_id) and
    (contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no) and
    ([contract].contract_no = contractor_renewals.contract_no) and
    ((outlet.region_id = @inregion and @inregion > 
    0) or(@inregion = 
    0)) and
    exists(select payment.contractor_supplier_no from
      payment where
      (payment.contract_no = [contract].contract_no) and
      (payment.contractor_supplier_no = contractor.contractor_supplier_no) and
      (payment.contract_seq_number = contractor_renewals.contract_seq_number) and
      ((payment.invoice_date between @sdate and @edate))) 

end


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--THE EVALUATION VERSION TRIMS COLUMN NAMES AND VARIABLES TO 7 CHARACTERS
--
CREATE procedure [odps].[OD_BLF_Mainrun_Accept] @enddat DATETIME ,@SWP_Re INT OUTPUT 
AS
begin
   declare @v_payment_count INT
   declare @v_payment_component_count INT
   declare @v_payment_pr_count INT
   declare @v_max_invoice_no INT
   declare @v_max_invoice_id INT
   declare @v_max_pc_id INT
   declare @v_max_pcpr_id INT
   declare @v_contractor INT
   declare @v_contract INT
   DECLARE @SWV_er INT
BEGIN TRANSACTION
BEGIN TRY
      update odps.t_payment_component set pc_amount = odps.t_payment_component.pc_amount*-1  where
      odps.t_payment_component.pct_id =(select max(odps.Payment_Component_Type.pct_id) from
      odps.payment_component_group,
      odps.Payment_Component_Type where
      odps.Payment_Component_Type.pcg_id = odps.payment_component_group.pcg_id and
      odps.payment_component_group.pcg_short_code = 'GST' and
      odps.Payment_Component_Type.pct_description like 'GST%')
      if ERROR_NUMBER() < 0
      begin
         rollback 
         set @SWP_Re = -2000
         RETURN 
      end
  -- get contractor and contract no for date validations
      select  top 1 @v_contractor = contractor_supplier_no,@v_contract = contract_no  from odps.t_payment
  -- TWC - 15/09/2003 - check date against contractor tenure dates.
      update rd.contract_adjustments set ca_date_paid = @enddat  where
      exists(select odps.t_payment.contract_no from
      odps.t_payment where
      odps.t_payment.contract_no = rd.contract_adjustments.contract_no and
      rd.contract_adjustments.ca_date_occured <= rd.getContractorEnd(odps.t_payment.contract_no,odps.t_payment.contractor_supplier_no) and -- end date of contractor
      rd.contract_adjustments.ca_date_occured >= rd.getContractorStart(odps.t_payment.contract_no,odps.t_payment.contractor_supplier_no)) and -- start date of contractor 
    --and t_payment.contract_seq_number=contract_adjustments.contract_seq_number
      ca_confirmed = 'Y' and
      ca_date_occured <= @enddat and
      ca_date_paid is null
      if ERROR_NUMBER() < 0
      begin
         rollback 
         set @SWP_Re = -2005
         RETURN 
      end
      update rd.frequency_adjustments set fd_paid_to_date = @enddat  where
      exists(select odps.t_payment.contract_no from
      odps.t_payment where
      odps.t_payment.contract_no = rd.frequency_adjustments.contract_no and
      odps.t_payment.contract_seq_number = rd.frequency_adjustments.contract_seq_number) and
      fd_paid_to_date is null and
      fd_confirmed = 'Y' and
      fd_effective_date <=(select max(invoice_date) from odps.t_payment)
      if ERROR_NUMBER() < 0
      begin
         rollback 
         set @SWP_Re = -2010
         RETURN
      end
      update rd.contract_allowance set ca_paid_to_date = @enddat  where
      exists(select odps.t_payment.contract_no from odps.t_payment where odps.t_payment.contract_no = rd.contract_allowance.contract_no) and
      ca_effective_date <=(select max(invoice_date) from odps.t_payment) and
      ca_paid_to_date is null
      if ERROR_NUMBER() < 0
      begin
         rollback 
         set @SWP_Re = -2020
         RETURN
      end
      --!update odps.t_payment_runs set pr_id =(select isnull(max(pr_id),0)+1 from odps.payment_runs)
      /*Cannot update identity column 'pr_id' in MSSQL */
	  if ERROR_NUMBER() < 0
      begin
         rollback 
         set @SWP_Re = -2030
         RETURN
      end
      insert into odps.payment_runs select (select isnull(max(pr_id),0)+1 from odps.payment_runs),
      pr_date,gl_posted,pr_ap_posted,pr_contract_no,POTS from odps.t_payment_runs
      if ERROR_NUMBER() < 0
      begin
         rollback 
         set @SWP_Re = -2040
         RETURN
      end
      select @v_payment_count = 1   where exists(select 1 from odps.Payment)
      if @v_payment_count = 0 or @v_payment_count is null
      begin
         insert into odps.Payment select contractor_supplier_no,contract_no,contract_seq_number,invoice_id,pr_id,invoice_date,Witholding_tax_rate_applied,invoice_id,case_no,
         POTS from odps.t_payment
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2050
            RETURN
         end
         insert into odps.post_tax_deductions_applied(pcd_amount,ded_id,pcd_date,invoice_id) select /*null,*/pcd_amount,ded_id,pcd_date,invoice_id from odps.t_post_tax_deductions_applied
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2051
            RETURN
         end
      end
      else
      begin
         select @v_max_invoice_no = max(invoice_no)  from odps.Payment where invoice_date = @enddat
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2051
            RETURN
         end
         select @v_max_invoice_id = max(invoice_id)  from odps.Payment
         if @v_max_invoice_no = 0 or @v_max_invoice_no is null
         begin
            set @v_max_invoice_no = 0
         end
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2055
            RETURN
         end
         insert into odps.Payment select contractor_supplier_no,contract_no,contract_seq_number,invoice_id+@v_max_invoice_id,pr_id,invoice_date,Witholding_tax_rate_applied,/*number(*)*/ (ROW_NUMBER()  OVER (ORDER BY contract_no ASC)) +@v_max_invoice_no,
         case_no,POTS from odps.t_payment
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2080
            RETURN
         end
         if ((select count(*)from odps.t_post_tax_deductions_applied) <>0) --jlwang:added
           insert into odps.post_tax_deductions_applied(pcd_amount,ded_id,pcd_date,invoice_id) select /*null,*/pcd_amount,ded_id,pcd_date,invoice_id+@v_max_invoice_id from odps.t_post_tax_deductions_applied
      end
      select @v_payment_component_count = 1   where exists(select 1 from odps.Payment_Component)
      if ERROR_NUMBER() < 0
      begin
         rollback 
         set @SWP_Re = -2085
         RETURN
      end
      if @v_payment_component_count = 0 or @v_payment_component_count is null
      begin
         insert into odps.Payment_Component select* from odps.t_payment_component where pc_amount <> 0
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2090
            RETURN
         end
      end
      else
      begin
         select @v_max_pc_id = max(pc_id)+1  from odps.Payment_Component
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2095
            RETURN 
         end
--         --!update odps.t_payment_component set pc_id =(pc_id+@v_max_pc_id)*-1
--         if ERROR_NUMBER() < 0
--         begin
--            rollback 
--            set @SWP_Re = -2100
--            RETURN 
--         end
--         --!update odps.t_payment_component set pc_id = pc_id*-1
--         if ERROR_NUMBER() < 0
--         begin
--            rollback 
--            set @SWP_Re = -2120
--            RETURN 
--         end
  --jlwang
           set @v_max_pc_id= @v_max_pc_id+2
           DBCC CHECKIDENT ('odps.t_payment_component', RESEED,  @v_max_pc_id)
  
           insert t_payment_component select pct_id,invoice_id,pc_amount,comments,misc_date,misc_string,misc_decimal from t_payment_component
           delete from t_payment_component where pc_id < @v_max_pc_id-2
   --jlwang:end
         insert into odps.Payment_Component select pc_id,pct_id,invoice_id+@v_max_invoice_id,pc_amount,comments,misc_date,misc_String,misc_decimal from odps.t_payment_component where pc_amount <> 0
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2130
            RETURN 
         end
      end
      select @v_payment_pr_count = 1   where exists(select 1 from odps.Payment_component_piece_rates)
      if ERROR_NUMBER() < 0
      begin
         rollback 
         set @SWP_Re = -2140
         RETURN
      end
      if @v_payment_pr_count = 0 or @v_payment_pr_count is null
      begin
         if ((select count(*) from odps.t_payment_component_piece_rates) >0) --added
         begin  --added
         insert into odps.Payment_component_piece_rates(prt_key,pc_id,pcpr_volume,pcpr_value) select prt_key,pc_id,pcpr_volume,pcpr_value from odps.t_payment_component_piece_rates
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2150
            RETURN
         end
         end --added
      end
      else
      begin
         select @v_max_pcpr_id = max(pcpr_id)+1  from odps.Payment_component_piece_rates
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2160
            RETURN
         end
         --!update odps.t_payment_component_piece_rates set pcpr_id =(pcpr_id+@v_max_pcpr_id)*-1
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2170
            RETURN 
         end
         --!update odps.t_payment_component_piece_rates set pcpr_id = pcpr_id*-1
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2180
            RETURN 
         end
         insert into odps.Payment_component_piece_rates(prt_key,pc_id,pcpr_volume,pcpr_value) select prt_key,pc_id,pcpr_volume,pcpr_value from odps.t_payment_component_piece_rates
         if ERROR_NUMBER() < 0
         begin
            rollback 
            set @SWP_Re = -2190
            RETURN
         end
      end
  -- TWC - 15/09/2003 check prd_date against contractors tenure dates
      update rd.piece_rate_delivery set prd_paid_to_date = @enddat  where
      exists(select odps.Payment.contract_no from odps.Payment where
      odps.Payment.contract_no = rd.piece_rate_delivery.contract_no and
      rd.piece_rate_delivery.prd_date <= rd.getContractorEnd(odps.Payment.contract_no,odps.Payment.contractor_supplier_no) and -- end date
      rd.piece_rate_delivery.prd_date >= rd.getContractorStart(odps.Payment.contract_no,odps.Payment.contractor_supplier_no)) and -- start date
      prd_paid_to_date is null and
      prd_date between(select min(sdate) from odps.t_piecerate_tracker where odps.t_piecerate_tracker.contract_no = rd.piece_rate_delivery.contract_no)
      and(select max(edate) from odps.t_piecerate_tracker where odps.t_piecerate_tracker.contract_no = rd.piece_rate_delivery.contract_no)
      if ERROR_NUMBER() < 0
      begin
         rollback 
         set @SWP_Re = -2191
         RETURN
      end
      commit work
      set @SWP_Re = 1
      RETURN

   END TRY
BEGIN CATCH
      rollback 
      SET @SWV_er = ERROR_NUMBER()
--      RAISERROR(@SWV_er,16,1)
      set @SWP_Re = -1
      
      RETURN
   END CATCH
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure  [odps].[OD_BLF_Mainrun_Grosspay_Piecerates](@incontract_no int,@inSequence_no int,@inPayPeriod_Start datetime,@inPayPeriod_End datetime,@InvoiceNumber int,@in_PrType char(1),@v_contractor_contract_start datetime,@v_contractor_contract_end datetime,@incontractor_no int)
as
begin
	declare @p_pieceratetype int,
		@p_piecerateqty int,
		@p_pieceratecost numeric(12,2),
		@p_pieceratetotcost numeric(12,2),
		@p_pct_id int,
		@v_tempint int,
		@vt_sdate datetime,
		@vt_edate datetime,
		@ComponentNumber int,
		@pcom_number int,
		@period_nat_id int
	declare @int_temp int
	declare @str_temp varchar(40)
	declare c_AdPost cursor for select piece_rate_type.prt_key from rd.piece_rate_supplier piece_rate_supplier,rd.piece_rate_type  piece_rate_type
		where piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 1
	declare c_CourierPost cursor for select piece_rate_type.prt_key from rd.piece_rate_supplier piece_rate_supplier,rd.piece_rate_type piece_rate_type
		where piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 2
	declare c_XP cursor for select piece_rate_type.prt_key from rd.piece_rate_supplier piece_rate_supplier, rd.piece_rate_type piece_rate_type
		where piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 3
	declare c_ParcelPost cursor for select piece_rate_type.prt_key from rd.piece_rate_supplier piece_rate_supplier,rd.piece_rate_type piece_rate_type
		where piece_rate_type.prs_key = piece_rate_supplier.prs_key and piece_rate_supplier.prs_key = 4
	select @p_pieceratetotcost=0.0
	if @in_PrType = 'A' open c_AdPost
	if @in_PrType = 'C' open c_CourierPost
	if @in_PrType = 'X' open c_XP
	if @in_PrType = 'P' open c_ParcelPost
	if @@error <> 0 
	begin
		deallocate c_AdPost
		deallocate c_CourierPost
		deallocate c_XP
		deallocate c_ParcelPost
		return(-1010)
	end
	select @ComponentNumber = max(pc_id)+1 from t_payment_component
	if @@ERROR <> 0 
	begin
		deallocate c_AdPost
		deallocate c_CourierPost
		deallocate c_XP
		deallocate c_ParcelPost
		return(-1020)
	end
	if @ComponentNumber is null select @ComponentNumber=1
	if @ComponentNumber <= 0 select @ComponentNumber=1
	select @period_nat_id=(select odps.od_blf_getwhichnational(@inPayPeriod_End) )
	if @in_PrType = 'A'
		begin
			select @p_pct_id = pct_id from rd.piece_rate_supplier where prs_key = 1
			if @@ERROR <> 0 
			begin
				deallocate c_AdPost
				deallocate c_CourierPost
				deallocate c_XP
				deallocate c_ParcelPost
				return(-1019)
			end
			select @int_temp = nat_AdPost_DefaultComptype from "national" 
				where nat_id = (select odps.od_blf_getwhichnational(@inPayPeriod_End) )
			select @int_temp = isnull(@p_pct_id,@int_temp)
			select @str_temp = prs_description from rd.piece_rate_supplier where prs_key = 1
			insert into t_payment_component(/*pc_id,*/pct_id,invoice_id,pc_amount,comments) 
				values (/*@ComponentNumber,*/@int_temp,@InvoiceNumber,0,@str_temp)
      if @@ERROR <> 0
		begin
		deallocate c_AdPost
		deallocate c_CourierPost
		deallocate c_XP
		deallocate c_ParcelPost
        return(-1021)
		end
    end
  if @in_PrType = 'C'
    begin
      select @p_pct_id = pct_id
        from rd.piece_rate_supplier where
        prs_key = 2
      if @@ERROR <> 0
		begin
		deallocate c_AdPost
		deallocate c_CourierPost
		deallocate c_XP
		deallocate c_ParcelPost
        return(-1023)
		end
select @int_temp = nat_AdPost_DefaultComptype from
          "national" where
          nat_id = (select odps.od_blf_getwhichnational(@inPayPeriod_End)  )
       select @str_temp = prs_description from rd.piece_rate_supplier where
          prs_key = 2
      insert into t_payment_component(/*pc_id,*/pct_id,invoice_id,pc_amount,comments)
		values(/*@ComponentNumber,*/isnull(@p_pct_id,@int_temp),@InvoiceNumber,0,@str_temp)
    end
  if @in_PrType = 'X'
    begin
      select @p_pct_id = pct_id
        from rd.piece_rate_supplier where
        prs_key = 3
      if @@ERROR <> 0
		begin
			deallocate c_AdPost
			deallocate c_CourierPost
			deallocate c_XP
			deallocate c_ParcelPost
			return(-1123)
		end
        select @str_temp = prs_description from rd.piece_rate_supplier where
          prs_key = 3
         insert into t_payment_component(/*pc_id,*/pct_id,invoice_id,pc_amount,comments) 
		values(/*@ComponentNumber,*/ @p_pct_id,@InvoiceNumber,0,@str_temp)
    end
  if @in_PrType = 'P'
    begin
      select @p_pct_id = pct_id  
        from rd.piece_rate_supplier where
        prs_key = 4
      if @@ERROR <> 0
		begin
			deallocate c_AdPost
			deallocate c_CourierPost
			deallocate c_XP
			deallocate c_ParcelPost
			return(-1133)
		end
select @int_temp = nat_AdPost_DefaultComptype from
          "national" where
          nat_id = (select odps.od_blf_getwhichnational(@inPayPeriod_End) )
select @str_temp = prs_description from rd.piece_rate_supplier where
          prs_key = 4
      insert into t_payment_component(/*pc_id,*/pct_id,invoice_id,pc_amount,comments) 
		values(/*@ComponentNumber,*/isnull(@p_pct_id,@int_temp),@InvoiceNumber,0,@str_temp)
    end
  if @@ERROR <> 0
	begin
		deallocate c_AdPost
		deallocate c_CourierPost
		deallocate c_XP
		deallocate c_ParcelPost
		return(-1030)
	end
while 1=1 
    begin
      if @in_PrType = 'A'
        fetch next from c_AdPost into @p_pieceratetype
      if @in_PrType = 'C'
        fetch next from c_CourierPost into @p_pieceratetype
      if @in_PrType = 'X'
        fetch next from c_XP into @p_pieceratetype
      if @in_PrType = 'P'
        fetch next from c_ParcelPost into @p_pieceratetype
      if @@FETCH_STATUS <0 or @@ERROR <> 0
        break
      select 
        @p_pieceratecost = sum(prd_cost),
        @p_piecerateqty = sum(prd_quantity)
         from rd.piece_rate_delivery,
        rd.[contract],
        rd.contract_renewals join rd.contractor_renewals on
		contract_renewals.contract_no = contractor_renewals.contract_no and 
		contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number  where
        contract.contract_no = piece_rate_delivery.contract_no and
        contract_renewals.contract_no = contract.contract_no and
        contract_renewals.contract_seq_number = rd.maxSeqContractor(contract.contract_no,contractor_renewals.contractor_supplier_no) and
        (rd.getContractorEnd(contract.contract_no,contractor_renewals.contractor_supplier_no) >= dateadd(month,-3,@inPayPeriod_End)) and
        piece_rate_delivery.prt_key = @p_pieceratetype and
        contract.contract_no = @incontract_no and
        contractor_renewals.contractor_supplier_no = @incontractor_no and
        prd_date <= odps.OD_MiscF_GetLastDayofMonth(@inPayPeriod_start) and
        prd_date >= rd.getContractorStart(contract.contract_no,contractor_renewals.contractor_supplier_no) and
        prd_date <= rd.getContractorEnd(contract.contract_no,contractor_renewals.contractor_supplier_no) and
        prd_date <= @inPayPeriod_End and
        contract_renewals.con_rates_effective_date <= @inPayPeriod_End and
        piece_rate_delivery.prd_paid_to_date is null
      if @@ERROR <> 0
		begin
			deallocate c_AdPost
			deallocate c_CourierPost
			deallocate c_XP
			deallocate c_ParcelPost
			return(-1040)
		end
      if @p_pieceratecost <> 0.0 or @p_piecerateqty <> 0.0
        begin
          select @pcom_number = max(pcpr_id)+1
            from t_payment_component_piece_rates
          if @pcom_number <= 0
			begin
				deallocate c_AdPost
				deallocate c_CourierPost
				deallocate c_XP
				deallocate c_ParcelPost
				return(-1050)
			end
          if @pcom_number is null
            select @pcom_number=1
         insert into t_payment_component_piece_rates(/*pcpr_id,*/prt_key,pc_id,pcpr_volume,pcpr_value) 
			values(/*@pcom_number,*/ @p_pieceratetype,@ComponentNumber,@p_piecerateqty,@p_pieceratecost)
          if @@ERROR <> 0
			begin
				deallocate c_AdPost
				deallocate c_CourierPost
				deallocate c_XP
				deallocate c_ParcelPost
				return(-1060)
			end
          insert into odps.t_piecerate_tracker values(@incontract_no,@v_contractor_contract_start,odps.OD_MiscF_GetLastDayofMonth(@inPayPeriod_start))
          if @@ERROR <> 0
			begin
				deallocate c_AdPost
				deallocate c_CourierPost
				deallocate c_XP
				deallocate c_ParcelPost
				return(-1061)
			end
        end
      else
        select @p_pieceratecost=0.0
      select @p_pieceratetotcost=@p_pieceratetotcost+@p_pieceratecost
    end
  if @@ERROR <> 0
	begin
		deallocate c_AdPost
		deallocate c_CourierPost
		deallocate c_XP
		deallocate c_ParcelPost
		return(-1075)
	end
  if @in_PrType = 'A'
    close c_AdPost
  if @in_PrType = 'C'
    close c_CourierPost
  if @in_PrType = 'X'
    close c_XP
  if @in_PrType = 'P'
    close c_ParcelPost

  if @p_pieceratetotcost <> 0
    begin
      update t_payment_component set pc_amount = @p_pieceratetotcost 
		where t_payment_component.pc_id = @ComponentNumber
      if @@ERROR <> 0
		begin
			deallocate c_AdPost
			deallocate c_CourierPost
			deallocate c_XP
			deallocate c_ParcelPost
			return(-1070)
		end
    end
  else
    begin   
     delete from t_payment_component where pc_id = @ComponentNumber
    --add 
     if (@ComponentNumber >1)
          select @ComponentNumber=@ComponentNumber-1
      DBCC CHECKIDENT ('odps.t_payment_component', RESEED,@ComponentNumber )
    --add end
      if @@ERROR <> 0
		begin
			deallocate c_AdPost
			deallocate c_CourierPost
			deallocate c_XP
			deallocate c_ParcelPost
	        return(-1080)
		end
    end

deallocate c_AdPost
deallocate c_CourierPost
deallocate c_XP
deallocate c_ParcelPost
  return(0)
/* Watcom only
exception
  when others then
    rollback transaction
    resignal
    return(-1)
*/
end




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for stored procedure OD_DWS_OwnerDriver_Search : 
--

CREATE procedure
-- TWC - 11/08/2003 -- changing this procedure to handle contractor / renewal changes
[odps].[OD_DWS_OwnerDriver_Search](@inOwnerDriver varchar(40),@sdate datetime,@edate datetime)
as
begin
  select top 1 0,0,odcontracts='<All Contractors/Contracts>',enddate=rd.date(rd.today())  union
  select distinct contract.contract_no,
    contractor.contractor_supplier_no,
    c_surname_company + (case when len(c_first_names) > 0 then ',' + c_first_names else '' end),contractor_end_date=(select dateadd(day,-1,min(crx.cr_effective_date)) from
      rd.contractor_renewals as crx where
      crx.contract_no = contract_renewals.contract_no and
      crx.contract_seq_number = contract_renewals.contract_seq_number and
      crx.cr_effective_date > contractor_renewals.cr_effective_date) from
    rd.contract,
    rd.contract_renewals,
    rd.contractor,
    rd.contractor_renewals where
    (contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no) and
    (contractor_renewals.contract_no = contract_renewals.contract_no) and
    (contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number) and
    -- TWC - if a renewal has gone through - old renewal may be part of this period
    -- (contract.con_active_sequence = contract_renewals.contract_seq_number) and
    (contract_renewals.contract_seq_number = rd.maxSeqContractor(contractor_renewals.contract_no,contractor_renewals.contractor_supplier_no)) and
    (contract.contract_no = contract_renewals.contract_no) and
    (contractor.c_surname_company like ISNULL(@inOwnerDriver,'') + '%') and
    (contract.con_date_terminated is null or contract.con_date_terminated > @edate or datediff(day,con_date_terminated,@sdate) < 63) and
    (contractor_renewals.cr_effective_date <= @edate) and
    -- check that the end date of the contract is smaller than the end date
    (rd.getContractorEnd(contract.contract_no,contractor.contractor_supplier_no) >= dateadd(month,-2,@sdate)) and
    (/*contractor_end_date*/(select dateadd(day,-1,min(crx.cr_effective_date)) from
      rd.contractor_renewals as crx where
      crx.contract_no = contract_renewals.contract_no and
      crx.contract_seq_number = contract_renewals.contract_seq_number and
      crx.cr_effective_date > contractor_renewals.cr_effective_date) > @edate or /*contractor_end_date*/(select dateadd(day,-1,min(crx.cr_effective_date)) from
      rd.contractor_renewals as crx where
      crx.contract_no = contract_renewals.contract_no and
      crx.contract_seq_number = contract_renewals.contract_seq_number and
      crx.cr_effective_date > contractor_renewals.cr_effective_date) is null or datediff(day,/*contractor_end_date*/(select dateadd(day,-1,min(crx.cr_effective_date)) from
      rd.contractor_renewals as crx where
      crx.contract_no = contract_renewals.contract_no and
      crx.contract_seq_number = contract_renewals.contract_seq_number and
      crx.cr_effective_date > contractor_renewals.cr_effective_date),@sdate) < 63)
end






GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_IR68A_IR68P : 
--

CREATE procedure [odps].[OD_RPS_IR68A_IR68P](@sdate datetime,@edate datetime)
as
begin
  select distinct a=contractor_renewals.contract_no,
    b=contractor.c_surname_company,
    c=contractor.c_first_names,
    d=contractor.c_initials,
    GPTaxable=odps.OD_RPF_PCYearlyEarnings(contractor.contractor_supplier_no,contract_renewals.contract_no,contract_renewals.contract_seq_number,@sdate,@edate,'GP','Y')+
    odps.OD_RPF_PCYearlyEarnings(contractor.contractor_supplier_no,contract_renewals.contract_no,contract_renewals.contract_seq_number,@sdate,@edate,'OGP','Y'),
    GPNonTaxable=odps.OD_RPF_PCYearlyEarnings(contractor.contractor_supplier_no,contract_renewals.contract_no,contract_renewals.contract_seq_number,@sdate,@edate,'GP','N')+
    odps.OD_RPF_PCYearlyEarnings(contractor_renewals.contractor_supplier_no,contractor_renewals.contract_no,contractor_renewals.contract_seq_number,@sdate,@edate,'OGP','N'),
    Paye=abs(odps.OD_RPF_PCGetSumYear_spec(contractor.contractor_supplier_no,contract_renewals.contract_no,contract_renewals.contract_seq_number,@sdate,@edate,'TAX',null)),  --!added a 'null' to the default parameter
    ACC=(select((nat_acc_percentage/100)) from [national] where nat_id = odps.OD_BLF_GetWhichNational(@edate)) from
    rd.contractor,rd.contractor_renewals,rd.contract_renewals where
    contractor.contractor_supplier_no = contractor_renewals.contractor_supplier_no and
    contract_renewals.contract_no = contractor_renewals.contract_no and
    (contract_renewals.con_expiry_date is null or contract_renewals.con_expiry_date > @sdate) and
    contract_renewals.contract_seq_number = contractor_renewals.contract_seq_number order by
    contractor_renewals.contract_no asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_Invoice_pay : 
--

CREATE procedure [odps].[OD_RPS_Invoice_pay](
@invoiceid int,
@enddate datetime,
@insupplier int,
@incontract_no int)
as
begin
  -- 1/June/06 TJB  SR4684
  -- Added handling of ParcelPost (prs_key = 4)
  --
  -- 18/May/06 TJB  SR4685
  -- Reformatted to make it legible and removed large commented-out section.
  --
  -- 18/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from sql code.  
  -- Used the corresponding payment_component_type.prs_key instead.
  select m_standard=(select isnull(sum(pc_amount),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Contract payment value%' or
      payment_component_type.pct_description like 'Frequency Adjustment%') and
      (payment.invoice_id = @invoiceid) and
      (left(payment_component.comments,6) <> 'Arrear'))),
    m_allowance=(select isnull(sum(pc_amount),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Contract allowance%' and
      left(payment_component.comments,6) <> 'Arrear') and
      (payment.invoice_id = @invoiceid))),
    m_Taxable_adjustments=(select isnull(sum(pc_amount),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.prs_key = 1 or
      payment_component_type.prs_key = 2 or
      payment_component_type.prs_key = 3 or
      payment_component_type.prs_key = 4 or
      payment_component_type.pct_description like 'Contract Adjustment%' or
      ((payment_component_type.pct_description like 'Frequency Adjustment%' or
      payment_component_type.pct_description like 'Contract allowance%') and
      left(payment_component.comments,6) = 'Arrear')) and
      (payment.invoice_id = @invoiceid))),
    m_GST_rate=(select abs(isnull(nat_od_standard_gst_rate,12.5)) from
      "national" where
      nat_id = odps.od_blf_getwhichnational(@enddate)),
    m_GST_value=(select isnull(sum(pc_amount*-1),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'GST%') and
      (payment.invoice_id = @invoiceid))),
    m_wtax_rate=(select witholding_tax_rate_applied from
      payment where
      (payment.invoice_id = @invoiceid)),
    m_wtax_value=(select isnull(sum(pc_amount*-1),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Withholding Tax%') and
      (payment.invoice_id = @invoiceid))),
    m_adj_notax=(select isnull(sum(pc_amount*-1),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Post-Tax Adjustments%') and
      (payment.invoice_id = @invoiceid))),
    y_standard=(select isnull(sum(pc_amount),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Contract payment value%' or
      payment_component_type.pct_description like 'Frequency Adjustment%') and
      (left(payment_component.comments,6) <> 'Arrear') and
      (payment.contractor_supplier_no = @insupplier) and
      (payment.contract_no = @incontract_no) and
      (payment.invoice_date between odps.OD_MiscF_GetFinYear(@enddate,'S') and @enddate))),
    y_allowance=(select isnull(sum(pc_amount),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Contract allowance%' and
      left(payment_component.comments,6) <> 'Arrear') and
      (payment.contractor_supplier_no = @insupplier) and
      (payment.contract_no = @incontract_no) and
      (payment.invoice_date between odps.OD_MiscF_GetFinYear(@enddate,'S') and @enddate))),
    y_Taxable_adjustments=(select isnull(sum(pc_amount),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.prs_key = 1 or
      payment_component_type.prs_key = 2 or
      payment_component_type.prs_key = 3 or
      payment_component_type.prs_key = 4 or
      payment_component_type.pct_description like 'Contract Adjustment%' or
      ((payment_component_type.pct_description like 'Frequency Adjustment%' or
      payment_component_type.pct_description like 'Contract allowance%') and
      left(payment_component.comments,6) = 'Arrear')) and
      (payment.contractor_supplier_no = @insupplier) and
      (payment.contract_no = @incontract_no) and
      (payment.invoice_date between odps.OD_MiscF_GetFinYear(@enddate,'S') and @enddate))),
    y_GST_value=(select isnull(sum(pc_amount*-1),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'GST%') and
      (payment.contractor_supplier_no = @insupplier) and
      (payment.contract_no = @incontract_no) and
      (payment.invoice_date between odps.OD_MiscF_GetFinYear(@enddate,'S') and @enddate))),
    y_wtax_value=(select isnull(sum(pc_amount*-1),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Withholding Tax%') and
      (payment.contractor_supplier_no = @insupplier) and
      (payment.contract_no = @incontract_no) and
      (payment.invoice_date between odps.OD_MiscF_GetFinYear(@enddate,'S') and @enddate))),
    y_adj_notax=(select isnull(sum(pc_amount*-1),0) from
      payment,
      payment_component,
      payment_component_type where
      (payment_component.invoice_id = payment.invoice_id) and
      (payment_component_type.pct_id = payment_component.pct_id) and
      ((payment_component_type.pct_description like 'Post-Tax Adjustments%') and
      (payment.contractor_supplier_no = @insupplier) and
      (payment.contract_no = @incontract_no) and
      (payment.invoice_date between odps.OD_MiscF_GetFinYear(@enddate,'S') and @enddate))) 
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for user-defined function OD_BLF_GetTaxRate : 
--

CREATE function [odps].[OD_BLF_GetTaxRate](@inContractor int,@effective_date datetime)
returns decimal(12,2)
as
begin
  declare @OD_Taxrate decimal(5,2),
  @tax_certificate char(20),
  @IR13_TaxRate decimal(5,2),
  @NoIR13_TaxRate decimal(5,2),
  @Standard_TaxRate decimal(5,2)
  select @tax_certificate = contractor.c_witholding_tax_certificate,@OD_TaxRate = c_tax_rate from rd.contractor where
    contractor.contractor_supplier_no = @inContractor
  if @@error <> 0 /* <> was < */
    return(-1)
  if @tax_certificate is null
    select @tax_certificate='N'
  if @OD_TaxRate is null
    select @OD_TaxRate=0
  select @Standard_TaxRate = isnull("national".nat_od_standard_gst_rate,0),
    @IR13_TaxRate = isnull("national".nat_od_tax_rate_ir13,0),
    @NoIR13_TaxRate = isnull("national".nat_od_tax_rate_no_ir13,0) from "national" where
    "national".nat_id = (select top 1 odps.od_blf_getwhichnational(@effective_date) from sysobjects)
  if @@rowcount = 0 /* was @@error =100 */
    begin
      select @IR13_TaxRate=0
      select @NoIR13_TaxRate=0
      select @Standard_TaxRate=0
    end
  if @@error <> 0 /* <> was < */
    return(-1)
  if @tax_certificate = 'X'
    return(0.0) else if @tax_certificate = 'Y'
    if @OD_TaxRate > 0
      return(@OD_TaxRate)
    else
      return(@IR13_TaxRate) else if @tax_certificate = 'N'
    return(@NoIR13_TaxRate)
  return(-1)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_BLF_Mainrun_GST : 
--

CREATE procedure  [odps].[OD_BLF_Mainrun_GST]
as
begin
  declare @v_pcfaker int,
  @v_ctr int,
  @v_invoiceid int,
  @v_taxrate numeric(12,2),
  @v_pct int
begin transaction
  declare vc_invoice_list2 cursor for select invoice_id from t_payment
  select @v_pct = pct_id from payment_component_type where(pct_description like 'GST%' or pct_description like 'Goods and Services Tax%')
  select @v_pcfaker = max(pc_id) from t_payment_component
  select @v_ctr=0
  select @v_taxrate=0.0
  open vc_invoice_list2
  /* Watcom only
  iloop2:
  */while 1=1 
    begin
      fetch next from vc_invoice_list2 into @v_invoiceid
      if @@error <> 0
        begin
		  deallocate vc_invoice_list2
          rollback transaction
          return(-909)
        end
      if @@FETCH_STATUS <0
        break
        /* Watcom only
        iloop2
        */
      select @v_ctr=@v_ctr+1
      insert into t_payment_component(/*pc_id,*/  --Cannot insert explicit value for identity column in table 't_payment_component' when IDENTITY_INSERT is set to OFF.
        pct_id,
        invoice_id,
        pc_amount,
        comments,misc_string,misc_decimal)
        select /*@v_pcfaker+@v_ctr,*/
          @v_pct,
          @v_invoiceid,
          (select sum(pc_amount) from
            t_payment_component as tpc,payment_component_type where
            tpc.invoice_id = @v_invoiceid and
            tpc.pct_id = payment_component_type.pct_id and
            (pct_description not like 'Withholding%' and pct_description not like 'Post-Tax%'))*
          (select isnull(nat_od_standard_gst_rate,12.5)/100 from "national" where nat_id = odps.od_blf_getwhichnational(t_payment.invoice_date)),'GST - ' + 
          (select case when nat_od_standard_gst_rate is not null then convert(varchar(40),nat_od_standard_gst_rate) + '% which is the standard rate in the national table'
            else 'set to 12.50% because the standard rate in the national table is null' end from "national" where nat_id = odps.od_blf_getwhichnational(t_payment.invoice_date)),'GST rate applied',
          (select isnull(nat_od_standard_gst_rate,12.5)/100 from "national" where nat_id = odps.od_blf_getwhichnational(t_payment.invoice_date)) from
          t_payment,rd.contractor where
          t_payment.invoice_id = @v_invoiceid and
          contractor.contractor_supplier_no = t_payment.contractor_supplier_no and
          len(rtrim(ltrim(c_gst_number))) > 0 and
          exists(select pc_amount from
            t_payment_component as tc where
            tc.invoice_id = @v_invoiceid)
      if @@ERROR <> 0
		begin
			deallocate vc_invoice_list2
			rollback transaction
			return(@@ERROR)
		end
    end
  close vc_invoice_list2
  if @@ERROR <> 0
    begin
	  deallocate vc_invoice_list2
      rollback transaction
      return(-101)
    end
deallocate vc_invoice_list2
commit transaction
  return(0)
/* Watcom only
exception
  when others then
    rollback transaction
    resignal
    return(-1)
*/
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




--
-- Definition for stored procedure od_rps_ir348header : 
--

CREATE procedure [odps].[od_rps_ir348header](@startdate datetime,@enddate datetime)
as
begin
  select HDR='HDR',IRD_No='0' + 
    left((select [national].nat_ird_no from [national] where nat_id = odps.od_BLF_getWhichNational(@enddate)),2)+
    substring((select [national].nat_ird_no from [national] where nat_id = odps.od_BLF_getWhichNational(@enddate)),4,3)+
    right((select [national].nat_ird_no from [national] where nat_id = odps.od_BLF_getWhichNational(@enddate)),3),
    Return_Period=convert(CHAR(10),odps.od_Miscf_GetLastDayofMonth(@enddate),112/*!'yyyymmdd'*/),Contact_Person='PR Drysdale',Contact_Phone='04 576 5220',Total_PAYE='0',Child_Support='0',Student_Loan='0',Family_Assistance='0',Gross='0',Not_Liable='0',Form_Version_No='0001'
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure OD_RPS_IR13_Interface_Header : 
--

CREATE procedure [odps].[OD_RPS_IR13_Interface_Header](@Procdate datetime)
as
begin
  select Name_of_Organisation='Rural Post',Trading_name='',Type_of_Service='Mail Contract Delivery',GST='N',
    Rural_Post_GST_Number=(select nat_rural_post_gst_no from [national] where [national].nat_id = (select odps.od_blf_getwhichnational(@procdate) /*!from dummy*/)),
    Rural_Post_Address=(select nat_rural_post_address from [national] where [national].nat_id = (select odps.od_blf_getwhichnational(@procdate) /*!from dummy*/)),
    Name_of_Payer=(select nat_rural_post_payer_name from [national] where [national].nat_id = (select odps.od_blf_getwhichnational(@procdate) /*!from dummy*/)),
    Date_Of_printing=getdate()--!today(*) from
    --!sys.dummy
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for user-defined function OD_MiscF_Get_ACID : 
--

CREATE function [odps].[OD_MiscF_Get_ACID](@inContract int)
returns char(30)
as
begin
  -- PBY 12/09/2002 SR#4456 
  -- Changed ACID data type from INT to VARCHAR(30)
  declare @ACID varchar(30)
  select @ACID = case when isnull(contract.ac_id,0) = 0 then (select ac2.ac_code from "national",account_codes as ac2 where "national".ac_id = ac2.ac_id and "national".nat_id = odps.od_blf_getwhichnational('2000-6-20')) 
		else (select ac.ac_code from account_codes as ac where ac.ac_id = contract.ac_id) end 
    from rd.contract where contract_no = @inContract
  return(@ACID)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for stored procedure OD_RPS_GL_Interface_for_AccrualsSummary_old : 
--

CREATE procedure [odps].[OD_RPS_GL_Interface_for_AccrualsSummary_old](@ProcDate datetime)
as
begin
  select pbu_code=pbu_code.pbu_code,
    account_number=account_codes.ac_code,
    transaction_amount=sum(abs(pc_amount))*.3548387096774,description='RD Accruals - Contract Price',drcr='D',
    trans=0,trans2=0 from
    rd.contract,
    payment,
    payment_component,
    payment_component_group,
    payment_component_type,
    account_codes,
    pbu_code where
    (contract.contract_no = payment.contract_no) and
    (payment_component.invoice_id = payment.invoice_id) and
    (payment_component_type.pcg_id = payment_component_group.pcg_id) and
    (payment_component_type.pct_id = payment_component.pct_id) and
    (pbu_code.pbu_id = contract.pbu_id) and
    (account_codes.ac_id = payment_component_type.ac_id) and
    (payment_component_group.pcg_short_code = 'GP' or
    payment_component_group.pcg_short_code = 'OGP') and
    payment.invoice_date = @procdate
    group by pbu_code.pbu_code,
    account_codes.ac_code union
  select pbu_code=isnull((select pbu_code.pbu_code from "national",pbu_code where nat_pbu_code_gst_gl = pbu_id and "national".nat_id = (select odps.od_blf_getwhichnational(@procdate)  )),'49999'),
    account_number=isnull((select account_codes.ac_code from account_codes,"national" where nat_ac_id_accrualBalance_gl = account_codes.ac_id and "national".nat_id = (select odps.od_blf_getwhichnational(@procdate)  )),'4250'),
    transaction_amount=abs(sum(pc_amount)*.3548387096774)*-1,description='RD Accruals - GST',drcr='C',
    trans=0,trans2=0 from
    rd.contract,
    payment,
    payment_component,
    payment_component_group,
    payment_component_type where
    (contract.contract_no = payment.contract_no) and
    (payment_component.invoice_id = payment.invoice_id) and
    (payment_component_type.pcg_id = payment_component_group.pcg_id) and
    (payment_component_type.pct_id = payment_component.pct_id) and
    (payment_component_group.pcg_short_code = 'GST') and
    payment.invoice_date = @procdate
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [odps].[OD_RPS_GL_Interface_for_Accruals](@ProcDate datetime)
as
begin
  BEGIN TRANSACTION
  delete from t_rps_gl_interface
  commit transaction

BEGIN TRANSACTION
  insert into t_rps_gl_interface(entity_id_1,
    journal_id_2,effective_date_3,journal_sequence_4,
    line_entity_id_6,rc_number_7,account_number_8,product_code_9,
    analysis_code_10,primary_dr_cr_code_11,transaction_amount_12,
    misc_cr_dr_code_13,misc_amount_14,jrnl_user_alpha_fld_15,
    date_created_16,description_17)
    select entity_id_1='101',journal_id_2='RDS_ACCRUAL',
      effective_date_3=rd.today(),
      journal_sequence_4=1,line_entity_id_6='101',
      rc_number_7=pbu_code.pbu_code,
      account_number_8=case when contract.ac_id is null then account_codes.ac_code else (select ac2.ac_code from account_codes as ac2 where
        ac2.ac_id = contract.ac_id) end,product_code_9=' ',analysis_code_10=' ',primary_dr_cr_code_11='D',
      transaction_amount_12=round(sum(pc_amount)*.3333333333333,2),misc_cr_dr_code_13=' ',
      misc_amount_14=0,
      jrnl_user_alpha_fld_15=pbu_code.pbu_code,
      date_created_16=rd.today(),description_17='RD Accruals Contract Price' from
      rd.contract,
      payment,
      payment_component,
      payment_component_group,
      payment_component_type,
      account_codes,
      pbu_code where
      contract.contract_no = payment.contract_no and
      payment_component.invoice_id = payment.invoice_id and
      payment_component_type.pcg_id = payment_component_group.pcg_id and
      payment_component_type.pct_id = payment_component.pct_id and
      pbu_code.pbu_id = contract.pbu_id and
      account_codes.ac_id = payment_component_type.ac_id and
      payment_component_group.pcg_short_code in('GP','OGP') and
      payment_component_type.pct_id <> 4 and
      payment_component_type.prs_key is null and
      payment.invoice_date = @procdate
      group by pbu_code.pbu_code,
      account_codes.ac_code,
      contract.ac_id
  if @@error < 0
    begin
      rollback transaction
      return(-100001000)
    end


  insert into t_rps_gl_interface(entity_id_1,
    journal_id_2,effective_date_3,journal_sequence_4,
    line_entity_id_6,rc_number_7,account_number_8,product_code_9,
    analysis_code_10,primary_dr_cr_code_11,transaction_amount_12,
    misc_cr_dr_code_13,misc_amount_14,jrnl_user_alpha_fld_15,
    date_created_16,description_17)
    select entity_id_1='101',journal_id_2='RDS_ACCRUAL',
      effective_date_3=rd.today(),
      journal_sequence_4=1,line_entity_id_6='101',
      isnull((select pbu_code.pbu_code from "national",pbu_code where
        nat_pbu_code_gst_gl = pbu_id and
        "national".nat_id = (select odps.od_blf_getwhichnational(@procdate)  )),'49999') as rc_number_7,
      account_number_8=isnull((select account_codes.ac_code from account_codes,"national" where
        nat_ac_id_accrualBalance_gl = account_codes.ac_id and
        "national".nat_id = (select odps.od_blf_getwhichnational(@procdate) )),'4250'),product_code_9=' ',analysis_code_10=' ',primary_dr_cr_code_11='C',
      transaction_amount_12=round(sum(pc_amount)*.3333333333333,2)*-1,misc_cr_dr_code_13=' ',
      misc_amount_14=0,
      jrnl_user_alpha_fld_15=isnull((select pbu_code.pbu_code from "national",pbu_code where
        nat_pbu_code_gst_gl = pbu_id and
        "national".nat_id = (select odps.od_blf_getwhichnational(@procdate)  )),'49999'), --gives jrnl_user_alpha_fld_15 the same value as rc_number_7's orgine
      date_created_16=rd.today(),description_17='RD Accruals' from
      rd.contract,
      payment,
      payment_component,
      payment_component_group,
      payment_component_type where
      contract.contract_no = payment.contract_no and
      payment_component.invoice_id = payment.invoice_id and
      payment_component_type.pcg_id = payment_component_group.pcg_id and
      payment_component_type.pct_id = payment_component.pct_id and
      payment_component_group.pcg_short_code in('GP','OGP') and
      payment_component_type.pct_id <> 4 and
      (not payment_component_type.pct_id = any(select pct_id from rd.piece_rate_supplier)) and
      payment.invoice_date = @procdate
  if @@error < 0
    begin
      rollback transaction
      return(-100001000)
    end
  commit transaction

  select entity_id_1,
    journal_id_2,
    effective_date_3,
    journal_sequence_4,
    ROW_NUMBER() OVER (ORDER BY entity_id_1 ASC),
    line_entity_id_6,
    rc_number_7,
    account_number_8,
    product_code_9,
    analysis_code_10,
    primary_dr_cr_code_11,
    transaction_amount_12,
    misc_cr_dr_code_13,
    misc_amount_14,
    jrnl_user_alpha_fld_15,
    date_created_16,
    description_17 from
    t_rps_gl_interface
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_NetPayVariance : 
--

CREATE procedure [odps].[OD_RPS_NetPayVariance](@sdate datetime,@edate datetime,@prevsdate datetime,@prevedate datetime)
/***********************************************************
* TJB SR4611, 5 Aug 2004
* Obsoleted.  See od_rps_GrossPayVariance
***********************************************************/
as
select payment.contract_no,
  contractor.c_surname_company,
  contractor.c_first_names,
  contractor.c_initials,
  LastMonth=(odps.OD_RPF_PCGetSumYear(payment.contractor_supplier_no,payment.contract_no,payment.contract_seq_number,@prevsdate,@prevedate,'GP',null)),
  /*Commented out so that the gross pay is what is calculated and not net pay,16/09/1999*/
  /*+OD_RPF_PCGetSumYear(payment.contractor_supplier_no,payment.contract_no,payment.contract_seq_number,@prevsdate,@prevedate,'OGP')*/
  /*+abs(OD_RPF_PCGetSumYear(payment.contractor_supplier_no,payment.contract_no,payment.contract_seq_number,@prevsdate,@prevedate,'GST'))*/
  /*-abs(OD_RPF_PCGetSumYear(payment.contractor_supplier_no,payment.contract_no,payment.contract_seq_number,@prevsdate,@prevedate,'TAX'))*/
  /*+OD_RPF_PCGetSumYear(payment.contractor_supplier_no,payment.contract_no,payment.contract_seq_number,@prevsdate,@prevedate,'PTA')),*/
  ThisMonth=(odps.OD_RPF_PCGetSum(payment.invoice_id,'GP')),
  /*Commented out so that the gross pay is what is calculated and not net pay,16/09/1999  */
  /*+OD_RPF_PCGetSum(payment.invoice_id,'OGP')*/
  /*+(OD_RPF_PCGetSum(payment.invoice_id,'GST')*-1)*/
  /*-abs(OD_RPF_PCGetSum(payment.invoice_id,'TAX'))*/
  /*+OD_RPF_PCGetSum(payment.invoice_id,'PTA')),*/
  wrate=(select nat_net_pct_change_warn from [national] where nat_id = odps.od_blf_getwhichnational(@edate)) from
  rd.contractor,payment where
  contractor.contractor_supplier_no = payment.contractor_supplier_no and
  payment.invoice_date between @sdate and @edate and 
  (((case when (odps.OD_RPF_PCGetSumYear(payment.contractor_supplier_no,payment.contract_no,payment.contract_seq_number,@prevsdate,@prevedate,'GP',null)) <> 0 then(abs((odps.OD_RPF_PCGetSum(payment.invoice_id,'GP'))-(odps.OD_RPF_PCGetSumYear(payment.contractor_supplier_no,payment.contract_no,payment.contract_seq_number,@prevsdate,@prevedate,'GP',null)))/(odps.OD_RPF_PCGetSumYear(payment.contractor_supplier_no,payment.contract_no,payment.contract_seq_number,@prevsdate,@prevedate,'GP',null)))*100 else 999999 end) >= 
  (select nat_net_pct_change_warn from [national] where nat_id = odps.od_blf_getwhichnational(@edate))))








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [odps].[OD_RPS_GL_Interface_for_Payment](@ProcDate datetime)
as
begin
  -- TJB  SR4684  June-2006
  -- Added handling of Parcel Post
  -- 18/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
  -- sql code.  Used the corresponding payment_component_type.prs_key instead.
  -- 03/10/2002 PBY DB Upgrade from 5.x to 8.0.1
  -- NUMBER(*) function is no longer valid when used inside a UNION clause.
  -- Temporary table t_rps_gl_interface is created instead to retain
  -- the original functionality.
  begin transaction
  delete from t_rps_gl_interface
  commit transaction

  begin transaction
  insert into t_rps_gl_interface(entity_id_1,
    journal_id_2,effective_date_3,journal_sequence_4,
    line_entity_id_6,rc_number_7,account_number_8,product_code_9,
    analysis_code_10,primary_dr_cr_code_11,transaction_amount_12,
    misc_cr_dr_code_13,misc_amount_14,jrnl_user_alpha_fld_15,
    date_created_16,description_17)
    select entity_id_1='101',journal_id_2='RDS_PAYROLL',
      effective_date_3=rd.today(),
      journal_sequence_4=1,line_entity_id_6='101',
      rc_number_7=case when contract.pbu_id is null then 
      (select p.pbu_code from pbu_code as p where
        p.pbu_id = (select nat.nat_PBU_code_NetPay_GL from "national" as nat where
          nat.nat_id = odps.od_blf_getwhichnational(@ProcDate))) else 
      (select p2.pbu_code from pbu_code as p2 where
        p2.pbu_id = contract.pbu_id) end,
      account_number_8=(case when payment_component_type.prs_key is null then
			case when contract.ac_id is null then account_codes.ac_code else 
				(select ac2.ac_code from account_codes as ac2 where ac2.ac_id = contract.ac_id) end 
		else ( case when payment_component_type.prs_key = 2 then
				(select ac10.ac_code from account_codes as ac10 where ac10.ac_id = (select p10.ac_id from payment_component_type as p10 where p10.pct_id = (select n10.nat_courierpost_defaultcomptype from "national" as n10 where n10.nat_id = odps.od_blf_getwhichnational(@procdate))))
			else case when payment_component_type.prs_key = 1 then (select ac11.ac_code from account_codes as ac11 where ac11.ac_id = (select p11.ac_id from payment_component_type as p11 where p11.pct_id = (select n11.nat_AdPost_DefaultComptype from "national" as n11 where n11.nat_id = odps.od_blf_getwhichnational(@procdate)))) 
				else case when payment_component_type.prs_key = 3 then (select ac12.ac_code from account_codes as ac12 where ac12.ac_id = (select p12.ac_id from payment_component_type as p12 where p12.pct_id = (select n12.nat_XP_DefaultComptype from "national" as n12 where n12.nat_id = odps.od_blf_getwhichnational(@procdate)))) 
					else case when payment_component_type.prs_key = 4 then (select ac13.ac_code from account_codes as ac13 where ac13.ac_id = (select p13.ac_id from payment_component_type as p13 where p13.pct_id = (select n13.nat_PP_DefaultComptype from "national" as n13 where n13.nat_id = odps.od_blf_getwhichnational(@procdate))))
					end
				end
			end
		end) end ),product_code_9=' ',analysis_code_10=' ',primary_dr_cr_code_11='D',
      transaction_amount_12=sum(pc_amount),misc_cr_dr_code_13='',
      misc_amount_14=0,
      jrnl_user_alpha_fld_15=case when contract.pbu_id is null then 
      (select p.pbu_code from pbu_code as p where
        p.pbu_id = (select nat.nat_PBU_code_NetPay_GL from "national" as nat where
          nat.nat_id = odps.od_blf_getwhichnational(@ProcDate))) else 
      (select p2.pbu_code from pbu_code as p2 where
        p2.pbu_id = contract.pbu_id) end,
      date_created_16=rd.today(),description_17='RD Payments Contract Price' from
      rd.contract,
      payment,
      payment_component,
      payment_component_group,
      payment_component_type,
      account_codes where
      contract.contract_no = payment.contract_no and
      payment_component.invoice_id = payment.invoice_id and
      payment_component_type.pcg_id = payment_component_group.pcg_id and
      payment_component_type.pct_id = payment_component.pct_id and
      account_codes.ac_id = payment_component_type.ac_id and
      payment_component_group.pcg_short_code in('GP','OGP') and
      payment.invoice_date = @procdate
      group by contract.pbu_id,
      contract.ac_id,
      payment_component_type.pct_description,payment_component_type.prs_key,account_codes.ac_code,payment_component_type.prs_key,
payment_component_type.prs_key,payment_component_type.prs_key,payment_component_type.prs_key
  if @@error < 0
    begin
      rollback transaction
      return(-100001000)
    end
  insert into t_rps_gl_interface(entity_id_1,
    journal_id_2,effective_date_3,journal_sequence_4,
    line_entity_id_6,rc_number_7,account_number_8,product_code_9,
    analysis_code_10,primary_dr_cr_code_11,transaction_amount_12,
    misc_cr_dr_code_13,misc_amount_14,jrnl_user_alpha_fld_15,
    date_created_16,description_17)
    select entity_id_1='101',journal_id_2='RDS_PAYROLL',
      effective_date_3=rd.today(),
      journal_sequence_4=1,line_entity_id_6='101',
      rc_number_74=isnull((select pbu_code.pbu_code from "national",pbu_code where
        nat_PBU_code_NetPay_GL = pbu_id and
        "national".nat_id = (select odps.od_blf_getwhichnational(@procdate) )),'181876'),
      account_number_8=isnull((select account_codes.ac_code from account_codes,"national" where
        nat_ac_id_NetPay_GL = account_codes.ac_id and
        "national".nat_id = (select odps.od_blf_getwhichnational(@procdate) )),'4200'),product_code_9=' ',analysis_code_10=' ',primary_dr_cr_code_11='C',
      transaction_amount_121=(select sum(pc_amount)*-1 from
        rd.contract as c,
        payment as p,
        payment_component as pc,
        payment_component_group as pcg,
        payment_component_type as pct where
        c.contract_no = p.contract_no and
        pc.invoice_id = p.invoice_id and
        pct.pcg_id = pcg.pcg_id and
        pct.pct_id = pc.pct_id and
        p.invoice_date = @procdate and
        pcg.pcg_short_code in('GP','OGP')),misc_cr_dr_code_13='',
      misc_amount_14=0,
      jrnl_user_alpha_fld_15=isnull((select pbu_code.pbu_code from "national",pbu_code where
        nat_PBU_code_NetPay_GL = pbu_id and
        "national".nat_id = (select odps.od_blf_getwhichnational(@procdate) )),'49999'), --give jrnl_user_alpha_fld_15 the same value as rc_number_74's origine 
      date_created_16=rd.today(),description_17='RD Payments Creditors Net Pay' 
  if @@error < 0
    begin
      rollback transaction
      return(-100001000)
    end
  commit transaction
  select entity_id_1,
    journal_id_2,
    effective_date_3,
    journal_sequence_4,
    row_number() over(order by entity_id_1),
    line_entity_id_6,
    rc_number_7,
    account_number_8,
    product_code_9,
    analysis_code_10,
    primary_dr_cr_code_11,
    transaction_amount_12,
    misc_cr_dr_code_13,
    misc_amount_14,
    jrnl_user_alpha_fld_15,
    date_created_16,
    description_17 from
    t_rps_gl_interface
end







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [odps].[OD_RPS_GrossPayVariance](@sdate datetime,@edate datetime,@prevsdate datetime,@prevedate datetime)
as
select payment.contract_no,
  contractor.c_surname_company,
  contractor.c_first_names,
  contractor.c_initials,
  LastMonth=(odps.OD_RPF_PCGetSumYear(
  payment.contractor_supplier_no,
  payment.contract_no,
  payment.contract_seq_number,
  @prevsdate,
  @prevedate,'GP',null)),
  /* Commented out so that the gross pay is what is calculated and 
  *      not net pay, 16/09/1999
  * +OD_RPF_PCGetSumYear(payment.contractor_supplier_no, 
  *           payment.contract_no, payment.contract_seq_number, 
  *           @prevsdate, @prevedate, 'OGP')
  * +abs(OD_RPF_PCGetSumYear(payment.contractor_supplier_no, 
  *           payment.contract_no, payment.contract_seq_number, 
  *           @prevsdate, @prevedate, 'GST'))
  * -abs(OD_RPF_PCGetSumYear(payment.contractor_supplier_no, 
  *          payment.contract_no, payment.contract_seq_number, 
  *           @prevsdate, @prevedate, 'TAX'))
  * +OD_RPF_PCGetSumYear(payment.contractor_supplier_no, 
  *           payment.contract_no, payment.contract_seq_number, 
  *           @prevsdate, @prevedate, 'PTA')),
  */
  ThisMonth=(odps.OD_RPF_PCGetSum(payment.invoice_id,'GP')),
  /* Commented out so that the gross pay is what is calculated and 
  *      not net pay, 16/09/1999
  * +OD_RPF_PCGetSum(payment.invoice_id, 'OGP')
  * +(OD_RPF_PCGetSum(payment.invoice_id, 'GST')*-1)
  * -abs(OD_RPF_PCGetSum(payment.invoice_id, 'TAX'))
  * +OD_RPF_PCGetSum(payment.invoice_id, 'PTA')),
  */
  wrate=(select nat_net_pct_change_warn from "national" where
    nat_id = odps.od_blf_getwhichnational(@edate)) from
  rd.contractor,payment where
  contractor.contractor_supplier_no = payment.contractor_supplier_no and
  payment.invoice_date between @sdate and @edate and
  (((case when (odps.OD_RPF_PCGetSumYear(
  payment.contractor_supplier_no,
  payment.contract_no,
  payment.contract_seq_number,
  @prevsdate,
  @prevedate,'GP',null)) <> 0 then(abs(odps.OD_RPF_PCGetSum(payment.invoice_id,'GP')/*thismounth*/ - odps.OD_RPF_PCGetSumYear(
  payment.contractor_supplier_no,payment.contract_no, payment.contract_seq_number, @prevsdate, @prevedate,'GP',null) /*Lastmonth*/ )/(odps.OD_RPF_PCGetSumYear(
  payment.contractor_supplier_no,
  payment.contract_no,
  payment.contract_seq_number,
  @prevsdate,
  @prevedate,'GP',null)))*100
  else 999999
  end) >= (select nat_net_pct_change_warn from
    "national" where
    nat_id = odps.od_blf_getwhichnational(@edate))))









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure OD_RPS_AP_Interface_Footer_consolidated : 
--

CREATE procedure  [odps].[OD_RPS_AP_Interface_Footer_consolidated](@ProcDate datetime)
as
begin
  select transaction_id_1='PRLN',
    vendor_2=isnull((select max(cd_old_ds_no) from rd.contractor left outer join rd.contractor_ds on contractor.contractor_supplier_no = contractor_ds.contractor_supplier_no where contractor.contractor_supplier_no = contractor_ds.contractor_supplier_no and contractor.contractor_supplier_no = p.contractor_supplier_no),'RD0' + 
    convert(varchar,p.contractor_supplier_no)),vendor_location_3=' ',
    Invoice_no_4=odps.OD_MiscF_Get_Invoicenumber(p.invoice_no,@procdate),
    invoice_date_5=convert(varchar,p.invoice_date,112),
    payment_number_6=0,column_7=convert(varchar,odps.OD_MiscF_Get_PCT_SequenceConsolidated(p.invoice_id,a.ac_id)),column_8=' ',
    column_9=convert(varchar,odps.OD_RPS_AP_Interface_Footer_Amt(p.invoice_id,a.ac_id)),column_10=' ',column_11=' ',column_12=' ',column_13=' ',column_14=' ',column_15=' ',column_16=' ',column_17=' ',column_18=' ',column_19=' ',column_20=' ',column_21=' ',column_22=' ',column_23=' ',column_24=' ',column_25=' ',column_26=' ',column_27=' ',column_28=' ',column_29=' ',column_30=' ',column_31=' ',column_32=' ',column_33=' ',column_34=' ',column_35=' ',column_36='101',column_37='181876',
    column_38=a.ac_code,column_39=' ',column_40=' ',column_41=' ',column_42=' ',column_43=' ',column_44=' ',column_45=' ',column_46=' ',column_47=' ',column_48=' ',column_49=' ',column_50=' ',column_51=' ',column_52=' ',column_53=' ',column_54=' ',column_55=' ',column_56=' ',column_57=' ',column_58='  ' from
    payment as p,rd.contract as c,account_codes as a where
    (p.contract_no = c.contract_no) and(p.invoice_date = @procdate) and
	exists(select payment_component_type.pct_id from payment_component inner join payment_component_type on (payment_component_type.pct_id = payment_component.pct_id) where
      ((payment_component_type.ac_id = a.ac_id) and
      (payment_component.invoice_id = p.invoice_id))) and
    odps.OD_BLF_Get_NetPay(p.invoice_id,null,null) <> 0 order by
    p.invoice_id asc
end



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for stored procedure OD_RPS_AP_Interface_Footer : 
--

CREATE procedure [odps].[OD_RPS_AP_Interface_Footer](@ProcDate datetime)
as
begin
  select transaction_id_1='PRLN',
    vendor_2=isnull((select max(cd_old_ds_no) from rd.contractor left outer join rd.contractor_ds on contractor.contractor_supplier_no = contractor_ds.contractor_supplier_no where contractor.contractor_supplier_no = contractor_ds.contractor_supplier_no and contractor.contractor_supplier_no = p.contractor_supplier_no),convert(varchar,p.contractor_supplier_no)),vendor_location_3=' ',
    Invoice_no_4 = odps.OD_MiscF_Get_Invoicenumber(p.invoice_no,@ProcDate),
    invoice_date_5=convert(varchar,p.invoice_date,112),
    payment_number_6=0,
    column_7=convert(varchar,odps.OD_MiscF_Get_PCT_Sequence(p.invoice_id,pc.pc_id)),column_8=' ',
    column_9=convert(varchar,case when pcg.pcg_short_code = 'GST' then abs(pc.pc_amount) else pc.pc_amount end),column_10=' ',column_11=' ',column_12=' ',column_13=' ',column_14=' ',column_15=' ',column_16=' ',column_17=' ',column_18=' ',column_19=' ',column_20=' ',column_21=' ',column_22=' ',column_23=' ',column_24=' ',column_25=' ',column_26=' ',column_27=' ',column_28=' ',column_29=' ',column_30=' ',column_31=' ',column_32=' ',column_33=' ',column_34=' ',column_35=' ',column_36='101',column_37='181876',
    column_38=a.ac_code,column_39=' ',column_40=' ',column_41=' ',column_42=' ',column_43=' ',column_44=' ',column_45=' ',column_46=' ',column_47=' ',column_48=' ',column_49=' ',column_50=' ',column_51=' ',column_52=' ',column_53=' ',column_54=' ',column_55=' ',column_56=' ',column_57=' ',column_58='  ' from
    payment as p,
    payment_component as pc,
    payment_component_type as pct,
    rd.contract as c left outer join pbu_code as pbu on(pbu.pbu_id = c.pbu_id),
    account_codes as a,
    payment_component_group as pcg where
    (pc.invoice_id = p.invoice_id) and
    (pct.pct_id = pc.pct_id) and
    (a.ac_id = pct.ac_id) and
    (p.contract_no = c.contract_no) and
    (p.invoice_date = @procdate) and
    (pct.pcg_id = pcg.pcg_id) order by
    p.invoice_id asc,pc.pc_id asc
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_AP_Interface_Header : 
--

CREATE procedure [odps].[OD_RPS_AP_Interface_Header](@ProcDate datetime)
as
begin
  select transaction_id_1='PRQT',
    vendor_2=left(isnull((select max(cd_old_ds_no) from rd.contractor left outer join rd.contractor_ds on contractor.contractor_supplier_no = contractor_ds.contractor_supplier_no where contractor.contractor_supplier_no = contractor_ds.contractor_supplier_no and contractor.contractor_supplier_no = payment.contractor_supplier_no),'RD0' + convert(varchar,payment.contractor_supplier_no)),11),vendor_location_3=' ',
    Invoice_no_4=odps.OD_MiscF_Get_Invoicenumber(payment.invoice_no,@ProcDate),
    invoice_date_5=convert(varchar,invoice_date, 112),
    payment_number_6=0,column_7='BAT',column_8=' ',column_9=' ',column_10=' ',column_11=' ',
    column_12=convert(varchar,invoice_date,112),column_13=' ',column_14=' ',column_15=' ',column_16=' ',column_17=' ',
    column_18=left(convert(varchar,odps.OD_BLF_Get_NetPay(payment.invoice_id,null,null)),21),
    column_19=convert(varchar,odps.OD_MiscF_GetLastDayofMonth(@Procdate),112),column_20=' ',column_21=' ',column_22=' ',column_23=' ',column_24=' ',column_25='MAILC',column_26=convert(varchar,invoice_date,112),column_27=' ',column_28=' ',column_29=' ',column_30=' ',column_31=' ',column_32=' ',column_33=' ',column_34=' ',column_35=' ',column_36=' ',column_37=' ',column_38=' ',column_39=' ',column_40=' ',column_41=' ',column_42=' ',column_43=' ',column_44=' ',column_45=' ',column_46=' ',column_47=' ',column_48=' ',column_49=' ',column_50=' ',column_51=' ',column_52=' ',column_53=' ',column_54=' ',column_55=' ',column_56=' ',column_57=' ',column_58=' ' from
    payment where
    exists(select invoice_id from payment_component where payment.invoice_id = payment_component.invoice_id) and
    invoice_date = @procdate and convert(decimal,left(convert(varchar,odps.OD_BLF_Get_NetPay(payment.invoice_id,null,null)),21)) <> 0 order by
    invoice_id asc
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




CREATE procedure [rd].[rds_npad_create_road](@in_unique_road_id int,@in_road_name char(50),@in_rt_id int,@in_rs_id int,@in_tc_id int,@in_sl_id int,@in_username char(20))
/******************************************************************
* Description
*    This routine creates a new road.
*
* System
*    NPAD2 - NZ Post
*
* Author
*    Tom Britton, Synergy International
*
* Created on
*    November 2005
*
* Modification history
* 13 Feb 2006  TJB  Moved 'rollback' to end if inserts
* 17 Mar 2006  TJB  Changed to allow multiple calls with different mailtowns
* 10 Apr 2006  TJB  Add 3rd f_getNextSequence parameter
*****************************************************************/
as
begin
  declare @status int,
  @description char(100),
  @msg char(80),
  @new_road_id int,
  @now datetime,
  @new_road int -- Flag: 0 = new road; 1 = new road/mailtown
  -- Need the date and time for the logged actions
  select @now=getdate()
  -- Initialize some variables
  select @status=0
  select @new_road=0
  /************************************************************
  * Check input parameters
  ***********************************************************/
  -- Check to see that the unique_road_id is valid ...
  if @in_unique_road_id is null or @in_unique_road_id <= 0
    begin
      select @status=108
      select @description='Unique_road_id invalid'
    end
  else
  -- Check the validity of the road name (it must not be NULL)
  if @in_road_name is null or LEN(@in_road_name) <= 0
    begin
      select @status=107
      select @description='Street name invalid'
    end
  else
  -- Check the validity of the road type (it may be NULL)
  if @in_rt_id is not null and @in_rt_id <= 0
    begin
      select @status=103
      select @description='Street typeID does not exist or invalid'
    end
  else
  if @in_rt_id is not null and
  not exists(select 1 from road_type where
    rt_id = @in_rt_id)
    begin
      select @status=103
      select @description='Street typeID does not exist or invalid'
    end
  else
  -- Check the validity of the road suffix (it may be NULL)
  if @in_rs_id is not null and @in_rs_id <= 0
    begin
      select @status=104
      select @description='Street suffixID does not exist or invalid'
    end
  else
  if @in_rs_id is not null and
  not exists(select 1 from road_suffix where
    rs_id = @in_rs_id)
    begin
      select @status=104
      select @description='Street suffixID does not exist or invalid'
    end
  else
  -- Check the validity of the suburb/locality (it may be NULL)
  if @in_sl_id is not null and @in_sl_id <= 0
    begin
      select @status=105
      select @description='LocalityID does not exist or invalid'
    end
  else
  if @in_sl_id is not null and
  not exists(select 1 from SuburbLocality where
    sl_id = @in_sl_id)
    begin
      select @status=105
      select @description='LocalityID does not exist or invalid'
    end
  else
  -- Check the validity of the mailtown (it may not be NULL)
  if @in_tc_id is null or @in_tc_id <= 0
    begin
      select @status=106
      select @description='MailtownID does not exist or invalid'
    end
  else
  if @in_tc_id is not null and
  not exists(select 1 from TownCity where
    tc_id = @in_tc_id)
    begin
      select @status=106
      select @description='MailtownID does not exist or is invalid'
    end
  else
  -- Check to see if the suburb exists in the mailtown (if one is specified)
  if @in_sl_id is not null and
  not exists(select 1 from town_suburb where
    tc_id = @in_tc_id and
    sl_id = @in_sl_id)
    begin
      select @status=109
      select @description='Locality does not exist in Mailtown'
    end
  else
  -- Check to see if the road already exists
  -- It exists if the road name, type and suffix exists as a road
  -- and that road is in the suburb (if one is specified)
  -- and is already in the mailtown (which must be specified)
  if exists(select 1 from
    road left outer join road_type on road.rt_id = road_type.rt_id left outer join road_suffix on road.rs_id = road_suffix.rs_id,
    road_suburb left outer join suburbLocality on road_suburb.sl_id = suburbLocality.sl_id,
    town_road left outer join townCity on town_road.tc_id = townCity.tc_id 
 where
    road.road_name = @in_road_name and
    road_suburb.road_id = road.road_id and
    town_road.road_id = road.road_id and
    ((@in_rt_id is null and road.rt_id is null) or
    (@in_rt_id is not null and road.rt_id = @in_rt_id)) and
    ((@in_rs_id is null and road.rs_id is null) or
    (@in_rs_id is not null and road.rs_id = @in_rs_id)) and
    (@in_sl_id is null or road_suburb.sl_id = @in_sl_id) and
    town_road.tc_id = @in_tc_id)
    begin
      select @status=102
      select @description='Street exists'
    end
  -- Check to see if the road already exists in the mailtown
  if @status = 0
    if exists(select 1 from road where
        unique_road_id = @in_unique_road_id)
      begin
        select @new_road=1 -- Actually flags that the road isn''t new
        if exists(select 1 from town_road,road where
            tc_id = @in_tc_id and
            road.road_id = town_road.road_id and
            road.unique_road_id = @in_unique_road_id)
          begin
            select @status=101
            select @description='Unique_road_id exists'
          end
      end
  /************************************************************
  * If the road is new, create the new road
  ***********************************************************/
  -- Get a road_id for the new road entry
  select @new_road_id=0
  if @status = 0 and @new_road = 0
    begin
      execute @new_road_id=rd.f_getNextSequence 'road',1,0 
      if @new_road_id <= 0
        begin
          select @status=-1
          select @description='SQL Error: invalid road ID'
        end
      -- Insert the new road entry
      if @status = 0
        begin
          insert into road(road_id,
            rt_id,rs_id,road_name,unique_road_id,
            last_amended_date,last_amended_user) values(
            @new_road_id,@in_rt_id,@in_rs_id,@in_road_name,@in_unique_road_id,
            @now,@in_username)
          if @@error <> 0
            begin
              select @status=-1
              select @description='SQL Error '+cast(@@error as char(6))+' creating road table entry'
            end
        end
      select @msg='Added road as road_id = '+cast(@new_road_id as char(8))
      -- If a suburb was specified, add an entry in the road_suburb table
      if @status = 0 and @in_sl_id is not null
        begin
          insert into road_suburb(sl_id,road_id) values(
            @in_sl_id,@new_road_id)
          if @@error <> 0
            begin
              select @status=-1
              select @description='SQL Error '+cast(@@error as char(6))+' adding road_suburb table entry'
            end
        end
      -- Set the new_road flag to say the road now exists
      -- so that a town_road entry can be created.
      select @new_road=1
    end
  -- Add an entry in the town_road table
  if @status = 0 and @new_road = 1
    begin
      if @new_road_id = 0
        begin
          select @new_road_id = road_id from
            road where
            unique_road_id = @in_unique_road_id
          if @@error <> 0
            begin
              select @status=-1
              select @description='SQL Error '+cast(@@error as char(6))+' getting road ID for town_road insert'
            end
        end
      if @status = 0
        begin
          insert into town_road(tc_id,road_id) values(
            @in_tc_id,@new_road_id)
          if @@error <> 0
            begin
              select @status=-1
              select @description='SQL Error '+cast(@@error as char(6))+' adding town_road table entry'
            end
        end
    end
  /************************************************************
  * Done.  Return status
  ***********************************************************/
  if @status = 0
    begin
      commit transaction -- Commit the changes
      select @description='Success'+' - '+@msg
    end
  else
    rollback transaction
  -- log message
  select @msg=ltrim(rtrim(convert(char(8),@in_unique_road_id)))+','+
    ltrim(rtrim(@in_road_name))+','+
    ltrim(rtrim(convert(char(8),@in_rt_id)))+','+
    ltrim(rtrim(convert(char(8),@in_rs_id)))+','+
    ltrim(rtrim(convert(char(8),@in_tc_id)))+','+
    ltrim(rtrim(convert(char(8),@in_sl_id)))
  insert into NPAD_msg_log(msg_date,
    msg_username,msg_type,msg_dpid,msg_status,msg_description) values(
    @now,@in_username,'create road',null,@status,@msg)
  -- Return status
  select Status=@status,
    Description=@description 
end






GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [rd].[f_create_road](@in_roadname char(50),@in_rtid int,@in_rsid int,@in_slname char(50),@in_tcid int,@in_user char(20))
-- TJB  NPAD2  May 2006   - New -
-- Create a new road if necessary, and/or links between the road and 
-- town and suburb.
-- Returns the road_id of the existing or created road.
--
-- Returns
--   >0     Road_id 
--    0     Not OK    (failed to create the road or its linkages)
as --   -4     OK        (suburb doesn''t exist in the mailtown)
begin
  declare @tempid int
  declare @roadid int
  declare @slid int
  declare @now datetime
  -- First, determine the suburb ID, if a suburb name is specified.
  -- There are possibly multiple suburbs with the same name, but only
  -- one suburb with a given name in a mailtown.  Its an error if 
  -- the specified suburb doesn''t exist in the specified mailtown.
  if @@TRANCOUNT = 0
  begin
	begin tran
  end
  if @in_slname is null or @in_slname = ''
    select @slid=0
  else
    select top 1 @slid = sl.sl_id from
      town_suburb as ts join suburblocality as sl
      on ts.tc_id = sl.sl_id
      where
      ts.tc_id = @in_tcid and
      sl.sl_name = @in_slname order by
      sl.sl_id asc
  if @slid is null
    return-4 -- Suburb doesn''t exist in the town
  -- Let's see if there's already a road with the right name, and 
  -- no unique_road_id (a non-NPAD road). We''ll look for a road 
  -- associated with the mailtown, following the NPAD scheme of
  -- having separate roads for each mailtown even though the old
  -- RDS scheme didn''t.
  select @roadid = road.road_id from
    road join town_road 
    on road.road_id = town_road.road_id
    where
    road_name = rd.trim(@in_roadname) and
    tc_id = @in_tcid and
    isnull(@in_rtid,0) = isnull(rt_id,0) and
    isnull(@in_rsid,0) = isnull(rs_id,0) and
    unique_road_id is null
  if @roadid is null or @roadid <= 0
    begin
      -- If a non-NPAD road wasn''t found, look for an NPAD one.
      select top 1 @roadid = road.road_id from
      road join town_road 
      on road.road_id = town_road.road_id
      where
        road_name = rd.trim(@in_roadname) and
        tc_id = @in_tcid and
        isnull(@in_rtid,0) = isnull(rt_id,0) and
        isnull(@in_rsid,0) = isnull(rs_id,0)
      if @slid > 0
        -- If a suburb was specified, see if there is a road in the 
        -- suburb and town (there could be different roads in different 
        -- suburbs in the town and the road/town lookup above might 
        -- have found the wrong one).
        select top 1 @tempid = road.road_id from
          road join town_road
          on road.road_id = town_road.road_id
			 join road_suburb 
          on road.road_id = road_suburb.road_id
          where
          road.road_name = rd.trim(@in_roadname) and
          tc_id = @in_tcid and
          SL_id = @slid and
          isnull(@in_rtid,0) = isnull(road.rt_id,0) and
          isnull(@in_rsid,0) = isnull(road.rs_id,0)
      if @tempid is not null and @tempid > 0
        select @roadid=@tempid
    end
  -- At this point, if @roadid is null, there isn''t an existing road record 
  -- we can use and we''ll have to create a new one.
  if @roadid is null or @roadid <= 0
    begin
      select @now=getdate()
      execute @roadid=rd.f_getNextSequence 'Road',1,0
      insert into road(road_id,
        road_name,rt_id,rs_id,unique_road_id,
        last_amended_date,last_amended_user) values(
        @roadid,rd.trim(@in_roadname),@in_rtid,@in_rsid,null,
        @now,@in_user)
    end
  -- Now set up the linkages between the road and town and suburb 
  -- if necessary.
  --
  -- If there isn''t a road/town relation, add one.
  if not exists(select 1 from town_road where
      tc_id = @in_tcid and
      road_id = @roadid)
    insert into town_road(tc_id,road_id) values(
      @in_tcid,@roadid)
  -- If there isn''t a road/suburb relation, add one.
  if @slid > 0 and
    not exists(select 1 from road_suburb where
      sl_id = @slid and
      road_id = @roadid)
    insert into road_suburb(sl_id,road_id) values(
      @slid,@roadid)
  commit transaction
  return @roadid
end








GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO




CREATE  procedure [rd].[rds_npad_create_address](@in_dpid int,@in_adr_no int,@in_adr_alpha char(20),@in_unique_road_id int,@in_sl_id int,@in_tc_id int,@in_rd_no char(40),@in_post_code char(4),@in_adr_property char(100),@in_adr_unit char(10),@in_cust_surname char(45),@in_cust_initials char(30),@in_cust_title char(10),@in_master_cust_dpid int,@in_username char(20),@in_xcoordinate numeric(10,2),@in_ycoordinate numeric(10,2))
/******************************************************************
* Description
*    This routine creates an address record in the RDS system.
*    For unnumbered addresses, it also creates a new customer 
*    in the rds_customer table and an associated record in the
*    Customer_address_moves table.
*
*    Addresses can only be created where the road, mailtown and 
*    suburb (if specified) already exist.
*
* System
*    NPAD2 - NZ Post
*
* Author
*    Tom Britton, Synergy International
*
* Created on
*    November 2005
*
* Modification history
* 13 Feb 2006  TJB  Added X and Y coordinate parameters as per CR13
* 24 Feb 2006  TJB  Made description of error 101 consistent
* 20 Mar 2006	TJB  Changed default new customer attributes to
*                   'rural resident' and Privacy = No.
* 24 Mar 2006  TJB  Add lookup of contract_no using post_code,
*                   RD_no, and unique_road_id.
*  5 Apr 2006  TJB  Ensure RD numbers for Oamaru are 3 chars
*                   with the last char an alpha.
* 10 Apr 2006  TJB  Add 3rd f_getNextSequence parameter
* 11 May 2006  TJB  SR4687: If a road/suburb association doesn't 
*                   exist, create it (don't flag it as an error).
* 17 May 2007  TJB  Fix bug:  set default adpost quantity = 1 for new
*                   master customers.
*****************************************************************/
as
begin
  declare @status int, -- Return status (0 = success)
  @description char(60), -- Return description (mainly error
  -- message)
  @numbered tinyint, -- Flag indicating the address is
  -- numbered (1) or not (0).
  @found tinyint, -- Flag indicating a database record 
  -- exists (1) or not (NULL)
  @msg char(80), -- Test message
  @adrID int, -- New address ID
  @custID int, -- New customer ID
  @postCodeID int, -- Post code ID
  @masterCustID int, -- Master customer''s ID
  @masterAdrID int, -- Master customer''s adr_id
  @contract_no int, -- Contract number
  @temp_int int, -- Temporary number
  @temp_char char(20), -- Temporary string
  -- Most of these are used to ensure either a proper value or NULL
  -- is used to create the address or customer record (the passed
  -- value may be '' or 0 instead of NULL).
  -- In other cases, the passed value can be used when it is required
  -- and has passed validation (eg adr_no, tc_id, rd_no, post_code)
  @adrNo char(20), -- in_adr_no as a string to match database column type (normalised)
  @adrUnit char(10), -- Normalized address adr_unit
  @adrAlpha char(20), -- Normalized address adr_alpha
  @adrProperty char(20), -- Normalized address adr_property_identification
  @slID int, -- Normalized address sl_id
  @roadID int, -- RDS road_id (determined via unique_road_id)
  @custInitials char(30), -- Normalized rds_customer cust_initials
  @custTitle char(10), -- Normalized rds_customer cust_title
  @masterDpid int, -- Normalized dpid of master customer
  @RDno char(40), -- Normalised RD number
  @now datetime
  -- Need the date and time for the logged actions
  select @now=getdate()
  select @status=0
  /************************************************************
  * Check input parameters
  ***********************************************************/
  -- Check to see that the dpid is valid ...
  if @in_dpid is null or @in_dpid <= 0
    begin
      select @status=115
      select @description='Invalid Dpid'
    end
  else
  -- ... and doesn''t already exist 
  if exists(select 1 from address where
    dp_id = @in_dpid)
    begin
      select @status=101
      select @description='Address already exists (same dpid)'
    end
  else
  -- Check to see that the road ID is valid ...
  if @in_unique_road_id is null or @in_unique_road_id <= 0
    begin
      select @status=103
      select @description='Unique_road_id does not exist or invalid'
    end
  -- ... and does exist
  -- We get the road_id for the road to use below
  if @status = 0
    begin
      select @roadID=NULL
      select @roadID = road_id from
        road where
        unique_road_id = @in_unique_road_id
      if @roadID is null
        begin
          select @status=103
          select @description='Unique_road_id does not exist or invalid'
        end
    end
  -- Check to see if this address is numbered or not.
  -- A numbered address MUST have a street number and MAY have 
  --     a unit number and/or alpha suffix.
  if @status = 0
    if @in_adr_no is not null and @in_adr_no > 0
      begin
        select @numbered=1
        select @adrNo=convert(char(20),@in_adr_no)
      end
    else
      begin
        select @numbered=0
        select @adrNo=null
      end
  -- Check to see if the unit number is valid (if specified)
  -- any value is allowed
  -- Set @adrUnit to the @in_adr_unit value or NULL
  -- eliminating the possibly passed value of ''.
  if @status = 0
    begin
      if @in_adr_unit is null or @in_adr_unit = ''
        select @adrUnit=null
      else
        select @adrUnit=@in_adr_unit
      -- Check to see if the number alpha is valid (if specified)
      --> any value is allowed
      -- Set @adrAlpha to the @in_adr_alpha value or NULL
      -- eliminating the possibly passed value of ''.
      if @in_adr_alpha is null or @in_adr_alpha = ''
        select @adrAlpha=null
      else
        select @adrAlpha=@in_adr_alpha
      -- Check to see if the property name is valid (if specified)
      --> any value is allowed
      -- Set @adrProperty to the @in_adr_property value or NULL
      -- eliminating the possibly passed value of ''.
      if @in_adr_property is null or @in_adr_property = ''
        select @adrProperty=null
      else
        select @adrProperty=@in_adr_property
      -- Normalise the suburbID
      if @in_sl_id is null
        select @slID=null
      else
        select @slID=@in_sl_id
      -- Check to see if the suburb exists (if specified)
      if @slID is not null
        if not exists(select 1 from suburbLocality where
            sl_id = @slID) or
          @slID <= 0
          begin
            select @status=104
            select @description='LocalityID does not exist or invalid'
          end
    end
  -- Check to see that a mailtown was specified
  if @status = 0
    if @in_tc_id is null
      begin
        select @status=114
        select @description='Mailtown not specified'
      end
  -- Check to see that the mailtown is valid
  if @status = 0
    if @in_tc_id is not null
      if not exists(select 1 from townCity where
          tc_id = @in_tc_id) or
        @in_tc_id <= 0
        begin
          select @status=105
          select @description='MailtownID does not exist or invalid'
        end
  -- Check to see if the suburb exists in the mailtown
  if @status = 0
    if @slID is not null
      if not exists(select 1 from town_suburb where
          tc_id = @in_tc_id and
          sl_id = @slID)
        begin
          select @status=119
          select @description='Locality does not exist in Mailtown'
        end
  --    -- Check to see if the road exists in the suburb (if specified)
  --    if @status = 0 then
  --        if @slID is not null then
  --            if not exists (select 1 from road_suburb
  --                            where sl_id = @slID
  --                              and road_id = @roadID)
  --            then
  --                set @status = 106;
  --                set @description = 'Street does not exist in Locality';
  --            end if;
  --        end if;
  --    end if;
  -- Check to see if the road exists in the mailtown
  if @status = 0
    if @in_tc_id is not null
      if not exists(select 1 from town_road where
          tc_id = @in_tc_id and
          road_id = @roadID)
        begin
          select @status=107
          select @description='Street does not exist in Mailtown'
        end
  -- Check to see that an RD number was specified
  --> NOTE: Alphanumeric values are acceptable
  if @status = 0
    if @in_rd_no is not null and LEN(@in_rd_no) > 0
      select @rdno=@in_rd_no
    else
      begin
        select @rdno=null
        select @status=108
        select @description='RD number missing or invalid'
      end
  -- Check that the RD number is valid for Oamaru
  -- (3 chars with the last char an alpha)
  if @status = 0 and @in_tc_id = (select tc_id from towncity where
      tc_name = 'Oamaru')
    begin
      select @RDno=ltrim(rtrim(@RDno))
      if LEN(@RDno) > 3
        begin
          select @status=108
          select @description='RD number missing or invalid'
        end
      else
      if len(@RDno) < 3
        select @RDno=space(3-len(@RDno))+@RDno
      if @status = 0 and(isnumeric(right(@RDno,1)) = 1 or right(@RDno,1) = ' ')
        begin
          select @status=120
          select @description='RD number invalid for Oamaru'
        end
    end
  -- Check to see that a post code was specified
  --> Note: isnumeric() returns 0 if the post_code is NULL
  if @status = 0
    if isnumeric(@in_post_code) = 0 or len(@in_post_code) <> 4
      begin
        select @status=109
        select @description='Post Code missing or invalid'
      end
  -- ... and that it exists (assume its the right one)
  if @status = 0
    begin
      select @postCodeID=rd.f_getPostCodeID(@in_post_code,@in_tc_id,@roadID)
      if @postCodeID = -1
        begin
          select @status=109
          select @description='Post Code missing or invalid'
        end
    end
  -- Check whether a customer has been named when it shouldn''t be
  -- An address can have either a street number or customer named, 
  -- but not both.
  if @status = 0
    if @numbered = 1
      if @in_cust_surname is not null and len(@in_cust_surname) > 0
        begin
          select @status=116
          select @description='Both street number and customer given for address'
        end
  -- Check whether a customer has not been named when it should be
  if @status = 0
    if @numbered = 0
      if @in_cust_surname is null or len(@in_cust_surname) = 0
        begin
          select @status=117
          select @description='No street number or customer given for address'
        end
  -- Normalise the master_cust_dpid.  We''ll use it soon.
  if @in_master_cust_dpid is null or @in_master_cust_dpid = 0
    select @masterDpid=null
  else
    select @masterDpid=@in_master_cust_dpid
  -- At this point the @in_cust_surname either has something in it when it should
  -- or doesn't have anything when it shouldn't (NULL and '' being equivalent).
  -- If this is an unnumbered address, we want to ensure the cust_initials and cust_title
  -- are either <something> or NULL (not '').  What that <something> is doesn''t matter.
  -- We also want to ensure the master_dpid is either NULL or > 0, and if > 0, is valid.
  -- They''re only used to create a customer record for an unnumbered address, so what they 
  -- are if they're not going to be used doesn't matter.
  if @status = 0 and @numbered = 0
    begin
      -- Normalise the cust_title
      if @in_cust_title is null or @in_cust_title = ''
        select @custTitle=null
      else
        select @custTitle=@in_cust_title
      -- Normalise the cust_initials
      if @in_cust_initials is null or @in_cust_initials = ''
        select @custInitials=null
      else
        select @custInitials=@in_cust_initials
      -- If a master_cust_dpid was given, check that it is valid
      -- The referenced customer must be a master
      -- and that customer''s address must match the new address
      if @masterDpid is not null
        begin
          select @found=null
          -- Check that there''s only one master dpid
          -- in the customer_address_moves table.
          select @found = count(*) from
            customer_address_moves where
            dp_id = @masterDpid and
            move_out_date is null
          if @found is null
            begin
              select @status=118
              select @description='Invalid master customer dpid'
            end
          else
          if @found > 1
            begin
              select @status=120
              select @description='Other: Master dpid appears too often in customer_address_moves'
            end
          -- Get the master dpid''s customer ID and address
          -- for further validations
          if @status = 0
            begin
              select @masterCustID = cust_id,@masterAdrID = adr_id from
                customer_address_moves where
                dp_id = @masterDpid and
                move_out_date is null
              -- Check that the master dpid refers to a master customer
              select @found = 1 from
                rds_customer where
                cust_id = @masterCustID and
                master_cust_id is null
              if @found is null or @found <> 1
                begin
                  select @status=120
                  select @description='Master dpid is not a master customer'
                end
            end
        end
    end
  -- Now check that the address isn''t being duplicated (when its a numbered address)
  -- and exists when it should (when creating a recipient)
  if @status = 0 and @numbered = 1
    begin
      -- New numbered address: there shouldn''t be a duplicate
      -- Look up the dp_id for the address
      select @temp_int=null
      select @temp_int = dp_id from
        address join post_code on address.post_code_id = post_code.post_code_id where
        adr_no = @adrNo and
        (isnull(adr_unit,'') = isnull(@adrUnit,'')) and
        (isnull(adr_alpha,'') = isnull(@adrAlpha,'')) and
        road_id = @roadID and
        tc_id = @in_tc_id and
        adr_rd_no = @RDno and
        post_code.post_code = @in_post_code
      -- If a duplicate address was found check whether has the same or a different dp_id
      if @temp_int is not null
        if @temp_int = @in_dpid
          begin
            select @status=101
            select @description='Address already exists (same dpid)'
          end
        else
          begin
            select @status=102
            select @description='Address already exists (different dpid)'
          end
    end
  if @status = 0 and @numbered = 0 and @masterDpid is not null
    begin
      -- new recipient: the address must exist 
      -- and must be the same as the master''s.
      -- Look up the dp_id of the master''s address
      -- and also that the addresses match
      select @temp_int = dp_id from
        address join post_code on address.post_code_id = post_code.post_code_id where
        adr_id = @masterAdrID and
        adr_no is null and
        road_id = @roadID and
        tc_id = @in_tc_id and
        adr_rd_no = @RDno and
        post_code.post_code = @in_post_code
      -- If the address didn't match, or has a different dp_id than the master's
      if @temp_int is null or @temp_int <> @masterDpid
        begin
          select @status=113
          select @description='Master customer dpid does not exist or invalid'
        end
    end
  -- NOTE:  the other possibility is that this might be an unnumbered address
  --        with no master customer dpid specified (but these are not allowed).  
  --        In that case, there may be duplicate (unnumbered) addresses, and 
  --        we''re about to create another with this customer as its master.
  /************************************************************
  * Create the new address
  ***********************************************************/
  -- Get the next available address ID for the new address
  -- Note: we only actually create a new address record for
  -- numbered addresses and unnumbered addresses where we 
  -- create a new master customer.
  if @status = 0
    begin
      execute @adrID=rd.f_getNextSequence 'address',1,0
      -- See if we can determine the contract number
      -- Look for other addresses in the same RD/post code
      select @temp_int = count(distinct contract_no) from
        address join post_code on
        address.post_code_id = post_code.post_code_id join road on
        address.road_id = road.road_id where
        post_code = @in_post_code and
        adr_rd_no = @RDno and
        contract_no is not null and
        unique_road_id = @in_unique_road_id
      if @@error <> 0
        begin
          select @status=-1
          select @description='SQL Error '+convert(char(6),@@error)+' counting contract#s in post_code'
        end
      if @temp_int = 1 and @status = 0
        begin
          select distinct @contract_no = contract_no from
            address join post_code on
            address.post_code_id = post_code.post_code_id join road on
            address.road_id = road.road_id where
            post_code = @in_post_code and
            adr_rd_no = @RDno and
            contract_no is not null and
            unique_road_id = @in_unique_road_id
          if @@error <> 0
            begin
              select @status=-1
              select @description='SQL Error '+convert(char(6),@@error)+' getting contract# for address'
            end
        end
      else
        select @contract_no=null
      if @numbered = 1 and @status = 0
        begin
          -------------------------------------
          --  Create a new numbered address  --
          -------------------------------------
          insert into address(adr_id,
            adr_no,adr_unit,adr_alpha,adr_property_identification,
            road_id,sl_id,tc_id,adr_rd_no,post_code_id,
            dp_id,contract_no,adr_date_loaded,adr_last_amended_user) values(
            @adrID,@adrNo,@adrUnit,@adrAlpha,@adrProperty,
            @roadID,@slID,@in_tc_id,@RDno,@postCodeID,
            @in_dpid,@contract_no,@now,@in_username)
          if @@error <> 0
            begin
              select @status=-1
              select @description='SQL Error '+convert(char(6),@@error)+' creating numbered address'
            end
          else
            -- Successful: prepare addition fo 'Successful' message
            select @msg='New Adr_id = '+convert(char(8),@adrID)
          -- Now add the geocode 
          if @status = 0
            begin
              insert into address_geocode(adr_id,
                geocode_x,geocode_y) values(
                @adrID,@in_xcoordinate,@in_ycoordinate)
              if @@error <> 0
                begin
                  select @status=-1
                  select @description='SQL Error '+convert(char(6),@@error)+' adding address_geocode record'
                end
            end
        end
      else
        begin
          -------------------------------------
          -- Create a new unnumbered address --
          -------------------------------------
          -- Get the next available customer ID for the new customer
          execute @custID=rd.f_getNextSequence 'customer',1,0
          ----------------------------------
          if @masterDpid is null
            begin
              -- Create a new master customer --
              ----------------------------------
              -- Create the address record
              insert into address(adr_id,
                adr_no,adr_unit,adr_alpha,adr_property_identification,
                road_id,sl_id,tc_id,adr_rd_no,post_code_id,dp_id,
                contract_no,adr_date_loaded,adr_last_amended_user) values(
                @adrID,null,null,null,@adrProperty,
                @roadID,@slID,@in_tc_id,@RDno,@postCodeID,@in_dpid,
                @contract_no,@now,@in_username)
              if @@error <> 0
                begin
                  select @status=-1
                  select @description='SQL Error '+convert(char(6),@@error)+' creating unnumbered address'
                end
              -- Now add the geocode 
              if @status = 0
                begin
                  insert into address_geocode(adr_id,
                    geocode_x,geocode_y) values(
                    @adrID,@in_xcoordinate,@in_ycoordinate)
                  if @@error <> 0
                    begin
                      select @status=-1
                      select @description='SQL Error '+convert(char(6),@@error)+' adding address_geocode record'
                    end
                end
              -- Create the master customer record
              if @status = 0
                begin
                  insert into rds_customer(cust_id,
                    cust_title,cust_initials,cust_surname_company,
                    master_cust_id,cust_dir_listing_ind,
                    cust_business,cust_rural_resident,cust_rural_farmer,
                    cust_date_commenced,cust_last_amended_date,cust_last_amended_user) values(
                    @custID,@custTitle,@custInitials,@in_cust_surname,
                    null,'Y','N','Y','N',
                    rd.today(),@now,@in_username)
                  if @@error <> 0
                    begin
                      select @status=-1
                      select @description='SQL Error '+convert(char(6),@@error)+' creating master customer'
                    end
                end
              -- Create the customer_address_moves record linking the
              -- customer to the address.
              if @status = 0
                begin
                  insert into customer_address_moves(adr_id,
                    cust_id,dp_id,move_in_date,move_out_date) values(
                    @adrID,@custID,@in_dpid,@now,null)
                  if @@error <> 0
                    begin
                      select @status=-1
                      select @description='SQL Error '+convert(char(6),@@error)+' creating customer_address_moves record for master'
                    end
                end
              select @msg='New Adr_id = '+convert(char(8),@adrID)+', new master = '+
                convert(char(8),@custID)
            end
          else
            begin
              ------------------------------
              --  Create a new recipient  --
              ------------------------------
              -- Create the recipient customer record
              insert into rds_customer(cust_id,
                cust_title,cust_initials,cust_surname_company,
                master_cust_id,cust_dir_listing_ind,
                cust_date_commenced,cust_last_amended_date,cust_last_amended_user) values(
                @custID,@custTitle,@custInitials,@in_cust_surname,
                @masterCustID,'Y',
                rd.today(),@now,@in_username)
              if @@error <> 0
                begin
                  select @status=-1
                  select @description='SQL Error '+convert(char(6),@@error)+' creating recipient'
                end
              -- Create the customer_address_moves record linking the
              -- recipient to the master''s address but with its own dp_id.
              if @status = 0
                begin
                  insert into customer_address_moves(adr_id,
                    cust_id,dp_id,move_in_date,move_out_date) values(
                    @masterAdrID,@custID,@in_dpid,@now,null)
                  if @@error <> 0
                    begin
                      select @status=-1
                      select @description='SQL Error '+convert(char(6),@@error)+' creating customer_address_moves record for recipient'
                    end
                end
              select @msg='New recipient = '+convert(char(8),@custID)+', at masters adr_id = '+
                convert(char(8),@masterAdrID)
            end
        end
    end
  -- If the road doesn''t already exist in the suburb, creeate it.
  if @status = 0
    if @slID is not null
      if not exists(select 1 from road_suburb where
          sl_id = @slID and
          road_id = @roadID)
        begin
          insert into road_suburb(sl_id,road_id) values(
            @slID,@roadID)
          if @@error <> 0
            begin
              select @status=-1
              select @description='SQL Error '+convert(char(6),@@error)+' creating road_suburb record'
            end
        end
  /************************************************************
  * Done.  Return status
  ***********************************************************/
  if @status = 0
    begin
      commit transaction -- Commit the changes    
      select @description='Success'+' - '+@msg
    end
  else
    rollback transaction
  -- Log the message
  select @msg=rd.trim(convert(char(20),@in_adr_no))+','+
    rd.trim(@in_adr_alpha)+','+
    rd.trim(convert(char(8),@in_unique_road_id))+','+
    rd.trim(convert(char(8),@in_sl_id))+','+
    rd.trim(convert(char(8),@in_tc_id))+','+
    rd.trim(@in_rd_no)+','+
    rd.trim(@in_post_code)+','+
    rd.trim(@in_adr_unit)+','+
    rd.trim(@in_cust_surname)+','+
    rd.trim(@in_cust_initials)+','+
    rd.trim(@in_cust_title)+','+
    rd.trim(convert(char(8),@in_master_cust_dpid))
  insert into NPAD_msg_log(msg_date,
    msg_username,msg_type,msg_dpid,msg_status,msg_description) values(
    @now,@in_username,'create address',@in_dpid,@status,@msg)
  -- Return status
  select Status=@status,Description=@description 
  return @status
end


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE procedure [odps].[OD_MiscF_Get_Invoicenumber_old] 
(@inPayPeriod_End datetime)
	-- Add the parameters for the stored procedure here
as
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
  declare @InvoiceNumber integer,
  @InvoiceSequenceStart integer
  select @InvoiceSequenceStart = "national".nat_seq_no_for_keys
    from "national" where
    "national".nat_effective_date = (select max(nat_effective_date) from
      "national" where "national".nat_effective_date <= @inPayPeriod_End)
--insert into temp_int values(1) --exec odps.od_blf_getnextsequence('invoice') 
--select @InvoiceNumber= intvalue from temp_int
 --select @InvoiceNumber = odps.od_blf_getnextsequence('invoice') 
exec @InvoiceNumber = odps.od_blf_getnextsequence '360'

 
  if @InvoiceNumber <= 0
    begin
      --rollback transaction // by fyb
      return(-1)
    end
  return(@InvoiceNumber)
    -- Insert statements for procedure here
END







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRenewalRatesWithRegion2001a : 
--

CREATE procedure [rd].[sp_GetRenewalRatesWithRegion2001a](@inregion int)
as
begin
  if @inregion > 0
    select distinct non_vehicle_rate.rg_code,
      non_vehicle_rate.nvr_rates_effective_date,
      non_vehicle_rate.nvr_frozen_indicator,
      rd.f_CheckRates(non_vehicle_rate.rg_code,non_vehicle_rate.nvr_rates_effective_date) from
      contract,
      outlet,
      non_vehicle_rate where
      outlet.outlet_id = contract.con_lodgement_office and
      contract.rg_code = non_vehicle_rate.rg_code and
      outlet.region_id = @inregion order by
      non_vehicle_rate.nvr_rates_effective_date asc
  else
    select distinct non_vehicle_rate.rg_code,
      non_vehicle_rate.nvr_rates_effective_date,
      non_vehicle_rate.nvr_frozen_indicator,
      rd.f_CheckRates(non_vehicle_rate.rg_code,non_vehicle_rate.nvr_rates_effective_date) from
      non_vehicle_rate order by
      2 asc
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function NZPRegionV2 : 
--

CREATE function [rd].[NZPRegionV2](@inRegion int,@inOutlet int,@inRenGroup int,@inContractType int)
returns decimal(10,2)
as
begin
  declare @dReturn decimal(10,2),
  @dTotal decimal(10,2)
  select @dTotal = rd.CoreContract(@inRegion,@inOutlet,@inRenGroup,@inContractType) 
    
  select @dReturn=isnull(@dTotal,0)
  select @dTotal = sum(isnull(frequency_adjustments.fd_amount_to_pay,0))
    from contract_renewals join
    contract as aa on
    contract_renewals.contract_no = aa.contract_no and
    contract_renewals.contract_seq_number = aa.con_active_sequence join
    frequency_adjustments on
    contract_renewals.contract_no = frequency_adjustments.contract_no and
    contract_renewals.contract_seq_number = frequency_adjustments.contract_seq_number and
    frequency_adjustments.fd_confirmed = 'Y',
    contract join
    outlet on
    contract.con_base_office = outlet.outlet_id and
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) where
    contract.con_date_terminated is null and
    ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
    (@inContractType = 0 or @inContractType is null)) and
    (contract_renewals.contract_no = contract.contract_no) and
    (contract_renewals.contract_seq_number = contract.con_active_sequence) and
    (contract.rg_code = @inRenGroup or @inRenGroup = 0)
  select @dReturn=@dReturn+isnull(@dTotal,0)
  select @dTotal = rd.NZPAllowance(@inRegion,@inOutlet,@inRenGroup,@inContractType) 
    
  select @dReturn=@dReturn+isnull(@dTotal,0)
  if @dReturn = 0
    select @dReturn=null
  return @dReturn
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure EstAdPostAll : 
--

CREATE procedure [rd].[EstAdPostAll](@inAll int,@inRegion int,@inRenGroup int,@inContractType int)
as
begin
  -- 14/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
  -- sql code.  Used the corresponding piece_rate_suplier.prs_key instead.
  declare @decAmount real,
  @tsum1 numeric(12,2),
  @tsum2 numeric(12,2),
  @StartDate datetime,
  @EndDate datetime
  select @StartDate=rd.getFirstDayofMonth(datediff(day,rd.getLastDayofMonth(getdate()),-125))
  select @EndDate=rd.getLastDayofMonth(datediff(day,rd.getLastDayofMonth(getdate()),-32))
  if @inAll <> 1
    insert into RCMStatPR1(region_id,AdpostCost,AdpostVol)
      select 0,
        (sum(case when isnull(piece_rate_delivery.prd_quantity,0)=0 then 0 else piece_rate_delivery.prd_quantity*isnull(piece_rate.pr_rate,0)end))*3,
        (sum(isnull(piece_rate_delivery.prd_quantity,0)))*3 from
        piece_rate,
        piece_rate_delivery,
        piece_rate_supplier,
        piece_rate_type,
        contract,
        outlet,
        renewal_group,
        contract_renewals where
        (piece_rate.prt_key = piece_rate_delivery.prt_key) and
        (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
        (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
        (piece_rate_type.prt_key = piece_rate.prt_key) and
        (contract.contract_no = piece_rate_delivery.contract_no) and
        (outlet.outlet_id = contract.con_base_office) and
        (renewal_group.rg_code = contract.rg_code) and
        (renewal_group.rg_code = piece_rate.rg_code) and
        (piece_rate.pr_effective_date = (select MAX(PR.pr_effective_date) from piece_rate as PR where pr.prt_key = piece_rate.prt_key and pr.rg_code = piece_rate.rg_code)) and
        (piece_rate_delivery.prd_date between @StartDate and @EndDate) and
        (piece_rate_supplier.prs_key = 1) and
        (contract_renewals.contract_no = contract.contract_no) and
        (contract_renewals.contract_seq_number = contract.con_active_sequence) and
        ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
        (@inContractType = 0 or @inContractType is null))
  else
    begin
      select @tsum1=sum(AdpostCost) from RCMStatPR1
      select @tsum2=sum(AdpostVol) from RCMStatPR1
      insert into RCMStatPR1(region_id,AdpostCost,AdpostVol) values(
        0,@tsum1,@tsum2)
    end
  return(@inregion)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure EstCourPost : 
--

CREATE procedure [rd].[EstCourPost](@region int,@outlet int,@inRenGroup int,@inContractType int) as
begin
  -- 14/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
  -- sql code.  Used the corresponding piece_rate_suplier.prs_key instead.
  declare @decAmount real,
  @StartDate datetime,
  @EndDate datetime
  select @StartDate=rd.getFirstDayofMonth(datediff(day,rd.getLastDayofMonth(getdate()),-125))
 
  select @EndDate=rd.getLastDayofMonth(datediff(day,rd.getLastDayofMonth(getdate()),-32))
 
  insert into RCMStatPR2(region_id,CourpostCost,CourpostVol)
    select outlet.region_id,
      (sum(case when isnull(piece_rate_delivery.prd_quantity,0)=0 then 0 else piece_rate_delivery.prd_quantity*isnull(piece_rate.pr_rate,0)end ))*3,
      (sum(isnull(piece_rate_delivery.prd_quantity,0)))*3 from
      piece_rate,
      piece_rate_delivery,
      piece_rate_supplier,
      piece_rate_type,
      contract,
      outlet,
      renewal_group,
      contract_renewals where
      (piece_rate.prt_key = piece_rate_delivery.prt_key) and
      (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
      (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
      (piece_rate_type.prt_key = piece_rate.prt_key) and
      (contract.contract_no = piece_rate_delivery.contract_no) and
      (outlet.outlet_id = contract.con_base_office) and
      (renewal_group.rg_code = contract.rg_code) and
      (renewal_group.rg_code = piece_rate.rg_code) and
      (outlet.region_id = @region or @region = 0) and
      (outlet.outlet_id = @outlet or @outlet = 0) and
      (piece_rate.pr_effective_date = (select MAX(PR.pr_effective_date) from piece_rate as PR where pr.prt_key = piece_rate.prt_key and pr.rg_code = piece_rate.rg_code)) and
      (piece_rate_delivery.prd_date between @StartDate and @EndDate) and
      (piece_rate_supplier.prs_key = 2) and
      (contract_renewals.contract_no = contract.contract_no) and
      (contract_renewals.contract_seq_number = contract.con_active_sequence) and
      (contract.rg_code = @inRenGroup or @inRenGroup = 0) and
      ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
      (@inContractType = 0 or @inContractType is null))
      group by outlet.region_id
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure EstAdPost : 
--

CREATE procedure [rd].[EstAdPost](@region int,@outlet int,@inRenGroup int,@inContractType int) as
begin
  -- 14/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
  -- sql code.  Used the corresponding piece_rate_suplier.prs_key instead.
  declare @decAmount real,
  @StartDate datetime,
  @EndDate datetime
  select @StartDate=rd.getFirstDayofMonth(datediff(day,rd.getLastDayofMonth(getdate()),-125))
 
  select @EndDate=rd.getLastDayofMonth(datediff(day,rd.getLastDayofMonth(getdate()),-32))
  
  insert into RCMStatPR1(region_id,AdpostCost,AdpostVol)
    select outlet.region_id,
      (sum(case when isnull(piece_rate_delivery.prd_quantity,0)=0 then 0 else piece_rate_delivery.prd_quantity*isnull(piece_rate.pr_rate,0) end ))*3,
      (sum(isnull(piece_rate_delivery.prd_quantity,0)))*3 from
      piece_rate,
      piece_rate_delivery,
      piece_rate_supplier,
      piece_rate_type,
      contract,
      outlet,
      renewal_group,
      contract_renewals where
      (piece_rate.prt_key = piece_rate_delivery.prt_key) and
      (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
      (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
      (piece_rate_type.prt_key = piece_rate.prt_key) and
      (contract.contract_no = piece_rate_delivery.contract_no) and
      (outlet.outlet_id = contract.con_base_office) and
      (renewal_group.rg_code = contract.rg_code) and
      (renewal_group.rg_code = piece_rate.rg_code) and
      (outlet.region_id = @region or @region = 0) and
      (outlet.outlet_id = @outlet or @outlet = 0) and
      (piece_rate.pr_effective_date = (select MAX(PR.pr_effective_date) from piece_rate as PR where pr.prt_key = piece_rate.prt_key and pr.rg_code = piece_rate.rg_code)) and
      (piece_rate_delivery.prd_date between @StartDate and @EndDate) and
      (piece_rate_supplier.prs_key = 1) and
      (contract_renewals.contract_no = contract.contract_no) and
      (contract_renewals.contract_seq_number = contract.con_active_sequence) and
      (contract.rg_code = @inRenGroup or @inRenGroup = 0) and
      ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
      (@inContractType = 0 or @inContractType is null))
      group by outlet.region_id
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure EstCourPostAll : 
--

CREATE procedure  [rd].[EstCourPostAll](@inAll int,@inRegion int,@inRenGroup int,@inContractType int)
as
begin
  -- 14/02/02 PBY Request#4326
  -- Removed hardcoding of 'Kiwimail', 'CourierPost' and 'XP' from
  -- sql code.  Used the corresponding piece_rate_suplier.prs_key instead.
  declare @decAmount real,
  @StartDate datetime,
  @EndDate datetime
  select @StartDate=rd.getFirstDayofMonth(datediff(day,rd.getLastDayofMonth(getdate()),-125)) 
    
  select @EndDate=rd.getLastDayofMonth(datediff(day,rd.getLastDayofMonth(getdate()),-32))
    
  if @inAll <> 1
    insert into RCMStatPR2(Region_id,CourpostCost,CourpostVol)
      select 0,
        (sum(case when isnull(piece_rate_delivery.prd_quantity,0)=0 then 0 else piece_rate_delivery.prd_quantity*isnull(piece_rate.pr_rate,0)end))*3,
        (sum(isnull(piece_rate_delivery.prd_quantity,0)))*3 from
        piece_rate,
        piece_rate_delivery,
        piece_rate_supplier,
        piece_rate_type,
        contract,
        outlet,
        renewal_group,
        contract_renewals where
        (piece_rate.prt_key = piece_rate_delivery.prt_key) and
        (piece_rate_supplier.prs_key = piece_rate_type.prs_key) and
        (piece_rate_type.prt_key = piece_rate_delivery.prt_key) and
        (piece_rate_type.prt_key = piece_rate.prt_key) and
        (contract.contract_no = piece_rate_delivery.contract_no) and
        (outlet.outlet_id = contract.con_base_office) and
        (renewal_group.rg_code = contract.rg_code) and
        (renewal_group.rg_code = piece_rate.rg_code) and
        (piece_rate.pr_effective_date = (select MAX(PR.pr_effective_date) from piece_rate as PR where pr.prt_key = piece_rate.prt_key and pr.rg_code = piece_rate.rg_code)) and
        (piece_rate_delivery.prd_date between @StartDate and @EndDate) and
        (piece_rate_supplier.prs_key = 2) and
        (contract_renewals.contract_no = contract.contract_no) and
        (contract_renewals.contract_seq_number = contract.con_active_sequence) and
        ((contract.con_base_cont_type = @inContractType and @inContractType > 0) or
        (@inContractType = 0 or @inContractType is null))
  else
    insert into RCMStatPR2(Region_id,CourpostCost,CourpostVol)
      select 0,sum(CourpostCost),sum(CourpostVol) from RCMStatPR2
  return(@inregion)
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure  [rd].[sp_vehiclesum_agev2](@inRegion int,@inOutlet int,@inRengroup int,@inContract_type int)
-- TJB  SR4670  Sept 2005
-- Reorganised where clauses to match related procedures''
--mod RB
as --28/5/2001 - exclude terminated contracts
begin
  declare 
  @nAgeUpto5Years int,
  @nAge5To10Years int,
  @nAgeOver10Years int,
  @nAgeUnknown int
  select @nAgeUpto5Years = Count(distinct vehicle.vehicle_number)
    from outlet join contract as con on outlet.outlet_id = con.con_base_office 
    join contract_renewals on con.contract_no = contract_renewals.contract_no
    join contract_vehical on contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number
    -- PBY 12/06/2002 SR#4401
    -- and contract_vehical.cv_vehical_status = 'A'
    -- TJB  SR4670  Sept-2005
    -- Changed sequence number to con_active_sequence 
    -- to avoid multiple rows error in f_GetLatestVehicle
    and contract_vehical.vehicle_number = rd.f_GetLatestVehicle(con.contract_no,con.con_active_sequence)
    join vehicle on contract_vehical.vehicle_number = vehicle.vehicle_number
	 join types_for_contract on
    types_for_contract.contract_no = con.contract_no where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
    (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
    (con.con_date_terminated is null or con.con_date_terminated >= rd.today()) and
    (year(rd.today())-vehicle.v_vehicle_year) <= 5
    select @nAge5To10Years = Count(distinct vehicle.vehicle_number) 
    from outlet join contract as con on outlet.outlet_id = con.con_base_office
	join contract_renewals on con.contract_no = contract_renewals.contract_no
	 join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number
    -- PBY 12/06/2002 SR#4401
    -- and contract_vehical.cv_vehical_status = 'A'
    -- TJB  SR4670  Sept-2005
    -- Changed sequence number to con_active_sequence 
    -- to avoid multiple rows error in f_GetLatestVehicle
    and contract_vehical.vehicle_number = rd.f_GetLatestVehicle(con.contract_no,con.con_active_sequence)
    join vehicle on contract_vehical.vehicle_number = vehicle.vehicle_number
	 join types_for_contract on
    types_for_contract.contract_no = con.contract_no where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
    (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
    (con.con_date_terminated is null or con.con_date_terminated >= rd.today()) and
    (year(rd.today())-vehicle.v_vehicle_year) > 5 and
    (year(rd.today())-vehicle.v_vehicle_year) <= 10
    select @nAgeOver10Years = Count(distinct vehicle.vehicle_number)
    from outlet join contract as con on
    outlet.outlet_id = con.con_base_office
	join contract_renewals on con.contract_no = contract_renewals.contract_no
	 join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number
    -- PBY 12/06/2002 SR#4401
    -- and contract_vehical.cv_vehical_status = 'A'
    -- TJB  SR4670  Sept-2005
    -- Changed sequence number to con_active_sequence 
    -- to avoid multiple rows error in f_GetLatestVehicle
    and contract_vehical.vehicle_number = rd.f_GetLatestVehicle(con.contract_no,con.con_active_sequence)
    join vehicle on contract_vehical.vehicle_number =vehicle.vehicle_number
	 join types_for_contract on
    types_for_contract.contract_no = con.contract_no where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
    (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
    (con.con_date_terminated is null or con.con_date_terminated >= rd.today()) and
    (year(rd.today())-vehicle.v_vehicle_year) > 10
  select @nAgeUnknown = Count(distinct vehicle.vehicle_number) 
    from outlet join contract as con on
    outlet.outlet_id = con.con_base_office
	join contract_renewals on con.contract_no = contract_renewals.contract_no
	 join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number
    -- PBY 12/06/2002 SR#4401
    -- and contract_vehical.cv_vehical_status = 'A',
    -- TJB  SR4670  Sept-2005
    -- Changed sequence number to con_active_sequence 
    -- to avoid multiple rows error in f_GetLatestVehicle
    and contract_vehical.vehicle_number = rd.f_GetLatestVehicle(con.contract_no,con.con_active_sequence)
    join vehicle on contract_vehical.vehicle_number = vehicle.vehicle_number
	 join types_for_contract on
    types_for_contract.contract_no = con.contract_no where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
    (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
    (con.con_date_terminated is null or con.con_date_terminated >= rd.today()) and
    (vehicle.v_vehicle_year is null or vehicle.v_vehicle_year = 0)
  select @nAgeUpto5Years,
    @nAge5To10Years,
    @nAgeOver10Years,
    @nAgeUnknown 
end



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE procedure [rd].[sp_vehiclesum_fueltypev2](
@inRegion int,
@inOutlet int,
@inrengroup int,
@inContract_Type int)
-- TJB  SR4670  Sept 2005
as -- Reorganised where clauses to match related procedures''
begin
  select fuel_type.ft_description,
    (select Count(distinct vehicle.vehicle_number) 
  from outlet 
--!      join contract on outlet.outlet_id = contract.con_base_office,
--!      contract_renewals  join contract c1 on contract_renewals.contract_no=c1.contract_no
      join contract on outlet.outlet_id = contract.con_base_office
	  join contract_renewals on contract_renewals.contract_no=contract.contract_no
      join contract_vehical on
      contract_renewals.contract_no = contract_vehical.contract_no and
      contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
      -- PBY 12/06/2002 SR#4401
      -- and contract_vehical.cv_vehical_status = 'A'
      -- TJB  SR4670  Sept-2005
      -- Changed sequence number to con_active_sequence 
      -- to avoid multiple rows error in f_GetLatestVehicle
--!      contract_vehical.vehicle_number = rd.f_GetLatestVehicle(c1.contract_no,c1.con_active_sequence),
--!      contract_vehical cv2 join vehicle on cv2.vehicle_number=vehicle.vehicle_number ,
--!      contract c2
--!      join types_for_contract on types_for_contract.contract_no = c2.contract_no 
      contract_vehical.vehicle_number = rd.f_GetLatestVehicle(contract.contract_no,contract.con_active_sequence)
	  join vehicle on contract_vehical.vehicle_number=vehicle.vehicle_number
      join types_for_contract on types_for_contract.contract_no = contract.contract_no 

  where
      (outlet.region_id = @inRegion or @inRegion = 0) and
      (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
      (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
      (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
      (contract.con_date_terminated is null or contract.con_date_terminated >= rd.today()) and
      vehicle.ft_key = fuel_type.ft_key)  as SumVehicle from
    fuel_type
end














GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_vehiclesum_capacityv2](
@inRegion int,
@inOutlet int,
@inrengroup int,
@inContract_Type int)
-- TJB  SR4670  Sept 2005
as -- Reorganised where clauses to match related procedures''
begin
  declare @nUpto2Litres int
  declare @nAt2Litres int
  declare @nOver2Litres int
  declare @nUnknown int

  select @nUpto2Litres=Count(distinct vehicle.vehicle_number) 
--!  from outlet join contract on outlet.outlet_id = contract.con_base_office,
--!    contract_renewals join contract as c1 on contract_renewals.contract_no=c1.contract_no join contract_vehical on
  from outlet join contract on outlet.outlet_id = contract.con_base_office
	join contract_renewals on contract_renewals.contract_no=contract.contract_no join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    
    -- PBY 12/06/2002 SR#4401
    -- and contract_vehical.cv_vehical_status = 'A'
    -- TJB  SR4670  Sept-2005
    -- Changed sequence number to con_active_sequence 
    -- to avoid multiple rows error in f_GetLatestVehicle
--!    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(c1.contract_no,c1.con_active_sequence),
--!    contract_vehical cv2 join vehicle on  cv2.vehicle_number=vehicle.vehicle_number,
--!    contract c2 join types_for_contract on types_for_contract.contract_no = c2.contract_no 
    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(contract.contract_no,contract.con_active_sequence)
	join vehicle on  contract_vehical.vehicle_number=vehicle.vehicle_number
	join types_for_contract on types_for_contract.contract_no = contract.contract_no 
  where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
    (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
    (contract.con_date_terminated is null or contract.con_date_terminated >= rd.today()) and
    vehicle.v_vehicle_cc_rating < 1975

  select @nAt2Litres=Count(distinct vehicle.vehicle_number) 
  from 
--!    outlet join contract on outlet.outlet_id = contract.con_base_office,
--!    contract_renewals join contract as c1 on contract_renewals.contract_no=c1.contract_no join contract_vehical on
    outlet join contract on outlet.outlet_id = contract.con_base_office
    join contract_renewals on contract_renewals.contract_no=contract.contract_no join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    -- PBY 12/06/2002 SR#4401
    -- and contract_vehical.cv_vehical_status = 'A'
    -- TJB  SR4670  Sept-2005
    -- Changed sequence number to con_active_sequence 
    -- to avoid multiple rows error in f_GetLatestVehicle
--!    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(c1.contract_no,c1.con_active_sequence),
--!    contract_vehical cv2 join vehicle on cv2.vehicle_number=vehicle.vehicle_number,
--!    contract c2 join types_for_contract on types_for_contract.contract_no = c2.contract_no 
    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(contract.contract_no,contract.con_active_sequence)
    join vehicle on contract_vehical.vehicle_number=vehicle.vehicle_number
	join types_for_contract on types_for_contract.contract_no = contract.contract_no 

 where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
    (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
    (contract.con_date_terminated is null or contract.con_date_terminated >= rd.today()) and
    vehicle.v_vehicle_cc_rating between 1975 and 2025

  select @nOver2Litres=Count(distinct vehicle.vehicle_number) 
  from 
--!    outlet join contract on outlet.outlet_id = contract.con_base_office,
--!    contract_renewals join contract as c1 on contract_renewals.contract_no=c1.contract_no  join contract_vehical on
    outlet join contract on outlet.outlet_id = contract.con_base_office
    join contract_renewals on contract_renewals.contract_no=contract.contract_no  join contract_vehical on    
	contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    -- PBY 12/06/2002 SR#4401
    -- and contract_vehical.cv_vehical_status = 'A'
    -- TJB  SR4670  Sept-2005
    -- Changed sequence number to con_active_sequence 
    -- to avoid multiple rows error in f_GetLatestVehicle
--!    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(c1.contract_no,c1.con_active_sequence),
--!    contract_vehical cv2 join vehicle on cv2.vehicle_number=vehicle.vehicle_number,
--!    contract c2 join types_for_contract on types_for_contract.contract_no = c2.contract_no 
    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(contract.contract_no,contract.con_active_sequence)
	join vehicle on contract_vehical.vehicle_number=vehicle.vehicle_number
	join types_for_contract on types_for_contract.contract_no = contract.contract_no 

  where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
    (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
    (contract.con_date_terminated is null or contract.con_date_terminated >= rd.today()) and
    vehicle.v_vehicle_cc_rating > 2025

  select @nUnknown=Count(distinct vehicle.vehicle_number) 
  from 
--!    outlet join contract on outlet.outlet_id = contract.con_base_office,
--!    contract_renewals join contract as c1 on contract_renewals.contract_no=c1.contract_no join contract_vehical on
    outlet join contract on outlet.outlet_id = contract.con_base_office
    join contract_renewals on contract_renewals.contract_no=contract.contract_no join contract_vehical on
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    -- PBY 12/06/2002 SR#4401
    -- and contract_vehical.cv_vehical_status = 'A'
    -- TJB  SR4670  Sept-2005
    -- Changed sequence number to con_active_sequence 
    -- to avoid multiple rows error in f_GetLatestVehicle
--!    contract_vehical.vehicle_number =rd.f_GetLatestVehicle(c1.contract_no,c1.con_active_sequence),
--!    contract_vehical  cv2 join vehicle on cv2.vehicle_number=vehicle.vehicle_number,
--!    contract c2 join types_for_contract on
--!    types_for_contract.contract_no = c2.contract_no where
    contract_vehical.vehicle_number =rd.f_GetLatestVehicle(contract.contract_no,contract.con_active_sequence)
	join vehicle on contract_vehical.vehicle_number=vehicle.vehicle_number
	join types_for_contract on
    types_for_contract.contract_no = contract.contract_no where
    (outlet.region_id = @inRegion or @inRegion = 0) and
    (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
    (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
    (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
    (contract.con_date_terminated is null or contract.con_date_terminated >= rd.today()) and
    vehicle.v_vehicle_cc_rating is null

  select @nUpto2Litres,
    @nAt2Litres,
    @nOver2Litres,
    @nUnknown 
end












GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_vehiclesum_vehicletypev2](@inRegion int,@inOutlet int,@inrengroup int,@inContract_Type int)
-- TJB  SR4670  Sept 2005
as -- Reorganised where clauses to match related procedures''
begin
  select vehicle_type.vt_description,
    (select Count(distinct vehicle.vehicle_number) from
      outlet join contract as co on
--!      outlet.outlet_id = co.con_base_office,
--!      contract_renewals join contract as con on con.contract_no = contract_renewals.contract_no join contract_vehical as conv on
--!      contract_renewals.contract_no = conv.contract_no and
--!      contract_renewals.contract_seq_number = conv.contract_seq_number and
      outlet.outlet_id = co.con_base_office
      join contract_renewals on co.contract_no = contract_renewals.contract_no join contract_vehical as conv on
      contract_renewals.contract_no = conv.contract_no and
      contract_renewals.contract_seq_number = conv.contract_seq_number and
      -- TJB  SR4670  Sept 2005 copying change: PBY 12/06/2002 SR#4401
      -- and contract_vehical.cv_vehical_status = 'A'
      -- Changed sequence number to con_active_sequence 
      -- to avoid multiple rows error in f_GetLatestVehicle
--!      conv.vehicle_number = rd.f_GetLatestVehicle(con.contract_no,con.con_active_sequence),
--!      contract_vehical join vehicle on contract_vehical.vehicle_number = vehicle.vehicle_number,
--!      contract join types_for_contract on
--!      types_for_contract.contract_no = contract.contract_no where
      conv.vehicle_number = rd.f_GetLatestVehicle(co.contract_no,co.con_active_sequence)
		 join vehicle on conv.vehicle_number = vehicle.vehicle_number
		join types_for_contract on
      types_for_contract.contract_no = co.contract_no where
      (outlet.region_id = @inRegion or @inRegion = 0) and
      (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
      (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
      (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
      (co.con_date_terminated is null or co.con_date_terminated >= rd.today()) and
      (vehicle.vt_key = vehicle_type.vt_key)) from
    vehicle_type where
    vt_description not in('boat','motor cycle','truck','bus','minibus','other','others') union
  select 'Other',
    --         sum(
    (select Count(distinct vehicle.vehicle_number) from
      outlet join contract as co on
--!      outlet.outlet_id = co.con_base_office,
--!      contract_renewals join contract as con on con.contract_no = contract_renewals.contract_no join contract_vehical as conv on
--!      contract_renewals.contract_no = conv.contract_no and
--!      contract_renewals.contract_seq_number = conv.contract_seq_number and
      outlet.outlet_id = co.con_base_office
	  join contract_renewals on co.contract_no = contract_renewals.contract_no join contract_vehical as conv on
      contract_renewals.contract_no = conv.contract_no and
      contract_renewals.contract_seq_number = conv.contract_seq_number and
      -- TJB  SR4670  Sept 2005 copying change: PBY 12/06/2002 SR#4401
      -- and contract_vehical.cv_vehical_status = 'A'
      -- Changed sequence number to con_active_sequence 
      -- to avoid multiple rows error in f_GetLatestVehicle
--!      conv.vehicle_number = rd.f_GetLatestVehicle(con.contract_no,con.con_active_sequence),
--!      contract_vehical join vehicle on contract_vehical.vehicle_number = vehicle.vehicle_number,
--!      contract join types_for_contract on
--!      types_for_contract.contract_no = contract.contract_no where
      conv.vehicle_number = rd.f_GetLatestVehicle(co.contract_no,co.con_active_sequence)
	  join vehicle on conv.vehicle_number = vehicle.vehicle_number
	  join types_for_contract on
      types_for_contract.contract_no = co.contract_no where
      (outlet.region_id = @inRegion or @inRegion = 0) and
      (outlet.outlet_id = @inOutlet or @inOutlet = 0) and
      (types_for_contract.ct_key = @inContract_type or @inContract_type = 0) and
      (contract_renewals.con_rg_code_at_renewal = @inrengroup or(@inrengroup = 0 or @inrengroup is null)) and
      (co.con_date_terminated is null or co.con_date_terminated >= rd.today()) and
      (vehicle.vt_key = vehicle_type.vt_key)) from
    --         )
    vehicle_type where
    vt_description in('boat','motor cycle','truck','bus','minibus','other','others')
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_TNegativePay : 
--

CREATE procedure [odps].[OD_RPS_TNegativePay]
as
begin
  select t_payment.contract_no,
    contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_initials,
    Gross_Pay=odps.OD_RPF_PCTNegativePayGetSum(t_payment.invoice_id,'GP')
				+odps.OD_RPF_PCTNegativePayGetSum(t_payment.invoice_id,'OGP'),
    GST=odps.OD_RPF_PCTGetSum(t_payment.invoice_id,'GST')*-1,
    Tax=abs(odps.OD_RPF_PCTGetSum(t_payment.invoice_id,'TAX')),
    Post_Tax_Adjustments=odps.OD_RPF_PCTGetSum(t_payment.invoice_id,'PTD')*-1,
    Net_Pay=odps.OD_RPF_PCTNegativePayGetSum(odps.t_payment.invoice_id,'GP')
			+odps.OD_RPF_PCTNegativePayGetSum(odps.t_payment.invoice_id,'OGP')
			+odps.OD_RPF_PCTGetSum(odps.t_payment.invoice_id,'GST')*-1
			-abs(odps.OD_RPF_PCTGetSum(odps.t_payment.invoice_id,'TAX'))
			-odps.OD_RPF_PCTGetSum(odps.t_payment.invoice_id,'PTD')*-1
from
    rd.contractor,
    t_payment where
    contractor.contractor_supplier_no = t_payment.contractor_supplier_no and
    odps.OD_RPF_PCTNegativePayGetSum(t_payment.invoice_id,'GP')+odps.OD_RPF_PCTNegativePayGetSum(t_payment.invoice_id,'OGP')
	+odps.OD_RPF_PCTGetSum(t_payment.invoice_id,'GST')*-1
	-abs(odps.OD_RPF_PCTGetSum(t_payment.invoice_id,'TAX'))
	-odps.OD_RPF_PCTGetSum(t_payment.invoice_id,'PTD')*-1 < 0
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[jsresult]
-- TJB  Sept 2005  NPAD2 address schema changes
-- Added adr_unit number and road_suffix to relevant parts of address returned
-- Changed adr_nad_reference to adr_dp_id
--
-- TJB  SR4681  July 2006
-- Added post code to value returned as 'cust_mail_town'
as -- was cust_nad_reference (tjb Sept''05)
begin
  select distinct
    cust_id=rc.cust_id,
    cust_adpost_quantity=rc.cust_adpost_quantity,
    cust_date_first_loaded=rc.cust_date_commenced,
    cust_date_last_transfered=cam.move_in_date,
    cust_date_left=null,
    contract_no=adr.contract_no,
    cust_title=rc.cust_title,
    rc.cust_surname_company,
    rc.cust_initials,
    cust_rd_number=adr.adr_rd_no,
    cust_mailing_address_no=case when adr.adr_unit is null then '' else rd.trim(adr.adr_unit)+'/' end +
    case when adr.adr_no is null then '' else rd.trim(adr.adr_no) end +
    case when adr.adr_alpha is null then '' else rd.trim(adr.adr_alpha) end,
    cust_mailing_address_road=road.road_name+
    case when road_type.rt_name is null then '' else ' '+road_type.rt_name end+
    case when road_suffix.rs_name is null then '' else ' '+road_suffix.rs_name end,
    cust_mailing_address_locality=suburblocality.sl_name,
    cust_mail_town=towncity.tc_name+'    '+post_code.post_code,
    adr_dp_id=convert(char(12),adr.dp_id),
    rc.cust_phone_day,
    rc.cust_phone_night,
    rc.cust_dir_listing_text,
    cust_delivery_days=rd.f_GetDeliveryDays(rc.cust_id),
    rc.cust_business,
    rc.cust_rural_resident,
    rc.cust_rural_farmer,
    contract.con_rd_ref_text,
    contract.con_title,
    rc.cust_dir_listing_ind,
    cust_property_identification=adr.adr_property_identification,
    cust_post_code=post_code.post_code,
    null,
    null from
    rds_customer as rc,
--!    address as adr left outer join road on adr.road_id = road.road_id left outer join road_type on road.rt_id = road_type.rt_id left outer join road_suffix on road.rs_id = road_suffix.rs_id,
--!    address as adrr left outer join suburblocality on adrr.sl_id = suburblocality.sl_id,
--!    address as adrrr left outer join towncity on adrrr.tc_id = towncity.tc_id,
    address as adr left outer join road on adr.road_id = road.road_id left outer join road_type on road.rt_id = road_type.rt_id left outer join road_suffix on road.rs_id = road_suffix.rs_id
    left outer join suburblocality on adr.sl_id = suburblocality.sl_id
	left outer join towncity on adr.tc_id = towncity.tc_id,

    customer_address_moves as cam,
    contract,
    report_temp,
    post_code where
    contract.contract_no = adr.contract_no and
    cam.adr_id = adr.adr_id and
    rc.cust_id = cam.cust_id and
    rc.master_cust_id is null and
    cam.move_out_date is null and
    post_code.post_code_id = adr.post_code_id and
    rc.cust_id = report_temp.customer_id
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[rds_npad_modify_address](
@in_dpid int,
@in_adr_no int,
@in_adr_alpha char(20),
@in_adr_unit char(10),
@in_unique_road_id int,
@in_sl_id int,
@in_tc_id int,
@in_rd_no char(40),
@in_post_code char(4),
@in_adr_property char(100),
@in_username char(20),
@in_xcoordinate numeric(10,2),
@in_ycoordinate numeric(10,2))

/******************************************************************
* Description
*    This routine modifies an address record in the RDS system.
*
* System
*    NPAD2 - NZ Post
*
* Author
*    Tom Britton, Synergy International
*
* Created on
*    November 2005
*
* Modification history
* 13 Feb 2006  TJB  Added X and Y coordinate parameters as per CR13
* 14 Feb 2006  TJB  Removed checks for DPID being a master, and 
*                   non-numerics in in_adr_no.
*                   Add insert of geocode if the address doesn't have one.
* 30 Mar 2006  TJB  Fixed bug with updating property name.
*  5 Apr 2006  TJB  Ensure RD numbers for Oamaru are 3 chars
*                   with the last char an alpha.
*                   Added Contract # lookup in case the change 
*                   is to a new RD route/post code.
* 11 May 2006  TJB  SR4687: If a road/suburb association doesn't 
*                   exist, create it (don''t flag it as an error).
*****************************************************************/
as
begin
  declare @status int, -- Return status (0 = success)
  @description char(100), -- Return description (mainly error
  -- message)
  @found tinyint, -- Flag indicating a database record 
  -- exists (1) or not (NULL)
  @msg char(80), -- Test message
  @adrID int, -- New address ID
  @custID int, -- New customer ID
  @masterID int, -- Master customer ID
  @masterAddress int, -- Master customer''s address ID
  -- Most of these are used to ensure either a proper value or NULL
  -- is used to create the address or customer record (the passed
  -- value may be '' or 0 instead of NULL).
  -- In other cases, the passed value can be used when it is required
  -- and has passed validation (eg adr_no, tc_id, rd_no, post_code)
  @adr_no char(20), -- RDS street number: normalised input value
  @adr_unit char(10), -- RDS address unit
  @adr_alpha char(20), -- RDS address alpha
  @slID int, -- RDS address suburb
  @tcID int, -- RDS address mailtown
  @rdNo char(20), -- RDS RD Number
  @roadID int, -- RDS road_id
  @postCode char(4), -- RDS post code
  @postcodeID int, -- Post Code ID
  @master_dpid int, -- RDS dpid of master customer
  @contract_no int, -- Contract number
  @temp_int int, -- Temporary number
  @now datetime
  -- Need the date and time for the logged actions
  select @now=getdate()
  select @status=0
  /************************************************************
  * Validate the input parameters
  ***********************************************************/
  -- Check to see that the dpid is valid ...
  if @in_dpid is null or @in_dpid <= 0
    begin
      select @status=101
      select @description='Dpid does not exist or invalid'
    end
  -- ... and does already exist
  if @status = 0
    begin
      select @found=null
      select @found = count(*) from
        address where
        dp_id = @in_dpid
      if @found is null or @found < 1
        begin
          select @status=101
          select @description='Dpid does not exist or invalid'
        end
      else
      if @found is not null and @found > 1
        begin
          select @status=120
          select @description='Dpid exists more than once!'
        end
    end
  /* This isn't relevant: if the DPID was found in the address table, it is either
  *                      associated with a master customer, or an unoccupied address. 
  *                      If NPAD sends the DPID of a non-master (recipient) the DPID
  *                      won't be in the address table and will have been invalidated 
  *                      above.
  *
  *       -- ... and is a master
  *   if @status = 0 
  *   and not exists (select 1 from customer_address_moves, rds_customer
  *                    where customer_address_moves.dp_id = @in_dpid
  *                      and customer_address_moves.move_out_date is null
  *                      and rds_customer.cust_id = customer_address_moves.cust_id
  *                      and rds_customer.master_cust_id is null)
  *   then
  *       set @status = 102;
  *       set @description = 'Dpid is not a master';
  *   end if;
  */
  -- Check to see that the road ID is valid ...
  if @status = 0 and
    (@in_unique_road_id is null or @in_unique_road_id <= 0)
    begin
      select @status=103
      select @description='Unique_road_id does not exist or invalid'
    end
  -- ... and does exist
  -- We get the road_id for the road to use below
  if @status = 0
    begin
      select @roadID=null
      select @roadID = road_id from
        road where
        unique_road_id = @in_unique_road_id
      if @roadID is null
        begin
          select @status=103
          select @description='Unique_road_id does not exist or invalid'
        end
    end
  -- Check to see if a street number is specified
  if @status = 0
    if @in_adr_no is not null and @in_adr_no > 0
      select @adr_no=convert(char(20),@in_adr_no)
    else
      select @adr_no=null
  /* This isn't relevant now: in_adr_no is numeric so cannot contain non-numerics
  *
  *       -- If there is a street number, it must not contain non-numeric characters
  *       if @adr_no is not null and isnumeric(@adr_no) = 0 then
  *           set @status = 110;
  *           set @description = 'Invalid street number'';
  *       end if;
  */
  -- Check to see if the unit number is valid (if specified)
  -- ==> any value is allowed
  -- Set @adr_unit to the @in_adr_unit value or NULL
  -- eliminating the possibl passed value of ''.
  if @status = 0
    begin
      if @in_adr_unit is not null and len(@in_adr_unit) > 0
        select @adr_unit=@in_adr_unit
      else
        select @adr_unit=null
      -- Check to see if the number alpha is valid (if specified)
      -- ==> any value is allowed
      -- Set @adr_alpha to the @in_adr_alpha value or NULL
      -- eliminating the possibl passed value of ''.
      if @in_adr_alpha is not null and len(@in_adr_alpha) > 0
        select @adr_alpha=@in_adr_alpha
      else
        select @adr_alpha=null
      -- Check to see if the suburb is valid (if specified)
      if @in_sl_id is not null and @in_sl_id > 0
        begin
          if not exists(select 1 from suburbLocality where
              sl_id = @in_sl_id)
            begin
              select @status=104
              select @description='LocalityID does not exist or invalid'
            end
          select @slID=@in_sl_id
        end
      else -- We use @slID in place of @in_sl_id to
        -- ensure its value is either a real value
        select @slID=null
    end
  -- or NULL.  This eliminates the possibility
  -- of it being 0.
  -- Check to see if the mailtown is valid (must be specified)
  if @status = 0
    if @in_tc_id is null
      begin
        select @status=105
        select @description='MailtownID does not exist or invalid'
      end
    else
    if not exists(select 1 from townCity where
      tc_id = @in_tc_id) or
    @in_tc_id <= 0
      begin
        select @status=105
        select @description='MailtownID does not exist or invalid'
      end
    else
      select @tcID=@in_tc_id -- We use @tcID in place of @in_tc_id
  if @status = 0
    -- Check to see if an RD number was specified
    if @in_rd_no is not null and len(@in_rd_no) > 0
      select @rdno=@in_rd_no
    else
      begin
        select @rdno=null
        select @status=108
        select @description='RD number missing or invalid'
      end
  -- Check that the RD number is valid for Oamaru
  -- (3 chars with the last char an alpha)
  if @status = 0 and @in_tc_id = (select tc_id from towncity where
      tc_name = 'Oamaru')
    begin
      select @rdno=ltrim(rtrim(@rdno))
      if len(@rdno) > 3
        begin
          select @status=108
          select @description='RD number missing or invalid'
        end
      else
      if len(@rdno) < 3
        select @rdno=space(3-len(@rdno))+@rdno
      if @status = 0 and(isnumeric(right(@rdno,1)) = 1 or right(@rdno,1) = ' ')
        begin
          select @status=120
          select @description='RD number invalid for Oamaru'
        end
    end
  -- Check to see if a post code was specified
  if @status = 0
    if @in_post_code is not null and len(@in_post_code) <> 4
      begin
        select @postCode=null
        select @status=109
        select @description='Post code missing or invalid'
      end
    else
      begin
        select @postCode=@in_post_code
        -- ... and that it exists (assume is the right one)
        select @postCodeID=rd.f_getPostCodeID(@in_post_code,@in_tc_id,@roadID)
        if @postCodeID = -1
          begin
            select @status=109
            select @description='Post code missing or invalid'
          end
      end
  --    -- Check to see if the road exists in the suburb (if specified)
  --    if @status = 0 and @slID is not null then
  --        if not exists (select 1 from road_suburb
  --                        where sl_id = @slID
  --                          and road_id = @roadID)
  --        then
  --            set @status = 106;
  --            set @description = 'Street does not exist in Locality';
  --        end if;
  --    end if;
  -- Check to see if the road exists in the mailtown
  if @status = 0 and @tcID is not null
    if not exists(select 1 from town_road where
        tc_id = @tcId and
        road_id = @roadID)
      begin
        select @status=107
        select @description='Street does not exist in Mailtown'
      end
  -- Check to see if the suburb exists in the mailtown (if specified)
  if @status = 0 and @slID is not null
    if not exists(select 1 from town_suburb where
        sl_id = @slID and
        tc_id = @tcID)
      begin
        select @status=119
        select @description='Locality does not exist in Mailtown'
      end
  -- Get the contract number for the new address
  if @status = 0
    begin
      -- See if we can determine the contract number
      -- Look for other addresses in the same RD/post code
      select @temp_int = count(distinct @contract_no) from
        address as a join post_code on
--!        a.post_code_id = post_code.post_code_id,
--!        address as q join road on
--!        q.road_id = road.road_id where
         a.post_code_id = post_code.post_code_id
		 join road on
        a.road_id = road.road_id where
       post_code = @in_post_code and
        a.adr_rd_no = @RDno and
        @contract_no is not null and
        unique_road_id = @in_unique_road_id
      if @@error <> 0
        begin
          select @description='SQL Error '+convert(char(6),@@error)+' counting contract#s in post_code'
          select @status=-1
        end
      if @temp_int = 1 and @status = 0
        begin
     select @contract_no =f.t from (select  distinct a.contract_no as t from
            address as a join post_code on
--!            a.post_code_id = post_code.post_code_id,
--!            address as q join road on
--!            q.road_id = road.road_id where
            a.post_code_id = post_code.post_code_id
			join road on
            a.road_id = road.road_id where

            post_code = @in_post_code and
            a.adr_rd_no = @RDno and
            @contract_no is not null and
            unique_road_id = @in_unique_road_id) f
          if @@error <> 0
            begin
              select @description='SQL Error '+convert(char(6),@@error)+' getting contract# for address'
              select @status=-1
            end
        end
      else
        select @contract_no=null
    end
  /************************************************************
  * Do the modifications
  ***********************************************************/
  if @status = 0
    begin
      -- Get the adr_id of the address
      select @adrID = adr_id from
        address where
        dp_id = @in_dpid
      -- Update the address record
      update address set
        adr_no = @adr_no,
        contract_no = @contract_no,
        adr_unit = @adr_unit,
        adr_alpha = @adr_alpha,
        adr_property_identification = @in_adr_property,
        road_id = @roadID,
        sl_id = @slID,
        tc_id = @tcID,
        adr_rd_no = @rdNO,
        post_code_id = @postcodeID,
        adr_last_amended_date = @now,
        adr_last_amended_user = @in_username where
        dp_id = @in_dpid
      if @@error <> 0
        begin
          select @description='SQL Error '+convert(char(6),@@error)+' updating address record'
          select @status=-1
        end
      else
        select @msg='Updated address'
      -- If there is a street number for the address, clear the DPIDs 
      -- associated with any customers at the address.
      if @status = 0 and @adr_no is not null
        begin
          update customer_address_moves set
            dp_id = null where
            adr_id = @adrID
          if @@error <> 0 and @@rowcount <> 0 /* was @@error <>100 */
            begin
              -- Return error if the error isn't 'not found'' (100)
              select @description='SQL Error '+convert(char(6),@@error)+' removing DPIDs from customers'
              select @status=-1
            end
          else
            select @msg=@msg+' and removed customer DPIDs'
        end
      -- If the road doesn''t already exist in the suburb, creeate it.
      if @status = 0
        if @slID is not null
          if not exists(select 1 from road_suburb where
              sl_id = @slID and
              road_id = @roadID)
            begin
              insert into road_suburb(sl_id,road_id) values(
                @slID,@roadID)
              if @@error <> 0
                begin
                  select @status=-1
                  select @description='SQL Error '+convert(char(6),@@error)+' creating road_suburb record'
                end
            end
      -- Update the geocode values
      if @status = 0
        begin
          -- If there''s an entry for the geocode, update it.  Otherwise
          -- create a new entry for it.
          if exists(select 1 from address_geocode where adr_id = @adrID)
            update address_geocode set
              geocode_x = @in_xcoordinate,
              geocode_y = @in_ycoordinate where
              adr_id = @adrID
          else
            insert into address_geocode(adr_id,
              geocode_x,geocode_y) values(
              @adrID,@in_xcoordinate,@in_ycoordinate)
          if @@error <> 0
            begin
              -- Return error
              select @description='SQL Error '+convert(char(6),@@error)+' updating address geocode'
              select @status=-1
            end
        end
    end
  /************************************************************
  * Done.  Return status
  ***********************************************************/
  if @status = 0
    begin
      commit transaction -- Commit the changes
      select @description='Success'+' - '+@msg
    end
  else
    rollback transaction
  -- Log the message
  select @msg=ltrim(rtrim(convert(char(20),@in_adr_no)))+','+
    ltrim(rtrim(@in_adr_alpha))+','+
    rtrim(ltrim(@in_adr_unit))+','+
    ltrim(rtrim(convert(char(8),@in_unique_road_id)))+','+
    rtrim(ltrim(convert(char(8),@in_sl_id)))+','+
    rtrim(ltrim(convert(char(8),@in_tc_id)))+','+
    ltrim(rtrim(@in_rd_no))+','+
    ltrim(rtrim(@in_post_code))
  insert into NPAD_msg_log(msg_date,
    msg_username,msg_type,msg_dpid,msg_status,msg_description) values(
    @now,@in_username,'modify address',@in_dpid,@status,@msg)
  -- Return status
  select Status=@status,Description=@description 
  return @status
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetPerformanceSummary : 
--

CREATE procedure [rd].[sp_GetPerformanceSummary](
@inRegion decimal(12,2),
@inMonth datetime)
as
begin
  create table #tmp_performance_table(
    detailtype char(2) null,
    datagroup char(2) null,
    sortorder decimal(12,2) null,
    monthact decimal(12,2) null,
    monthbud decimal(12,2) null,
    description char(40) null,
    ytdact decimal(12,2) null,
    ytdbud decimal(12,2) null)
  declare @dMonthStart datetime
  declare @dMonthEnd datetime
  declare @dYearStart datetime
  declare @dYearEnd datetime
  declare @dPrevMonthEnd datetime
  declare @iLettersCount int
  declare @iSmallParcels int
  declare @iLargeParcels int
  declare @iExtnLetters int
  declare @iExtnSmallParcels int
  declare @iExtnLargeParcels int
  declare @decYTDDelHours decimal(12,2)
  declare @decYTDSortHours decimal(12,2)
  declare @decYTDDistance decimal(12,2)
  declare @decMonthDelHours decimal(12,2)
  declare @decMonthSortHours decimal(12,2)
  declare @decMonthDistance decimal(12,2)
  declare @numCustSum int
  declare @decYTDStart int
  declare @decYTDTrans int
  declare @decYTDStop int
  declare @decMonthStart int
  declare @decMonthTrans int
  declare @decMonthStop int
  declare @iYTDRenNo int
  declare @iYTDOutNo int
  declare @decYTDRenVal decimal(12,2)
  declare @decYTDOutVal decimal(12,2)
  declare @iMonRenNo int
  declare @iMonOutNo int
  declare @decMonRenVal decimal(12,2)
  declare @decMonOutVal decimal(12,2)
  declare @iYTDRenTrans int
  declare @iMonthRenTrans int
  declare @iYTDConCancelled int
  declare @iMonthConCancelled int
  select @dMonthStart=rd.ymd(year(@inMonth),month(@inMonth),1)
  select @dMonthEnd=dateadd(day,-1,dateadd(month,1,@dMonthStart))
  select @dPrevMonthEnd=dateadd(day,-1,@dMonthStart)
  if month(@dMonthStart) < 4
    begin
      select @dYearStart=rd.ymd(year(@dMonthStart)-1,4,1)
      select @dYearEnd=rd.ymd(year(@dMonthStart),3,31)
    end
  else
    begin
      select @dYearStart=rd.ymd(year(@dMonthStart),4,1)
      select @dYearEnd=rd.ymd(year(@dMonthStart)+1,3,31)
    end
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','TR',
    10,0,0,'TOTAL REVENUE',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','TR',
    20,0,0,'OWNER DRIVER EXPENDITURE',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','TR',
    30,0,0,'OTHER EXPENDITURES',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','TR',
    40,0,0,'TOTAL EXPENDITURES',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','TR',
    50,0,0,'PROFIT CONTRIBUTION',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('S1','MV',
    60,0,0,'MAIL VOLUMES',0,0)
  execute rd.ps_count_articles @inRegion,@dYearStart,@dMonthEnd,@iLettersCount,@iSmallParcels,@iLargeParcels,@iExtnLetters,@iExtnSmallParcels,@iExtnLargeParcels
  execute rd.ps_Renewal_Information @inRegion,@dYearStart,@dMonthEnd,@decYTDDelHours,@decYTDSortHours,@decYTDDistance,@decMonthDelHours,@decMonthSortHours,@decMonthDistance
  execute rd.ps_Customers @inRegion,@dYearStart,@dMonthEnd,@decYTDStart,@decYTDTrans,@decYTDStop,@decMonthStart,@decMonthTrans,@decMonthStop
  execute rd.ps_serviceplan @inRegion,@dYearStart,@dMonthEnd,@iYTDRenNo,@iYTDOutNo,@decYTDRenVal,@decYTDOutVal,@iMonRenNo,@iMonOutNo,decRenVal,@decMonOutVal,@iYTDRenTrans,@iMonthRenTrans,@iYTDConCancelled,iMonConCancelled
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','MV',
    70,@iExtnLetters,0,'Letters',@iLettersCount,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','MV',
    80,@iExtnSmallParcels,0,'Small Parcels',@iSmallParcels,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','MV',
    90,@iExtnLargeParcels,0,'Large Parcels',@iLargeParcels,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','MV',
    100,rd.GetPRSupplierVolumes(@inRegion,2,@dMonthStart,@dMonthEnd),0,'Courier Post',rd.GetPRSupplierVolumes(@inRegion,2,@dYearStart,@dMonthEnd),0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','MV',
    110,rd.GetPRSupplierVolumes(@inRegion,1,@dMonthStart,@dMonthEnd),0,'Kiwimail',rd.GetPRSupplierVolumes(@inRegion,1,@dYearStart,@dMonthEnd),0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('S2','OK',
    120,0,0,'OTHER KEY INDICATORS',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    130,0,0,'FTEU Level',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    140,0,0,'Overtime Hours',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    150,@decMonthDelHours,0,'Delivery Hours (p.w.)',@decYTDDelHours,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    160,@decMonthSortHours,0,'Sort Hours (p.w.)',@decYTDSortHours,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    170,@decMonthDistance,0,'KM Travelled (p.a.)',@decYTDDistance,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    179,@decMonthStart,0,'Average Cost per Article ($)',rd.NZPRegion(@inRegion,0,0)/rd.VolRegion(@inRegion,0,0),0)
  execute pGetNumCusts @inRegion,@numCustSum
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    180,@decMonthStart,0,'Number of Customers',@numCustSum,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    181,@decMonthStart,0,'Number of New Customers',@decYTDStart,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    182,@decMonthStart,0,'Average Cost per Customer ($)',rd.NZPRegion(@inRegion,0,0)/@numCustSum,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    190,@decMonthTrans,0,'Number of Transfers',@decYTDTrans,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','OK',
    200,@decMonthStop,0,'Number of Relinquishments',@decYTDStop,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('S3','SP',
    210,0,0,'SERVICE PERFORMANCE',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    220,0,0,'Planned Customer Visits',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    230,0,0,'Service Failures',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    240,0,0,'Owner Driver Visits',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    250,@iMonRenNo,0,'SLA Renewals Number',@iYTDRenNo,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    260,@decMonRenVal,0,'SLA Renewals Values ($)',@decYTDRenVal,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    270,@iMonthRenTrans,0,'SLA Transfers/ Assignments',@iYTDRenTrans,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    280,@iMonOutNo,0,'SLA Renewals Outstanding No',@iYTDOutNo,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    290,@decMonOutVal,0,'SLA Renewals Outstanding Value ($)',@decYTDOutVal,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    300,0,0,'Sort Analysis Number Undertaken',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    310,0,0,'Sort Analysis Average S.E.',0,0)
  insert into #tmp_performance_table(detailtype,
    datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud) values('D','SP',
    320,@iMonthConCancelled,0,'SLA Cancelled',@iYTDConCancelled,0)
  select detailtype,datagroup,sortorder,monthact,monthbud,description,ytdact,ytdbud from
    #tmp_performance_table
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure OD_RPS_NegativePay : 
--

CREATE procedure [odps].[OD_RPS_NegativePay](@sdate datetime,@edate datetime)
as
begin
  select payment.contract_no,
    contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_initials,
    Gross_Pay=odps.OD_RPF_PCNegitivePayGetSum(payment.invoice_id,'GP')+odps.OD_RPF_PCNegitivePayGetSum(payment.invoice_id,'OGP'),
    GST=odps.OD_RPF_PCGetSum(payment.invoice_id,'GST')*-1,
    Tax=abs(odps.OD_RPF_PCGetSum(payment.invoice_id,'TAX')),
    Post_Tax_Adjustments=odps.OD_RPF_PCGetSum(payment.invoice_id,'PTD')*-1,
    Net_Pay=(odps.OD_RPF_PCNegitivePayGetSum(payment.invoice_id,'GP')+odps.OD_RPF_PCNegitivePayGetSum(payment.invoice_id,'OGP') ) + (odps.OD_RPF_PCGetSum(payment.invoice_id,'GST')*-1) - abs(odps.OD_RPF_PCGetSum(payment.invoice_id,'TAX')) - (odps.OD_RPF_PCGetSum(payment.invoice_id,'PTD')*-1) from
    rd.contractor,
    payment where
    contractor.contractor_supplier_no = payment.contractor_supplier_no and
    odps.OD_RPF_PCNegitivePayGetSum(payment.invoice_id,'GP')+odps.OD_RPF_PCNegitivePayGetSum(payment.invoice_id,'OGP')
	+odps.OD_RPF_PCGetSum(payment.invoice_id,'GST')*-1
	-abs(odps.OD_RPF_PCGetSum(payment.invoice_id,'TAX'))
	-odps.OD_RPF_PCGetSum(payment.invoice_id,'PTD')*-1 < 0 and
    payment.invoice_date between @sdate and @edate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure OD_RPS_PostTaxAdjustments : 
--

CREATE procedure [odps].[OD_RPS_PostTaxAdjustments](@sdate datetime,@edate datetime)
as
begin
  select distinct payment.contract_no,
    contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_initials,
    (select pbu_code.pbu_code from pbu_code where pbu_code.pbu_id = contract.pbu_id),
    account_codes.ac_code,
    Amount=odps.OD_RPF_PCGetSum(payment.invoice_id,'PTA')*-1 from
    rd.contractor,
    rd.contract left outer join account_codes on contract.ac_id = account_codes.ac_id,
    payment,
    payment_component,
    payment_component_type,
    payment_component_group where
    contractor.contractor_supplier_no = payment.contractor_supplier_no and
    payment.contract_no = contract.contract_no and
    payment.invoice_date between @sdate and @edate and
    payment.invoice_id = payment_component.invoice_id and
    payment_component.pct_id = payment_component_type.pct_id and
    payment_component_TYPE.pcg_id = payment_component_group.pcg_id and
    pcg_short_code like 'PTA%'
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetFuelRates : 
--

CREATE function [rd].[f_GetFuelRates](@in_contractNo int,@inSequenceNo int,@inEffDate datetime)
returns numeric(12,2)
as
begin
  declare @vn_fuelrate numeric(12,2)
  select  @vn_fuelrate=fuel_rates.fr_fuel_rate
    from fuel_type,
    fuel_rates,
    contract_vehical,
    vehicle,
    contract,
    contract_renewals where
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_renewals.contract_no = contract.contract_no and
    contract.rg_code = fuel_rates.rg_code and
    fuel_type.ft_key = fuel_rates.ft_key and
    vehicle.ft_key = fuel_type.ft_key and
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(@in_contractNo,@inSequenceNo) and
    contract_vehical.contract_no = @in_contractNo and
    contract_vehical.contract_seq_number = @inSequenceNo and
    fuel_rates.rr_rates_effective_date = @inEffDate
  return @vn_fuelrate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for user-defined function f_GetFuelRates_whatif : 
--

CREATE function  [rd].[f_GetFuelRates_whatif](@in_contractNo int,@inSequenceNo int,@inEffDate datetime)
-- TJB 4635 - Sept 04
-- Variation on f_getFuelRates for whatif calculation
-- Drops RG_Code from selection condition (see below)
-- See also f_getConsumptionRates_whatif, getContractDelDays_whatif, f_getInsurance_whatif
returns numeric(12,2)
as -- Called from sp_getWhatifCalc2001c
begin
  declare @vn_fuelrate numeric(12,2)
  select @vn_fuelrate=fuel_rates.fr_fuel_rate 
    from fuel_type,
    fuel_rates,
    contract_vehical,
    vehicle,
    contract,
    contract_renewals where
    contract_vehical.contract_no = @in_contractNo and
    contract_vehical.contract_seq_number = @inSequenceNo and
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract.contract_no = contract_renewals.contract_no and
    -- TJB 4635
    -- and contract.rg_code = fuel_rates.rg_code 
    fuel_type.ft_key = fuel_rates.ft_key and
    vehicle.ft_key = fuel_type.ft_key and
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(@in_contractNo,@inSequenceNo) and
    fuel_rates.rr_rates_effective_date = @inEffDate
  return @vn_fuelrate
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetInsurance : 
--

/*07/11/2006 mkwang_msd*/
CREATE function [rd].[f_GetInsurance](@in_contractNo int,@inSequenceNo int,@inEffDate datetime)
returns int
as
begin
  declare @vn_insurance_baserate numeric(12,2),
  @vn_insurance_override numeric(12,2)
  select top 1 @vn_insurance_baserate= isNull(vehicle_override_rate.vor_vehicle_insurance_premium,isNull(non_vehicle_rate.nvr_vehicle_insurance_base_premium,0)+
    isNull(vehicle_rate.vr_vehicle_value_insurance_pct/100,0)*case when isNull(vehicle_override_rate.vor_nominal_vehicle_value,vehicle_rate.vr_nominal_vehicle_value)=vehicle_rate.vr_nominal_vehicle_value then vehicle_rate.vr_nominal_vehicle_value else 0 end )
    from vehicle_type left outer join vehicle_rate on vehicle_type.vt_key = vehicle_rate.vt_key ,                                       
    contract left outer join non_vehicle_rate on  contract.rg_code = non_vehicle_rate.rg_code ,
    contract_renewals left outer join vehicle_override_rate on contract_renewals.contract_no = vehicle_override_rate.contract_no and contract_renewals.contract_seq_number = vehicle_override_rate.contract_seq_number,
    contract_vehical,
    vehicle
    where 
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    vehicle_type.vt_key = vehicle.vt_key and
    contract_renewals.contract_no = contract.contract_no and
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.contract_no = @in_contractNo and
    contract_vehical.contract_seq_number = @inSequenceNo and
    vehicle_rate.vr_rates_effective_date = @inEffDate and
    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(@in_contractNo,@inSequenceNo) and
    non_vehicle_rate.nvr_rates_effective_date = @inEffDate 
     order by
    vehicle_override_rate.vor_effective_date desc
  return @vn_insurance_baserate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetConsumptionRates : 
--

CREATE function [rd].[f_GetConsumptionRates](@in_contractNo int,@inSequenceNo int,@inEffDate datetime)
returns numeric(12,2)
as
begin
  declare @vn_ConsumptionRate numeric(12,2)
  select @vn_ConsumptionRate = fuel_rates.fr_fuel_consumtion_rate
    from fuel_type,
    fuel_rates,
    contract_vehical,
    vehicle,
    contract,
    contract_renewals where
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_renewals.contract_no = contract.contract_no and
    contract.rg_code = fuel_rates.rg_code and
    fuel_type.ft_key = fuel_rates.ft_key and
    vehicle.ft_key = fuel_type.ft_key and
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(@in_contractNo,@inSequenceNo) and
    contract_vehical.contract_no = @in_contractNo and
    contract_vehical.contract_seq_number = @inSequenceNo and
    fuel_rates.rr_rates_effective_date = @inEffDate
  return @vn_ConsumptionRate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetConsumptionRates_whatif : 
--

CREATE function [rd].[f_GetConsumptionRates_whatif](@in_contractNo int,@inSequenceNo int,@inEffDate datetime)
returns numeric(12,2)
-- TJB 4635 - Sept 04
-- Variation on f_getConsumptionRates for whatif calculation
-- Drops RG_Code from selection condition (see below)
-- See also f_getFuelRates_whatif, getContractDelDays_whatif, f_getInsurance_whatif
as -- Called from sp_getWhatifCalc2001c
begin
  declare @vn_ConsumptionRate numeric(12,2)
  select @vn_ConsumptionRate=fuel_rates.fr_fuel_consumtion_rate 
    from fuel_type,
    fuel_rates,
    contract_vehical,
    vehicle,
    contract,
    contract_renewals where
    contract_vehical.contract_no = @in_contractNo and
    contract_vehical.contract_seq_number = @inSequenceNo and
    contract_renewals.contract_no = contract_vehical.contract_no and
    contract_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract.contract_no = contract_renewals.contract_no and
    -- TJB 4635
    -- and fuel_rates.rg_code = contract.rg_code 
    fuel_type.ft_key = fuel_rates.ft_key and
    vehicle.ft_key = fuel_type.ft_key and
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(@in_contractNo,@inSequenceNo) and
    fuel_rates.rr_rates_effective_date = @inEffDate
  return @vn_ConsumptionRate
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[NPAD_get_address](@in_adrID int) as
begin
  select address.adr_id,
    address.tc_id,
    address.road_id,
    road.road_name,
    road.rt_id,
    address.sl_id,
    address.contract_no,
    address.post_code_id,
    post_code=(select post_code from post_code where post_code_id = address.post_code_id),
    address.adr_rd_no,
    address.adr_no,
    address.adr_alpha,
    address.dp_id,
    address.adr_old_delivery_days,
    address.adr_property_identification,
    adr_freq=rd.f_getFrequency(address.adr_id,0,'N'),
    adr_num=(case when address.adr_unit is null then '' else address.adr_unit+'/' end+address.adr_no+address.adr_alpha),
    adr_freq_terminal=rd.f_getFrequency(address.adr_id,address.contract_no,'Y'),
    address.adr_last_amended_date,
    address.adr_last_amended_user,
    address.adr_unit,
    road.rs_id,
    cust.cust_id,
    cust.cust_initials,
    cust.cust_surname_company from
--!    address as adr left outer join road on adr.road_id = road.road_id,
--!    address left outer join customer_address_moves as cam on address.adr_id = cam.adr_id left outer join rds_customer as cust on cam.cust_id = cust.cust_id where
    address left outer join road on address.road_id = road.road_id
	left outer join customer_address_moves as cam on address.adr_id = cam.adr_id left outer join rds_customer as cust on cam.cust_id = cust.cust_id where
    address.adr_id = @in_adrID and
    cam.move_out_date is null and
    cust.master_cust_id is null
end





GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO



--
-- Definition for user-defined function f_GetInsurance_whatif : 
--

CREATE function  [rd].[f_GetInsurance_whatif](@in_contractNo int,@inSequenceNo int,@inEffDate datetime)
-- TJB 4635 - Sept 04
-- Variation on f_getInsurance for whatif calculation
-- Drops RG_Code from selection condition (see below)
-- See also f_getFuelRates_whatif, f_getConsumptionRates_whatif, getContractDelDays_whatif
-- Called from sp_getWhatifCalc2001c
returns int
as -- --> also rewrote where clause to rationalise and improve efficiency
begin
  declare @vn_insurance_baserate numeric(12,2),
  @vn_insurance_override numeric(12,2)
  select top 1 @vn_insurance_baserate=isNull(vor.vor_vehicle_insurance_premium,
    isNull(nvr.nvr_vehicle_insurance_base_premium,0)+
    case when isNull(vor.vor_nominal_vehicle_value,vr.vr_nominal_vehicle_value)=vr.vr_nominal_vehicle_value then vr.vr_nominal_vehicle_value else 0 end*
    isNull(vr.vr_vehicle_value_insurance_pct/100,0))
    from contract_vehical as cv left outer join  vehicle_override_rate as vor on  vor.contract_no = cv.contract_no and vor.contract_seq_number = cv.contract_seq_number,
    vehicle as v,
    vehicle_rate as vr,
    non_vehicle_rate as nvr
    where
    cv.contract_no = @in_contractNo and
    cv.contract_seq_number = @inSequenceNo and
    cv.vehicle_number = rd.f_GetLatestVehicle(@in_contractNo,@inSequenceNo) and
    v.vehicle_number = cv.vehicle_number and
    vr.vr_rates_effective_date = @inEffDate and
    vr.vt_key = v.vt_key and
    nvr.nvr_rates_effective_date = @inEffDate  order by
    vor.vor_effective_date desc
  return @vn_insurance_baserate
end



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_GetCustomerDetails : 
--

--
-- Definition for stored procedure sp_GetCustomerDetails : 
--

CREATE procedure [rd].[sp_GetCustomerDetails]
as
begin
  -- PBY 30/05/2002 SR#4389 Extended f_GetContractNo char size from 60 to 300.
  select distinct rds_customer.cust_id,
    rds_customer.cust_title,
    rds_customer.cust_initials,
    rds_customer.cust_surname_company,
    rds_customer.cust_phone_day,
    rds_customer.cust_phone_night,
    rds_customer.cust_phone_mobile,
    rds_customer.cust_dir_listing_ind,
    rds_customer.cust_dir_listing_text,
    rds_customer.cust_date_commenced,
    rds_customer.cust_adpost_quantity,
    rd.f_GetCustomerAddresses(rds_customer.cust_id),
    rd.f_GetMailCategory(rds_customer.cust_id),
    rd.f_GetDeliveryDays(rds_customer.cust_id),
    rd.f_GetRecipients(rds_customer.cust_id),
    rd.f_GetContractNo(rds_customer.cust_id) from
    rds_customer where
    rds_customer.cust_id = any(select customer_id from report_temp)
end

SET CONCAT_NULL_YIELDS_NULL OFF;










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for user-defined function f_GetDeliveryDays : 
--

CREATE function [rd].[f_GetDeliveryDays_names](@ai_cust_id int)
returns varchar(70)
as
begin
  declare @sret char(7), @stemp1 varchar(70)

  select @sret=rd.f_GetDeliveryDays(@ai_cust_id)
  if @sret='NNNNNNN'
	return ('')

  set @stemp1=''
  if substring(@sret,1,1) = 'Y' 
	 set @stemp1=@stemp1 + ',Monday'
  if substring(@sret,2,1) = 'Y' 
	 set @stemp1=@stemp1 + ',Tuesday'
  if substring(@sret,3,1) = 'Y' 
	 set @stemp1=@stemp1 + ',Wednesday'
  if substring(@sret,4,1) = 'Y' 
	 set @stemp1=@stemp1 + ',Thursday'
  if substring(@sret,5,1) = 'Y' 
	 set @stemp1=@stemp1 + ',Friday'
  if substring(@sret,6,1) = 'Y' 
	 set @stemp1=@stemp1 + ',Saturday'
  if substring(@sret,7,1) = 'Y' 
	 set @stemp1=@stemp1 + ',Sunday'

  if len(@stemp1) >2
     set @stemp1 = substring(@stemp1,2,len(@stemp1)-1)

  return(@stemp1)
end











GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetCustomerDetailsForExport : 
--

--
-- Definition for stored procedure sp_GetCustomerDetailsForExport : 
--

CREATE procedure [rd].[sp_GetCustomerDetailsForExport]
as
begin
  select distinct rds_customer.cust_id,
    rds_customer.cust_title,
    rds_customer.cust_initials,
    rds_customer.cust_surname_company,
    rds_customer.cust_phone_day,
    rds_customer.cust_phone_night,
    rds_customer.cust_phone_mobile,
    rd.f_GetCustomerAddresses(rds_customer.cust_id),
    rd.f_GetMailCategory(rds_customer.cust_id),
    rd.f_GetRecipients(rds_customer.cust_id),
    rd.f_GetContractNo(rds_customer.cust_id) from
    rds_customer where
    rds_customer.cust_id = any(select customer_id from report_temp)
end









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


--
-- Definition for stored procedure sp_ContractSummaryPiecerates : 
--

CREATE procedure [rd].[sp_ContractSummaryPiecerates](@inContract int,@mo int,@yr int)
as
begin
  select piece_rate_supplier.prs_description,
    mo1=(select rd.f_piecerate(@incontract,@mo+1,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key))),
    mo2=(select rd.f_piecerate(@incontract,@mo+2,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key)) ),
    mo3=(select rd.f_piecerate(@incontract,@mo+3,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key)) ),
    mo4=(select rd.f_piecerate(@incontract,@mo+4,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key))),
    mo5=(select rd.f_piecerate(@incontract,@mo+5,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key))),
    mo6=(select rd.f_piecerate(@incontract,@mo+6,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key)) ),
    mo7=(select rd.f_piecerate(@incontract,@mo+7,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key)) ),
    mo8=(select rd.f_piecerate(@incontract,@mo+8,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key))),
    mo9=(select rd.f_piecerate(@incontract,@mo+9,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key)) ),
    mo10=(select rd.f_piecerate(@incontract,@mo+10,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key)) ),
    mo11=(select rd.f_piecerate(@incontract,@mo+11,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key)) ),
    mo12=(select rd.f_piecerate(@incontract,@mo+12,@yr-1,(select prs.prs_key from piece_rate_supplier as prs where prs.prs_key = piece_rate_supplier.prs_key)) ) from
    piece_rate_supplier
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetRCMStatReport : 
--

CREATE procedure [rd].[sp_GetRCMStatReport](
@inRegion int,
@inOutlet int,
@inRenGroup int,
@inContractType int)
-- TJB  SR4684  June-2006
-- Reformatted for legibility
-- Moved 'Delete from RCM...' and commit to beginning
as --    so commit didn''t happen in the middle.
begin
SET IMPLICIT_TRANSACTIONS On

  declare @sRegion char(40)
  declare @AVol int
  declare @CVol int
  declare @ACost numeric(12,2)
  declare @CCost numeric(12,2)
  declare @test1 int
  declare @test2 int
  delete from rcm_stat_report -- Collects report data
  delete from RCMStatPR1 -- Collects KiwiMail report data
  delete from RCMStatPR2 -- Collects CourierPost report data
  commit transaction
  insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Number of Runs',
      rd.RDRunsRegionV2(region_id,@inOutlet,@inRenGroup,@inContractType),
      10,
      1,'N','NORDRUN' from
      region where
      (region_id = @inRegion or @inRegion = 0)
  insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Number of Runs',
      rd.RDRunsRegionV2(0,0,@inRenGroup,@inContractType),
      10,
      2,'N','NORDRUN'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Number of Owner Drivers',
      rd.OwnDrvRegionV2(region_id,@inOutlet,@inRenGroup,@inContractType),
      20,
      1,'N','NOOWNDRV' from
      region where
      (region_id = @inRegion or @inRegion = 0)
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Number of Owner Drivers',
      rd.OwnDrvRegionV2(0,0,@inRenGroup,@inContractType),
      20,
      2,'N','NOOWNDRV'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Number of Customers',
      rd.CustsRegionV2(region_id,@inOutlet,@inRenGroup,@inContractType),
      30,
      1,'N','NOCUSTS' from
      region where
      (region_id = @inRegion or @inRegion = 0)
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Number of Customers',
      rd.CustsRegionV2(0,0,@inRenGroup,@inContractType),
      30,
      2,'N','NOCUSTS'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Total Articles Delivered',
      rd.AnnualVolume(region_id,@inOutlet,@inRenGroup,@inContractType),
      40,
      1,'N','NOARTDEL' from
      region where
      (region_id = @inRegion or @inRegion = 0)
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Total Articles Delivered',
      rd.AnnualVolume(0,0,@inRenGroup,@inContractType),
      40,
      2,'N','NOARTDEL'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Total NZP Payments($)',
      rd.CoreCOntract(region_id,@inOutlet,@inRenGroup,@inContractType),
      50,
      1,'N','NONZP' from
      region where
      (region_id = @inRegion or @inRegion = 0)
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Total NZP Payments($)',
      rd.CoreCOntract(0,0,@inRenGroup,@inContractType),
      50,
      2,'N','NONZP'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Total Daily Distance',
      rd.DayDistRegionV2(region_id,@inOutlet,@inRenGroup,@inContractType),
      60,
      1,'N','DAYDIST' from
      region where
      (region_id = @inRegion or @inRegion = 0)
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Total Daily Distance',
      rd.DayDistRegionV2(0,0,@inRenGroup,@inContractType),
      60,
      2,'N','DAYDIST'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Ave. Boxes per Run',
      (case when  tab2.sumamount > 0 then tab1.sumamount/tab2.sumamount else 0 end),
      70,
      tab1.column_order,'N','AVEBOXRUN' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'NOCUSTS' and
      tab2.variablename = 'NORDRUN'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Ave. Articles per Run',
      (case when tab2.sumamount > 0 then tab1.sumamount/tab2.sumamount else 0 end),
      80,
      tab1.column_order,'N','AVEARTRUN' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'NOARTDEL' and
      tab2.variablename = 'NORDRUN'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Ave. Articles per Box',
      (case when tab2.sumamount > 0 then tab1.sumamount/tab2.sumamount else 0 end),
      90,
      tab1.column_order,'N','AVEARTBOX' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'NOARTDEL' and
      tab2.variablename = 'NOCUSTS'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Ave. Distance per Run',
      (case when tab2.sumamount > 0 then tab1.sumamount/tab2.sumamount else 0 end),
      100,
      tab1.column_order,'N','AVEKMRUN' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'DAYDIST' and
      tab2.variablename = 'NORDRUN'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Ave. Density (Boxes/ KM)',
      (case when tab2.sumamount > 0 then tab1.sumamount/tab2.sumamount else 0 end),
      110,
      tab1.column_order,'Y','CUSTDENSE' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'NOCUSTS' and
      tab2.variablename = 'DAYDIST'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Annual Distance',
      rd.AnnualDistance(region_id,@inOutlet,@inRenGroup,@inContractType),
      210,
      1,'Y','COREDIST' from
      region where
      (region_id = @inRegion or @inRegion = 0)
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Annual Distance',
      rd.AnnualDistance(0,0,@inRenGroup,@inContractType),
      210,
      1,'Y','COREDIST'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Total Allowances per Year($)',
      rd.NZPAllowance(region_id,@inOutlet,@inRenGroup,@inContractType),
      55,
      1,'N','ALLOW' from
      region where
      (region_id = @inRegion or @inRegion = 0)
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Total Allowances per Year($)',
      rd.NZPAllowance(0,0,@inRenGroup,@inContractType),
      55,
      2,'N','ALLOW'
  /*
  *  SR#4392 PBY 22/05/2002 Commented out Unit Cost related rows
  *
  *   insert into rcm_stat_report
  *      (region,description,sumamount,sort_order,column_order,showdecimals,variablename)
  *  select tab1.region,
  *         'Unit Cost($)',
  *         (if tab2.sumamount>0 then tab1.sumamount/tab2.sumamount else 0 endif),
  *         210,
  *         1,
  *         'Y',
  *         'UNITCOST'
  *    from rcm_stat_report as tab1
  *       , rcm_stat_report as tab2
  *   where tab1.region=tab2.region
  *     and tab1.variablename='NONZP'
  *     and tab2.variablename='NOARTDEL'
  *     and tab1.region<>'National';
  *
  *  insert into rcm_stat_report
  *      (region,description,sumamount,sort_order,column_order,showdecimals,variablename)
  *  select 'National',
  *         'Unit Cost($)',
  *         (if tab2.sumamount > 0 then tab1.sumamount/tab2.sumamount else 0 endif),
  *         210,
  *         2,
  *         'Y',
  *         'UNITCOST'
  *    from rcm_stat_report as tab1,
  *         rcm_stat_report as tab2 
  *   where tab1.region = 'National' 
  *     and tab2.region = 'National' 
  *     and tab1.variablename = 'NONZP' 
  *     and tab2.variablename = 'NOARTDEL';
  */

insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Cost per Customer($)',
      (case when tab2.sumamount > 0 then tab1.sumamount/tab2.sumamount else 0 end),
      220,
      1,'Y','COSTCUST' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'NONZP' and
      tab2.variablename = 'NOCUSTS' and
      tab1.region <> 'National'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Cost per Customer($)',
      (case when tab2.sumamount > 0 then tab1.sumamount/tab2.sumamount else 0 end),
      220,
      2,'Y','COSTCUST' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = 'National' and
      tab2.region = 'National' and
      tab1.variablename = 'NONZP' and
      tab2.variablename = 'NOCUSTS'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Cost per Km($)',
      (case when tab2.sumamount > 0 then tab1.sumamount/tab2.sumamount else 0 end),
      220,
      1,'Y','COSTKM' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'NONZP' and
      tab2.variablename = 'COREDIST' and
      tab1.region <> 'National'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Cost per Km($)',
      (case when tab2.sumamount > 0 then tab1.sumamount/tab2.sumamount else 0 end),
      220,
      2,'Y','COSTKM' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = 'National' and
      tab2.region = 'National' and
      tab1.variablename = 'NONZP' and
      tab2.variablename = 'COREDIST'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Inward Mail',
      rd.PickupVolumes(region_id,@inOutlet,@inRenGroup,@inContractType),
      45,
      1,'n','PICKUP' from
      region where
      (region_id = @inRegion or @inRegion = 0)
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Inward Mail',
      rd.PickupVolumes(0,0,@inRenGroup,@inContractType),
      45,
      2,'N','PICKUP'
  ----------------------------------------------------------------------------------------------      
  execute rd.EstAdPost @inRegion,@inOutlet,@inRenGroup,@inContractType
  execute rd.EstCourPost @inRegion,@inOutlet,@inRenGroup,@inContractType
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Est. Courier Post Volumes',
      CourpostVol,
      120,
      1,'N','ESTCPV' from
      region,
      RCMStatPR2 where
      RCMStatPR2.region_id = region.region_id
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Est. Courier Post Expenditures',
      CourpostCost,
      130,
      1,'Y','ESTCPE' from
      region,
      RCMStatPR2 where
      RCMStatPR2.region_id = region.region_id
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Est. Kiwimail Volumes',
      AdpostVol,
      140,
      1,'N','ESTAPV' from
      region,
      RCMStatPR1 where
      RCMStatPR1.region_id = region.region_id
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Est. Kiwimail Expenditures',
      AdpostCost,
      150,
      1,'Y','ESTAPE' from
      region,
      RCMStatPR1 where
      RCMStatPR1.region_id = region.region_id
  ------------------------------------------------------------------------------------  
  if @inRegion = 0 and @inOutlet = 0
    begin
      execute @test1=rd.EstCourPostAll 1,@inRegion,@inRenGroup,@inContractType
        
      execute @test2=rd.EstAdPostAll 1,@inRegion,@inRenGroup,@inContractType
        
    end
  else
    begin
      execute @test1=rd.EstCourPostAll 0,@inRegion,@inRenGroup,@inContractType
        
      execute @test2=rd.EstAdPostAll 0,@inRegion,@inRenGroup,@inContractType 
       
    end
  select @ACost=AdpostCost,@AVol=AdpostVol from RCMStatPR1 where region_id = 0
  select @CCost=CourpostCost,@CVol=CourpostVol from RCMStatPR2 where region_id = 0
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Est. Courier Post Volumes',
      @CVol,
      120,
      2,'N','ESTCPV'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Est. Courier Post Expenditures',
      @CCost,
      130,
      2,'Y','ESTCPE'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Est. Kiwimail Volumes',
      @AVol,
      140,
      2,'N','ESTAPV' 
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Est. Kiwimail Expenditures',
      @ACost,
      150,
      2,'Y','ESTAPE'
  ------------------------------------------------------------------------------------------
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Ave. Courier Post Articles per Run',
      (case when isnull(tab2.sumamount,0) > 0 then isnull(tab1.sumamount,0)/tab2.sumamount else 0 end),    --
      160,
      tab1.column_order,'N','AVECPRUN' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'ESTCPV' and
      tab2.variablename = 'NORDRUN'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Ave. Courier Post Articles per Box',
      (case when isnull(tab2.sumamount,0) > 0 then isnull(tab1.sumamount,0)/tab2.sumamount else 0 end),		--
      170,
      tab1.column_order,'N','AVECPRUN' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'ESTCPV' and
      tab2.variablename = 'NOCUSTS'
  --------------------------------------------------------------------------------------------           
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Ave. Kiwimail Articles per Run',
      (case when isnull(tab2.sumamount,0) > 0 then isnull(tab1.sumamount,0)/tab2.sumamount else 0 end),  --
      180,
      tab1.column_order,'N','AVECPRUN' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'ESTAPV' and
      tab2.variablename = 'NORDRUN'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select tab1.region,'Ave. Kiwimail Articles per Box',
      (case when isnull(tab2.sumamount,0) > 0 then isnull(tab1.sumamount,0)/tab2.sumamount else 0 end),		--
      190,
      tab1.column_order,'N','AVECPRUN' from
      rcm_stat_report as tab1,
      rcm_stat_report as tab2 where
      tab1.region = tab2.region and
      tab1.variablename = 'ESTAPV' and
      tab2.variablename = 'NOCUSTS'
  --------------------------------------------------------------------------------------------------------
  -- working area TWC : 
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Geocoded Delivery Points %',
      rd.RDGeoPercent(0,0,@inRenGroup,@inContractType),
      250,
      2,'N','PERGEO' 
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Geocoded Delivery Points %',
      rd.RDGeoPercent(region_id,@inOutlet,@inRenGroup,@inContractType),
      250,
      1,'N','PERGEO' from
      region where
      (region_id = @inRegion or @inRegion = 0)
  --------------------------------------------------------------------------------------------------------------------------------------------------------   
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Drivers with Cell Phones %',
      rd.ownerwithcellPercent(0,0,@inRenGroup,@inContractType),
      260,
      2,'N','PERCELL'
--select convert(char, getdate(),9)+ 'w'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Drivers with Cell Phones %',
      rd.ownerwithcellPercent(region_id,@inOutlet,@inRenGroup,@inContractType),
      260,
      1,'N','PERCELL' from
      region where
      (region_id = @inRegion or @inRegion = 0)
--select convert(char, getdate(),9)+ 'w1'
  --------------------------------------------------------------------------------------------------------------------------------------------------------   
declare @exppercent1 real
execute @exppercent1 = rd.v_expPercent 0,0,@inRenGroup,@inContractType
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Vehicles meeting replacement %',
      @exppercent1,
      270,
      2,'Y','PEREXP' 
--select convert(char, getdate(),9)+ 'w2'
/*
  insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Vehicles meeting replacement %',
      rd.v_expPercent(region_id,@inOutlet,@inRenGroup,@inContractType),
      270,
      1,'Y','PEREXP' from
      region where
      (region_id = @inRegion or @inRegion = 0)
*/
-- temp table for setting column value by a procedure
create table #region_temp(
    region_id int not null,
    rgn_name varchar(40) null,
    expPercent real
    ) 
declare @l_region_id int
begin transaction
delete  #region_temp
insert #region_temp(region_id,rgn_name) 
select region_id,rgn_name from rd.region 
	where region_id = @inRegion or @inRegion = 0
declare c_region_temp  cursor for select region_id from #region_temp
open c_region_temp
while 1=1 
    begin
      fetch next from c_region_temp into @l_region_id
		if @@error <>0
        begin
          rollback transaction
          return(-1)
        end
		if @@FETCH_STATUS < 0
		  break
		execute @exppercent1 = rd.v_expPercent @l_region_id,@inOutlet,@inRenGroup,@inContractType
		update #region_temp set expPercent = @exppercent1 where region_id=@l_region_id
	end
--select convert(char, getdate(),9)+ 'w3'
insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Vehicles meeting replacement %',
      expPercent,
      270,
      1,'Y','PEREXP' from
      #region_temp
commit transaction

--select cast(getdate() as char)+ 'x'
  --------------------------------------------------------------------------------------------------------------------------------------------------------      
  insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Vehicles meeting Specs / livery %',
      0,
      280,
      2,'N','PERSPEC'
  insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Vehicles meeting Specs / livery %',
      0,
      280,
      1,'N','PERSPEC' from
      region where
      (region_id = @inRegion or @inRegion = 0)
  --------------------------------------------------------------------------------------------------------------------------------------------------------            
  insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','Privacy Opt out %',
      rd.privacyPercent(0,0,@inRenGroup,@inContractType),
      290,
      2,'Y','PERPRIV' 
  insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'Privacy Opt out %',
      rd.privacyPercent(region_id,@inOutlet,@inRenGroup,@inContractType),
      290,
      1,'Y','PERPRIV' from
      region where
      (region_id = @inRegion or @inRegion = 0)
  --------------------------------------------------------------------------------------------------------------------------------------------------------               
  insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select 'National','No Road Number %',
      rd.noroadnumPercent(0,0,@inRenGroup,@inContractType),
      300,
      2,'Y','PERNRN'
--select cast(getdate() as char)+ 'y'
  insert into rcm_stat_report(region,
    description,sumamount,sort_order,column_order,showdecimals,variablename)
    select rgn_name,'No Road Number %',
      rd.noroadnumPercent(region_id,@inOutlet,@inRenGroup,@inContractType),
      300,
      1,'Y','PERNRN' from
      region where
      (region_id = @inRegion or @inRegion = 0)
--select cast(getdate() as char)+ 'z'
  -----------------------------------------------------------------------------------------------------------------------
  commit transaction
SET IMPLICIT_TRANSACTIONS OFF
  select region,
    description,
    sumamount,
    sort_order,
    column_order,
    showdecimals from
    rcm_stat_report where
   left(description,3) <> 'Est' and
   left(variablename,3) <> 'COR'
--commit transaction

end


















GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure  [rd].[sp_GetWhatIfCalc2005](@inContract int,@inSequence int,@inRGCode int,@inEffectDate datetime,@inVolumeSource varchar(60))
-- TJB SR4661 - May 2005    - Significant changes
-- Change delivery and processing calc
-- - Base on 52 weeks (change from 56)
-- - Split rates into two separate rates
-- - Add "Relief" calculation (4 weeks)
-- Split nWageHourlyRate into nDeliveryWageRate and nProcessingWageRate
-- also split returned vrr_wage_hourly_rate into vrr_del_wage_rate vrr_proc_wage_rate
--
-- v2: return only non-null values.
-- TJB SR4635 - Sept 2004
-- Removed (commented out) all use of RG Code in selection criteria.
-- It was used, along with the effective date, to select rates and values from some tables.
-- When used in some Whatif scenarios, the two wouldn''t match, nothing would be found, and
-- the calculations would be incorrect. 
-- See also f_getFuelRates_whatif
--          f_getConsumptionRates_whatif
--          f_getInsurance_whatif
--          getContractDelDays_whatif
-- TJB  SR4684 bug fix  Aug 2006
-- Removed large_parcels from volume calculations
--	nWageHourlyRate 	numeric(10,2),          -- TJB SR4661
-- TJB SR4661
--	vrr_wage_hourly_rate 		numeric(10,2),      -- TJB SR4661
-- TJB SR4661
-- Added TJB SR4661
-- TJB SR4661
as -- TJB SR4661
begin
  declare @nNominalVehical numeric(10,2)
  declare @nRemainingEconomicLife integer
  --  declare nWageHourlyRate 		numeric(10,2);              -- TJB SR4661
  declare @nDeliveryWageRate numeric(10,2) -- TJB SR4661
  declare @nProcessingWageRate numeric(10,2) -- TJB SR4661
  declare @nRepairsMaint numeric(10,2)
  declare @nTyreTubes numeric(10,2)
  declare @nVehicalAllow numeric(10,2)
  declare @nVehicalInsure numeric(10,2)
  declare @nPublicLia numeric(10,2)
  declare @nCarrierRisk numeric(10,2)
  declare @nACCRate numeric(10,2)
  --new 2001
  declare @nInsurancePct numeric(10,2)
  declare @nACCAmount numeric(10,2)
  declare @nLivery numeric(10,2)
  declare @nUniform numeric(10,2)
  declare @nLiveryPerAnnum numeric(12,2)
  declare @nUniformPerAnnum numeric(12,2)
  declare @nMaxDays integer
  --end new
  declare @nLicence numeric(10,2)
  declare @nRateOfReturn numeric(10,2)
  declare @nSalvageRatio numeric(10,2)
  declare @nItemsHour numeric(10,2)
  declare @nFuel numeric(10,2)
  declare @nConsumption numeric(10,2)
  declare @dStartDate datetime
  declare @dEndDate datetime
  declare @sConTitle char(60)
  declare @iNumberCusts integer
  declare @sRDFile char(40)
  declare @sRCMFile char(40)
  declare @nCurrentPayment numeric(10,2)
  declare @nExtensions numeric(10,2)
  declare @nNumRows integer
  declare @nRouteDistance numeric(10,2)
  declare @nDeliveryHours numeric(10,2)
  declare @nProcessingHours numeric(10,2)
  declare @nVolume numeric(10,2)
  declare @nDeliveryDays numeric(10,2)
  declare @nMaxDeliveryDays numeric(10,2)
  declare @nRouteDistancePerDay real
  declare @nVehicleDepreciation real
  declare @nFuelCostPerAnnum real
  declare @nRepairsPerAnnum real
  declare @nTyresTubesPerAnnum real
  declare @nDeliveryCost real
  declare @nProcessingCost real
  declare @nReliefCost real -- Added:  TJB SR4661
  declare @nReliefWeeks int   -- Added:  TJB SR4703
  declare @nPublicLiabilityCost real
  declare @nACCPerAnnum real
  declare @nBenchmark real
  declare @nVehicleInsurance real
  declare @nLicensing real
  declare @nCarrierRiskRate real
  declare @nRateOfReturnCost real
  declare @nFinalBenchmark real
  declare @nRetainedAllowances numeric(10,2)
  declare @nSFKey integer
  declare @nRFDistance numeric(10,2)
  declare @cDeliveryDays char(7)
  declare @nVolume2 numeric(10,2)
  declare @nVolume1avg numeric(10,2)
  declare @nVolume2avg numeric(10,2)
  declare @nSumAdjustments numeric(10,2)
  declare @nTempint integer
  declare @nRUC numeric(8,2)
  declare @nRUCRate numeric(8,2)
  declare @nAccounting numeric(8,2)
  declare @nTelephone numeric(8,2)
  declare @nSundries numeric(8,2)
  declare @nSundriesK numeric(8,2)
  declare @nSundriesKTot numeric(8,2)
  declare @nMultiplier integer
  declare @vrr_nominal_vehical_value numeric(10,2)
  --  declare vrr_wage_hourly_rate 		numeric(10,2);          -- TJB SR4661
  declare @vrr_del_wage_rate numeric(10,2) -- TJB SR4661
  declare @vrr_proc_wage_rate numeric(10,2) -- TJB SR4661
  declare @vrr_repairs_maintenance_rate numeric(10,2)
  declare @vrr_tyre_tubes_rate numeric(10,2)
  declare @vrr_vehical_allowance_rate numeric(10,2)
  declare @vrr_vehical_insurance_premium numeric(10,2)
  declare @vrr_public_liability_rate numeric(10,2)
  declare @vrr_carrier_risk_rate numeric(10,2)
  declare @vrr_acc_rate numeric(10,2)
  declare @vrr_licence_rate numeric(10,2)
  declare @vrr_vehical_rate_of_return_pct numeric(10,2)
  declare @vrr_salvage_ratio numeric(10,2)
  declare @vrr_item_proc_rate_per_hr numeric(10,2)
  declare @vrr_frozen_indicator numeric(10,2)
  declare @vrr_contract_start numeric(10,2)
  declare @vrr_contract_end numeric(10,2)
  declare @vrr_ruc numeric(10,2)
  declare @vrr_accounting numeric(10,2)
  declare @vrr_telephone numeric(10,2)
  declare @vrr_sundries numeric(10,2)
  declare @vrr_sundriesK numeric(10,2)
  declare @nVtKey integer
  --volumes at renewal- ok!
  select @nVolume2=contract_renewals.con_volume_at_renewal 
    from contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  --Count letters according to source - ok!
  -- TJB  SR4684 bug fix  Aug 2006
  -- Removed large_parcels from volume calculations
  --  select (artical_count.ac_w1_medium_letters
  --          + artical_count.ac_w1_other_envelopes
  --          + artical_count.ac_w1_small_parcels
  --          + artical_count.ac_w1_large_parcels
  --          + artical_count.ac_w2_medium_letters
  --          + artical_count.ac_w2_other_envelopes
  --          + artical_count.ac_w2_small_parcels
  --          + artical_count.ac_w2_large_parcels
  --         )*artical_count.ac_scale_factor
  select @nVolume1avg=(artical_count.ac_w1_medium_letters+
    artical_count.ac_w1_other_envelopes+
    artical_count.ac_w1_small_parcels+
    artical_count.ac_w2_medium_letters+
    artical_count.ac_w2_other_envelopes+
    artical_count.ac_w2_small_parcels)*
    artical_count.ac_scale_factor 
    from artical_count where
    artical_count.ac_start_week_period = 
    (select max(artical_count.ac_start_week_period) from
      artical_count where
      artical_count.contract_no = @inContract) and
    artical_count.contract_no = @inContract and
    (@inVolumeSource = 'last_article_count' or
    @inVolumeSource = 'average_article_count') and
    artical_count.ac_scale_factor is not null
  /*if @@error <> 0 /* <> was < */
     Watcom only
    resignal
    */
  --Count article counts according to source - ok!
  -- TJB  SR4684 bug fix  Aug 2006
  -- Removed large_parcels from volume calculations
  --  select (artical_count.ac_w1_medium_letters
  --          + artical_count.ac_w1_other_envelopes
  --          + artical_count.ac_w1_small_parcels
  --          + artical_count.ac_w1_large_parcels
  --          + artical_count.ac_w2_medium_letters
  --          + artical_count.ac_w2_other_envelopes
  --          + artical_count.ac_w2_small_parcels
  --          + artical_count.ac_w2_large_parcels
  --         )*artical_count.ac_scale_factor
  select @nVolume2avg=(artical_count.ac_w1_medium_letters+
    artical_count.ac_w1_other_envelopes+
    artical_count.ac_w1_small_parcels+
    artical_count.ac_w2_medium_letters+
    artical_count.ac_w2_other_envelopes+
    artical_count.ac_w2_small_parcels)*
    artical_count.ac_scale_factor 
    from artical_count where
    artical_count.ac_start_week_period = 
    (select max(artical_count.ac_start_week_period) from
      artical_count where
      artical_count.contract_no = @inContract and
      artical_count.ac_start_week_period <> 
      (select max(artical_count.ac_start_week_period) from
        artical_count where
        artical_count.contract_no = @inContract)) and
    artical_count.contract_no = @inContract and
    (@inVolumeSource = 'last_but_one_article_count' or
    @inVolumeSource = 'average_article_count') and
    artical_count.ac_scale_factor is not null
  /*if @@error <> 0 /* <> was < */
     Watcom only
    resignal
    */
  select @nVolume2= @nVolume2avg  
    where @inVolumeSource = 'last_but_one_article_count' and
    @nVolume2avg is not null
  select @nVolume2=@nVolume1avg  
    where @inVolumeSource = 'last_article_count' and
    @nVolume1avg is not null
  select @nVolume2=(@nVolume1avg+@nVolume2avg)/2  
    where @inVolumeSource = 'average_article_count' and
    @nVolume2avg > 0 and
    @nVolume1avg is not null
  select @nVolume2=@nVolume1avg  
    where @inVolumeSource = 'average_article_count' and
    (@nVolume2avg = 0 or @nVolume2avg is null)
  --Get rates and their overrides  
  select top 1
    @nNominalVehical=isNull(vor.vor_nominal_vehicle_value,vr.vr_nominal_vehicle_value),
    @nRemainingEconomicLife=v.v_remaining_economic_life,
    -- isNull(nvor.nvor_wage_hourly_rate,nvr.nvr_wage_hourly_rate) as wage_rate,                  -- TJB SR4661
    @nDeliveryWageRate=isNull(nvor.nvor_delivery_wage_rate,nvr.nvr_delivery_wage_rate), -- TJB SR4661
    @nProcessingWageRate=isNull(nvor.nvor_processing_wage_rate,nvr.nvr_processing_wage_rate), -- TJB SR4661
    @nRepairsMaint=isNull(vor.vor_repairs_maintenance_rate,vr.vr_repairs_maintenance_rate),
    @nTyreTubes=isNull(vor.vor_tyre_tubes_rate,vr.vr_tyre_tubes_rate),
    @nVehicalAllow=isNull(vor.vor_vehical_allowance_rate,vr.vr_vehicle_allowance_rate),
    -- TJB SR4635
    -- f_GetInsurance(inContract,inSequence,inEffectDate) as insurance, //ins $
    @nVehicalInsure=rd.f_GetInsurance_whatif(@inContract,@inSequence,@inEffectDate), --ins $
    @nPublicLia=isNull(nvor.nvor_public_liability_rate_2,nvr.nvr_public_liability_rate),
    @nCarrierRisk=isNull(nvor.nvor_carrier_risk_rate,nvr.nvr_carrier_risk_rate),
    @nACCRate=isNull(nvor.nvor_acc_rate,nvr.nvr_acc_rate),
    @nACCAmount=isNull(nvor.nvor_acc_rate_amount,nvr.nvr_acc_rate_amount),
    @nLicence=isNull(vor.vor_licence_rate,vr.vr_licence_rate),
    @nRateOfReturn=isNull(vor.vor_vehicle_rate_of_return_pct,vr.vr_vehicle_rate_of_return_pct),
    @nSalvageRatio=isNull(vor.vor_salvage_ratio,vr.vr_salvage_ratio),
    @nItemsHour=isNull(nvor.nvor_item_proc_rate_per_hour,nvr.nvr_item_proc_rate_per_hr),
    -- TJB SR4635
    -- isNull(vor.vor_fuel_rate,f_GetFuelRates(inContract,inSequence,inEffectDate)) as fuel,
    @nFuel=isNull(vor.vor_fuel_rate,rd.f_GetFuelRates_whatif(@inContract,@inSequence,@inEffectDate)),
    -- TJB SR4635
    -- isNull(vor_consumption_rate,f_GetConsumptionRates(inContract,inSequence,inEffectDate)) as consumption,
    @nConsumption=isNull(vor_consumption_rate,rd.f_GetConsumptionRates_whatif(@inContract,@inSequence,@inEffectDate)),
    @nAccounting=isNull(nvor.nvor_accounting,nvr.nvr_accounting),
    @nTelephone=isNull(nvor.nvor_telephone,nvr.nvr_telephone),
    @nSundries=isNull(nvor.nvor_sundries,nvr.nvr_sundries),
    @nRucrate=isNull(vor.vor_ruc,vr.vr_ruc),
    @nSundriesK=isNull(vor.vor_sundries_k,vr.vr_sundries_k),
    @nInsurancePct=isNull(vr.vr_vehicle_value_insurance_pct,0),
    @nLivery=isNull(vor.vor_livery,vr.vr_livery),
    @nUniform=isNull(nvor_uniform,nvr_uniform),
    @nVtKey=v.vt_key 
	from
	 	contract_renewals as cr 
    left outer join non_vehicle_override_rate as nvor on cr.contract_no = nvor.contract_no and cr.contract_seq_number = nvor.contract_seq_number
    left outer join vehicle_override_rate as vor on  cr.contract_no = vor.contract_no and cr.contract_seq_number = vor.contract_seq_number, 
    contract_vehical as cv,
    vehicle as v,
    contract as c,
    non_vehicle_rate as nvr,
    vehicle_type as vt left outer join vehicle_rate as vr on vt.vt_key = vr.vt_key
where
    cv.contract_no = cr.contract_no and
    cv.contract_seq_number = cr.contract_seq_number and
    v.vehicle_number = cv.vehicle_number and
    vt.vt_key = v.vt_key and
    c.contract_no = cr.contract_no and
    v.vehicle_number = rd.f_GetLatestVehicle(@inContract,@inSequence) and
    --and c.rg_code=nvr.rg_code
    -- TJB SR4635
    -- nvr.rg_code = inRGCode and
    cr.contract_no = @inContract and
    cr.contract_seq_number = @inSequence and
    nvr.nvr_rates_effective_date = @inEffectDate and
    vr.vr_rates_effective_date = @inEffectDate
order by
    vor.vor_effective_date desc
  select @nNominalVehical=isnull(@nNominalVehical,0)
  select @nRemainingEconomicLife=isnull(@nRemainingEconomicLife,0)
  select @nDeliveryWageRate=isnull(@nDeliveryWageRate,0)
  select @nProcessingWageRate=isnull(@nProcessingWageRate,0)
  select @nRepairsMaint=isnull(@nRepairsMaint,0)
  select @nTyreTubes=isnull(@nTyreTubes,0)
  select @nVehicalAllow=isnull(@nVehicalAllow,0)
  select @nVehicalInsure=isnull(@nVehicalInsure,0)
  select @nPublicLia=isnull(@nPublicLia,0)
  select @nCarrierRisk=isnull(@nCarrierRisk,0)
  select @nACCRate=isnull(@nACCRate,0)
  select @nACCAmount=isnull(@nACCAmount,0)
  select @nLicence=isnull(@nLicence,0)
  select @nRateOfReturn=isnull(@nRateOfReturn,0)
  select @nSalvageRatio=isnull(@nSalvageRatio,0)
  select @nItemsHour=isnull(@nItemsHour,0)
  select @nFuel=isnull(@nFuel,0)
  select @nConsumption=isnull(@nConsumption,0)
  select @nAccounting=isnull(@nAccounting,0)
  select @nTelephone=isnull(@nTelephone,0)
  select @nSundries=isnull(@nSundries,0)
  select @nRucrate=isnull(@nRucrate,0)
  select @nSundriesK=isnull(@nSundriesK,0)
  select @nInsurancePct=isnull(@nInsurancePct,0)
  select @nLivery=isnull(@nLivery,0)
  select @nUniform=isnull(@nUniform,0)
  -- Select contract renewal start date
  select @dStartDate=con_start_date 
    from contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence

  --Get end date
  select @dEndDate=con_start_date 
    from contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence+1

        -- Added TJB  SR4703  Sep 2007
  if @inEffectDate >= '2007 Oct 31'
    set @nReliefWeeks = 5
  else
    set @nReliefWeeks = 4

  --Get other FD rates depending on source
  if @inVolumeSource = 'last_but_one_article_count' or @inVolumeSource = 'last_article_count' or @inVolumeSource = 'average_article_count'
    select @nNumRows=count(*),
      -- TJB SR4635 - GecContractDelDays changed to ignore inRGCode
      -- GetContractDelDays(contract_renewals.contract_no,contract_renewals.contract_seq_number,inRGcode,inEffectDate),
      @nDeliveryDays=rd.GetContractDelDays_whatif(contract_renewals.contract_no,@inRGcode,@inEffectDate),
      -- contract_renewals.con_distance_at_renewal+sum(ifnull(frequency_distances.fd_distance,0,frequency_distances.fd_distance)*rate_days.rtd_days_per_annum),
      @nRouteDistance=rd.getcontractdistance(@inContract,@inSequence),
      @nDeliveryHours=contract_renewals.con_del_hrs_week_at_renewal+
      sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
      @nProcessingHours=contract_renewals.con_processing_hours_per_week+
      sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
      @nVolume=@nVolume2,
      @iNumberCusts=isnull(contract_renewals.con_no_customers_at_renewal,0)+
      isnull(contract_renewals.con_no_cmb_custs_at_renewal,0)+
      sum(isnull(frequency_distances.fd_no_of_boxes,0))+
      sum(isnull(frequency_distances.fd_no_cmb_customers,0)) 
       from
      contract_renewals INNER JOIN route_frequency on contract_renewals.contract_no = route_frequency.contract_no
      INNER JOIN frequency_distances on
      route_frequency.contract_no = frequency_distances.contract_no and
      route_frequency.sf_key = frequency_distances.sf_key and
      route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days and
      frequency_distances.fd_effective_date >= @dStartDate and
      @dStartDate is not null and
      (@dEndDate is null or @dEndDate >= frequency_distances.fd_effective_date)
      INNER JOIN rate_days ON route_frequency.sf_key = rate_days.sf_key
	  where
      (contract_renewals.contract_no = route_frequency.contract_no) and
      (route_frequency.sf_key = rate_days.sf_key) and
      (rate_days.rr_rates_effective_date = @inEffectDate) and
      -- TJB SR4635
      -- (rate_days.rg_code = inRgCode) and
      (contract_renewals.contract_no = @inContract) and
      (contract_renewals.contract_seq_number = @inSequence)
      group by contract_renewals.contract_no,
      contract_renewals.contract_seq_number,
      contract_renewals.con_rg_code_at_renewal,
      contract_renewals.con_rates_effective_date,
      contract_renewals.con_distance_at_renewal,
      contract_renewals.con_del_hrs_week_at_renewal,
      contract_renewals.con_processing_hours_per_week,
      contract_renewals.con_volume_at_renewal,
      contract_renewals.con_no_customers_at_renewal,
      contract_renewals.con_no_cmb_custs_at_renewal
  else
    select @nNumRows=count(*),
      -- TJB SR4635
      -- GetContractDelDays(contract_renewals.contract_no,contract_renewals.contract_seq_number,inRGcode,inEffectDate),
      @nDeliveryDays=rd.GetContractDelDays_whatif(contract_renewals.contract_no,@inRGcode,@inEffectDate),
      @nRouteDistance=contract_renewals.con_distance_at_renewal+
      sum(isnull(frequency_distances.fd_distance,0)*
      rate_days.rtd_days_per_annum),
      @nDeliveryHours=contract_renewals.con_del_hrs_week_at_renewal+
      sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
      @nProcessingHours=contract_renewals.con_processing_hours_per_week+
      sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
      @nVolume=@nVolume2+sum(isnull(frequency_distances.fd_volume,0)),
      @iNumberCusts=isnull(contract_renewals.con_no_customers_at_renewal,0)+
      isnull(contract_renewals.con_no_cmb_custs_at_renewal,0)+
      sum(isnull(frequency_distances.fd_no_of_boxes,0))+
      sum(isnull(frequency_distances.fd_no_cmb_customers,0)) 
from
      contract_renewals,
      route_frequency left outer join frequency_distances on
      route_frequency.contract_no = frequency_distances.contract_no and
      route_frequency.sf_key = frequency_distances.sf_key and
      route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days and
      frequency_distances.fd_effective_date >= @dStartDate and
      @dStartDate is not null and
      (@dEndDate is null or
      @dEndDate >= frequency_distances.fd_effective_date),
      rate_days where
      (contract_renewals.contract_no = route_frequency.contract_no) and
      (route_frequency.sf_key = rate_days.sf_key) and
      (rate_days.rr_rates_effective_date = @inEffectDate) and
      -- TJB SR4635
      -- (rate_days.rg_code = inRgCode) and
      (contract_renewals.contract_no = @inContract) and
      (contract_renewals.contract_seq_number = @inSequence)
      group by contract_renewals.contract_no,
      contract_renewals.contract_seq_number,
      contract_renewals.con_rg_code_at_renewal,
      contract_renewals.con_rates_effective_date,
      contract_renewals.con_distance_at_renewal,
      contract_renewals.con_del_hrs_week_at_renewal,
      contract_renewals.con_processing_hours_per_week,
      contract_renewals.con_volume_at_renewal,
      contract_renewals.con_no_customers_at_renewal,
      contract_renewals.con_no_cmb_custs_at_renewal
  select @nNumRows=isnull(@nNumRows,0)
  select @nDeliveryDays=isnull(@nDeliveryDays,0)
  select @nRouteDistance=isnull(@nRouteDistance,0)
  select @nDeliveryHours=isnull(@nDeliveryHours,0)
  select @nProcessingHours=isnull(@nProcessingHours,0)
  select @nVolume=isnull(@nVolume,0)
  select @iNumberCusts=isnull(@iNumberCusts,0)
  --get contract adjustments
  select @nCurrentPayment=(contract_renewals.con_renewal_payment_value),
    @nExtensions=(select sum(contract_adjustments.ca_amount) from
      contract_adjustments where
      contract_renewals.contract_no = contract_adjustments.contract_no and
      contract_renewals.contract_seq_number = contract_adjustments.contract_seq_number and
      contract_adjustments.ca_date_paid is not null)
     from contract_renewals where
    contract_no = @inContract and
    contract_seq_number = @inSequence
  --Get frequency adjsutments  
  select @nSumAdjustments=sum(fd_amount_to_pay) 
    from frequency_adjustments where
    contract_no = @inContract and
    contract_seq_number = @inSequence and
    fd_paid_to_date is not null
  select @nCurrentPayment=isnull(@nCurrentPayment,0)
  select @nExtensions=isnull(@nExtensions,0)
  select @nSumAdjustments=isnull(@nSumAdjustments,0)
  --Calculate current payment    
  --  set nCurrentPayment=nCurrentPayment+ifnull(nSumAdjustments,0,nSumAdjustments);
  select @nCurrentPayment=@nCurrentPayment+@nSumAdjustments
  --Get max delivery days
  select @nMaxDeliveryDays=max(rate_days.rtd_days_per_annum) 
    from rate_days where
    rate_days.rr_rates_effective_date = @inEffectDate
  -- TJB SR4635
  -- and rate_days.rg_code = inRgCode;
  --If max days per week>4, assume deldays = maxdeldays
  select @nMaxdays=sum(standard_frequency.sf_days_week) 
    from rate_days,
    standard_frequency,
    route_frequency where
    standard_frequency.sf_key = rate_days.sf_key and
    route_frequency.sf_key = standard_frequency.sf_key and
    -- TJB SR4635
    -- rate_days.rg_code = inRgCode and
    rate_days.rr_rates_effective_date = @inEffectDate and
    route_frequency.contract_no = @inContract and
    route_frequency.rf_active = 'Y'
  select @nMaxDeliveryDays=isnull(@nMaxDeliveryDays,0)
  select @nMaxDays=isnull(@nMaxDays,0)
  if @nMaxdays > 4
    select @nDeliveryDays=@nMaxDeliveryDays
  --Calculate certain ratios
if(@nDeliveryDays <> 0)
BEGIN
  select @nRouteDistancePerDay=@nRouteDistance/@nDeliveryDays
END
  --Depreciation
  -- PBY 26/06/2002 SR#4415 Added nRouteDistance/1000 to VehicleDepreciation
  -- calcuation if REL > 0  
--  if @nRemainingEconomicLife > 0
--    select VehicleDepreciation
--      =(@nRouteDistance/1000)*
--      ((1-(isNull(@nSalvageRatio,0)/100))*isNull(@nNominalVehical,0)*1000)/
--      @nRemainingEconomicLife
  if @nRemainingEconomicLife <= 0 --else
    select @nVehicleDepreciation=@nRouteDistance*(@nVehicalAllow/1000)
  select @nFuelCostPerAnnum=(@nConsumption/100)*@nRouteDistance*(@nFuel/100)
  select @nRepairsPerAnnum=@nRepairsMaint*(@nRouteDistance/1000)
  select @nTyresTubesPerAnnum=@nTyreTubes*(@nRouteDistance/1000)
  -- select nSundriesK*(nRouteDistance/1000) into nSundriesKTot;
  select @nSundriesKTot=@nSundriesK*(@nRouteDistance/1000)
  -- TJB SR4661: Changed nWageHourlyRate to nDeliveryWageRate and nProcessingWageRate
  select @nDeliveryCost=((round(@nDeliveryHours,2))*52)*@nDeliveryWageRate
if(@nItemsHour<>0)
BEGIN
  select @nProcessingCost=((((@nVolume/@nItemsHour)/365)*7)*52)*@nProcessingWageRate
  select @nReliefCost=((round(@nDeliveryHours,2))*@nReliefWeeks)*@nDeliveryWageRate+ -- Added: TJB  SR4661
    ((((@nVolume/@nItemsHour)/365)*7)*@nReliefWeeks)*@nProcessingWageRate
END

IF(@nMaxDeliveryDays<>0)
BEGIN
  select @nPublicLiabilityCost=@nPublicLia*(@nDeliveryDays/@nMaxDeliveryDays)
END
  select @nACCPerAnnum=(@nAccRate/100)*(@nDeliveryCost+@nProcessingCost+@nReliefCost)+ -- Changed: TJB SR4661
    @nACCAmount -- TJB SR4661: bug fix: accAmount wasn''t included
  --Benchmark 2001
IF(@nMaxDeliveryDays<>0)
BEGIN
  select @nVehicleInsurance=@nVehicalInsure*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nLicensing=@nLicence*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nCarrierRiskRate=@nCarrierRisk*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nRateofReturnCost=rd.GetRateReturn(@nNominalVehical,@nRateOfReturn,@nSalvageRatio)*
    (@nDeliveryDays/@nMaxDeliveryDays)
print(@nNominalVehical)
print(@nRateOfReturn)
print(@nSalvageRatio)
print(@nDeliveryDays)
print(@nMaxDeliveryDays)
END
  select @nLiveryPerAnnum=@nLivery*(@nRouteDistance/1000)
  select @nUniformPerAnnum=@nUniform*(@nRouteDistance/1000)
  --Find out if the vehicle is diesel
  select @nTempint=count(contractor_renewals.contract_no) 
    from rd.contractor_renewals,
    rd.contract_vehical,
    rd.vehicle,
    rd.fuel_type where
    (contractor_renewals.contract_no = @inContract) and
    (contractor_renewals.contract_seq_number = @inSequence) and
    (contractor_renewals.contract_no = contract_vehical.contract_no) and
    (contractor_renewals.contract_seq_number = contract_vehical.contract_seq_number) and
    (contract_vehical.vehicle_number = vehicle.vehicle_number) and
    (vehicle.ft_key = fuel_type.ft_key) and
    (fuel_type.ft_description like 'diesel%') and
    (vehicle.vehicle_number = rd.f_GetLatestVehicle(@inContract,@inSequence))
   /*if @@error <> 0 /* <> was < */
    Watcom only
    resignal
    */
  if @ntempint = 0
    begin
      select @nRUC=0.0
      select @nMultiplier=0
    end
  else
    begin
      select @nMultiplier=1
      select @nRUC=@nRUCRate*(@nRouteDistance/1000)
    end
  --Calculate the benchmark
  select @nVehicleDepreciation=isnull(@nVehicleDepreciation,0)
  select @nFuelCostPerAnnum=isnull(@nFuelCostPerAnnum,0)
  select @nRepairsPerAnnum=isnull(@nRepairsPerAnnum,0)
  select @nTyresTubesPerAnnum=isnull(@nTyresTubesPerAnnum,0)
  select @nDeliveryCost=isnull(@nDeliveryCost,0)
  select @nProcessingCost=isnull(@nProcessingCost,0)
  select @nReliefCost=isnull(@nReliefCost,0)
  select @nPublicLiabilityCost=isnull(@nPublicLiabilityCost,0)
  select @nACCPerAnnum=isnull(@nACCPerAnnum,0)
  select @nVehicleInsurance=isnull(@nVehicleInsurance,0)
  select @nLicensing=isnull(@nLicensing,0)
  select @nCarrierRiskRate=isnull(@nCarrierRiskRate,0)
  select @nAccounting=isnull(@nAccounting,0)
  select @nTelephone=isnull(@nTelephone,0)
  select @nSundries=isnull(@nSundries,0)
  select @nRUC=isnull(@nRUC,0)
  select @nSundriesKTot=isnull(@nSundriesKTot,0)
  select @nLiveryPerAnnum=isnull(@nLiveryPerAnnum,0)
  select @nRateOfReturnCost=isnull(@nRateOfReturnCost,0)
  select @nBenchmark
    =@nVehicleDepreciation+
    @nFuelCostPerAnnum+
    @nRepairsPerAnnum+
    @nTyresTubesPerAnnum+
    @nDeliveryCost+
    @nProcessingCost+
    @nReliefCost+ -- Added: TJB  SR4661
    @nPublicLiabilityCost+
    @nACCPerAnnum+
    @nVehicleInsurance+
    @nLicensing+
    @nCarrierRiskRate+
    @nAccounting+
    @nTelephone+
    @nSundries+
    @nRUC+
    @nSundriesKTot+
    @nLiveryPerAnnum+
    @nUniformPerAnnum
  --Final; BM
  --  set nFinalBenchmark = nBenchmark + nRateOfReturnCost;
  select @nFinalBenchmark=Round(@nBenchmark+@nRateOfReturnCost,1)
  --Get contract title
  select @sConTitle=con_title,
    @sRDFile=con_rd_paper_file_text,
    @sRCMFile=con_rcm_paper_file_text 
     from contract where
    contract_no = @inContract
  --get standard rates 
  select @vrr_nominal_vehical_value=vehicle_rate.vr_nominal_vehicle_value,
    -- non_vehicle_rate.nvr_wage_hourly_rate,       -- TJB SR4661
    @vrr_del_wage_rate=non_vehicle_rate.nvr_delivery_wage_rate, -- TJB SR4661
    @vrr_proc_wage_rate=non_vehicle_rate.nvr_processing_wage_rate, -- TJB SR4661
    @vrr_repairs_maintenance_rate=vehicle_rate.vr_repairs_maintenance_rate,
    @vrr_tyre_tubes_rate=vehicle_rate.vr_tyre_tubes_rate,
    @vrr_vehical_allowance_rate=vehicle_rate.vr_vehicle_allowance_rate,
    @vrr_vehical_insurance_premium=non_vehicle_rate.nvr_vehicle_insurance_base_premium,
    -- vehicle_rate.vr_vehicle_value_insurance_pct,   
    @vrr_public_liability_rate=non_vehicle_rate.nvr_public_liability_rate,
    @vrr_carrier_risk_rate=non_vehicle_rate.nvr_carrier_risk_rate,
    @vrr_acc_rate=non_vehicle_rate.nvr_acc_rate,
    @vrr_licence_rate=vehicle_rate.vr_licence_rate,
    @vrr_vehical_rate_of_return_pct=vehicle_rate.vr_vehicle_rate_of_return_pct,
    @vrr_salvage_ratio=vehicle_rate.vr_salvage_ratio,
    @vrr_item_proc_rate_per_hr=non_vehicle_rate.nvr_item_proc_rate_per_hr,
    @vrr_ruc=vehicle_rate.vr_ruc,
    @vrr_accounting=non_vehicle_rate.nvr_accounting,
    @vrr_telephone=non_vehicle_rate.nvr_telephone,
    @vrr_sundries=non_vehicle_rate.nvr_sundries,
    @vrr_sundriesK=vehicle_rate.vr_sundries_k 
 from
    [contract],
    non_vehicle_rate,
    --vehicle_type,
    --vehicle_rate,
    contract_renewals,
    contract_vehical,
    vehicle ,
vehicle_type left outer join vehicle_rate on
	vehicle_type.vt_key = vehicle_rate.vt_key 

where
    -- TJB SR4635
    -- contract.rg_code *= non_vehicle_rate.rg_code and
   
    contract_renewals.contract_no = contract.contract_no and
    contract_vehical.contract_no = contract_renewals.contract_no and
    contract_vehical.contract_seq_number = contract_renewals.contract_seq_number and
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    vehicle_type.vt_key = vehicle.vt_key and
    non_vehicle_rate.nvr_rates_effective_date = @inEffectDate and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence and
    vehicle.vehicle_number = rd.f_GetLatestVehicle(@inContract,@inSequence) and
    vehicle_rate.vr_rates_effective_date = @inEffectDate
  --return the values  
  --insert into t_benchmark(renewalgroup,nominalvehiclevalue) values('what-if',nRepairsPerAnnum);
  select @inContract as inContract,
    @inSequence as inSequence,
    @sConTitle as sConTitle,
    @nNominalVehical,
    -- nWageHourlyRate,           -- TJB SR4661
    @nDeliveryWageRate, -- TJB SR4661
    @nRepairsMaint,
    @nTyreTubes,
    @nVehicalAllow,
    @nVehicalInsure,
    @nPublicLia,
    @nCarrierRisk,
    @nACCRate,
    @nLicence,
    @nRateOfReturn,
    @nSalvageRatio,
    @nItemsHour,
    @nFuel,
    @nConsumption,
    @nRouteDistance,
    @nDeliveryHours,
    @nProcessingHours,
    @nVolume,
    @nDeliveryDays,
    @nMaxDeliveryDays,
    @iNumberCusts,
    @nRouteDistancePerDay,
    @nVehicleDepreciation,
    @nFuelCostPerAnnum,
    @nRepairsPerAnnum,
    @nTyresTubesPerAnnum,
    @nDeliveryCost,
    @nProcessingCost,
    @nPublicLiabilityCost,
    @nACCPerAnnum,
    @nVehicleInsurance,
    @nLicensing,
    @nCarrierRiskRate,
    @nBenchmark,
    @nRateOfReturnCost,
    @nFinalBenchmark,
    @nRetainedAllowances,
    @nCurrentPayment,
    @nSFKey,
    @nRFDistance,
    @cDeliveryDays,
    nDaysYear=0,
    nDaysWeek=0,
    itemspercust=0,
	'Y' as rf_active,
	'',
    0.0,
    @nAccounting,
    @nTelephone,
    @nSundries,
    @nRUCRate,
    @vrr_nominal_vehical_value,
    -- vrr_wage_hourly_rate,           -- TJB SR4661
    @vrr_del_wage_rate, -- TJB SR4661
    @vrr_repairs_maintenance_rate,
    @vrr_tyre_tubes_rate,
    @vrr_vehical_allowance_rate,
    @vrr_vehical_insurance_premium,
    @vrr_public_liability_rate,
    @vrr_carrier_risk_rate,
    @vrr_acc_rate,
    @vrr_licence_rate,
    @vrr_vehical_rate_of_return_pct,
    @vrr_salvage_ratio,
    @vrr_item_proc_rate_per_hr,
    @vrr_ruc,
    @vrr_accounting,
    @vrr_telephone,
    @vrr_sundries,
    @vrr_sundriesK,
    @nSundriesK,
    @nMultiplier,
    @nInsurancePct,
    @nLivery,
    @nUniform,
    @nACCAmount,
    @nVtKey,
    @nReliefCost, -- Added TJB SR4596
    @nProcessingWageRate, -- TJB SR4661
    @vrr_proc_wage_rate,
    @nReliefWeeks  -- TJB SR4703
end

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO





CREATE procedure [odps].[OD_BLF_Mainrun_Grosspay](@incontract_no int,@inSequence_no int,@inContractor_no int,@inContractorStart datetime,@inContractorEnd datetime,@inPayPeriod_Start datetime,@inPayPeriod_End datetime,@run_id int,@inRenewalStart datetime,@inRenewalEnd datetime,@v_contractor_contract_start datetime)
--..............................................................--
--Author: Rex Bustria                                           --
--Function: Computes the gross pay                              --
--Note:                                                         --
--Problems: How to compute if both renewals need to be used     --
--..............................................................--
--
-- TJB  SR4684  June 2006
-- TJB  February 2007
-- Fix bug with payroll calculation.  See notes related to v_multiplier_old.
-- Added comments to section determining multipliers and other places

as -- Add handling for Parcel Post 
begin
  set implicit_transactions on
  --Declare heaps of things here
  declare @v_Multiplier numeric(15,10), --.prorate factor for current renewal
  @v_Multiplier2 numeric(15,10), --.prorate factor for the previous renewal
  @v_PeriodDiff numeric(12,2), --.days between period start and period end
  @v_Payment_Value numeric(12,2), --.contract payment value
  @v_Payment_Value_old numeric(12,2), --.contract payment value for old renewal
  @v_Frequency_Adjustments numeric(12,2), --.as it says
  @v_Contract_Adjustments numeric(12,2), --.as it says
  @v_Contract_Allowance numeric(12,2), --.as it says
  @v_Grosspay numeric(12,2), --.as it says
  @v_ParcelPost numeric(12,2), --.parcel post amount
  @v_CourierPost numeric(12,2), --.courier post amount
  @v_AdPost numeric(12,2), --.adpost amount
  @v_XP numeric(12,2), --.adpost amount
  @v_PiecerateStartDate datetime, --.courier/adpost start date (beg. of the month instead of pay period start)
  @v_PiecerateEndDate datetime, --.courier/adpost end date (end of the month instead of pay period end)
  @v_PieceRate numeric(12,2), --.courierpost + adpost
  @v_InvoiceNumber int, --.invoice number(generated)
  @v_Tax_Rate numeric(12,2), --.the applicable tax rate
  @v_NextContractorStart datetime, --.as it says
  @v_PreviousContractorStart datetime, --.as it says
  @v_UseOldRenewalValueOnly char(1), --.as it says
  @v_UseBothRenewals char(1), --.as it says
  @v_Case int, --.prorate case advisor
  @v_RenewalAndPayStartDiff int,
  @v_temp_dec numeric(12,2),
  @v_pcfaker int,
  @v_multiplier_old numeric(15,10) -- Multiplier to use for previous contract in Frequency Adjustment
  -- calculation (see note in that section) - TJB  Feb-2007
  --
  --**********************Set initial value********************--
  select @v_UseOldRenewalValueOnly='N'
  select @v_UseBothRenewals='N'
  select @v_Grosspay=0
  select @v_perioddiff=datediff(day,@inPayPeriod_Start,@inPayPeriod_End)+1.0
  --
  -- See Paycomp max PK
  --  select "count"(*) into v_pcfaker from odps.t_payment_component;
  if @v_pcfaker is null
    select @v_pcfaker=0
  --
  --*****************Check the dates passed********************--
--
  if @inContractorStart is null or @inContractorEnd is null
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000100)
    end
  --******************GET CONTRACTOR TAX RATE*******************--
  select @v_Tax_Rate = odps.od_blf_getTaxRate(@inContractor_no,@inContractorEnd) 
  --
  if @v_Tax_Rate < 0 or @@ERROR < 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000120)
    end
  --******************GET INVOICE NUMBER***********************--
  select @v_InvoiceNumber = max(invoice_id)+1 
    from t_payment
  if @@ERROR < 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000130)
    end
  if @v_InvoiceNumber is null
    select @v_InvoiceNumber=1
  --
  --
  --**************DETERMINE RENEWAL(s) TO USE***************--   
  -- (for prorating annualised amounts)
  --
  -- PBY 07-08-2002 SR#4443 Set the initial value
  set @v_Multiplier2=0;
  
--Determine if we should use the old renewal ONLY
  --
  --
  if(@inRenewalStart is null) or
    ((@inRenewalStart between @inPayPeriod_Start and @inPayPeriod_End) and
    (@inContractorEnd < @inRenewalStart)) or
    (@inRenewalStart > @inContractorEnd)
    select @v_UseOldRenewalValueOnly='Y' --.Pay using the previous renewal rates
  --Determine if we should use BOTH the old and new renewals here!
  if(@inRenewalStart is not null) and
    (@inRenewalStart between @inPayPeriod_Start and @inPayPeriod_End) and
    (@inContractorStart < @inRenewalStart) and
    (@inContractorEnd is null or @inContractorEnd > @inRenewalStart)
    select @v_UseBothRenewals='Y' --.Pay using the previous and the current renewal rates
  --
  --
  --Determine Multipliers (for prorating annualised amounts)
  --
  --
  if @inRenewalStart <= @inPayPeriod_Start
    begin
      select @v_Case=1
      if @inContractorStart <= @inPayPeriod_Start
        begin
          select @v_Case=2
          if @inContractorEnd is null or @inContractorEnd >= @inPayPeriod_End
            begin
              select @v_Case=3
              if @inRenewalEnd >= @inPayPeriod_End or @inRenewalEnd is null
                begin
                  select @v_Case=4
                  select @v_Multiplier=1
                end
              else  -- inRenewalEnd < inPayPeriod_End
                begin
                  select @v_Case=5
                  select @v_Multiplier=(datediff(day,@inPayPeriod_Start,@inRenewalEnd)+1)/@v_Perioddiff
                end
            end
          else  -- inRenewalEnd < inPayPeriod_End
            begin
              select @v_Case=6
              if @inRenewalEnd >= @inPayPeriod_End or @inRenewalEnd is null
                begin
                  select @v_Case=61
                  --Transfer pair with case 82
                  select @v_Multiplier=(datediff(day,@inPayPeriod_Start,@inContractorEnd)+1)/@v_Perioddiff
                  select @v_Multiplier2=0
                end
              else
                if @inRenewalEnd <= @inContractorEnd
                  select @v_Multiplier=(datediff(day,@inPayPeriod_Start,@inRenewalEnd)+1)/@v_Perioddiff
                else
                  select @v_Multiplier=(datediff(day,@inPayPeriod_Start,@inContractorEnd)+1)/@v_Perioddiff
            end
        end
      else   -- inContractorStart > inPayPeriod_Start
        begin
          select @v_Case=7
          if @inContractorEnd is null or @inContractorEnd >= @inPayPeriod_End
            begin
              select @v_Case=8
              if @inRenewalEnd <= @inPayPeriod_End
                begin
                  select @v_Case=81
                  select @v_Multiplier=(datediff(day,@inContractorStart,@inRenewalEnd)+1)/@v_Perioddiff
                end
              else  -- inRenewalEnd > inPayPeriod_End
                begin
                  select @v_Case=82
                  --Transfer pair with case 61
                  select @v_Multiplier=(datediff(day,@inContractorStart,@inPayPeriod_End)+1)/@v_Perioddiff
                end
            end
          else  -- inContractorEnd < inPayPeriod_End
            begin
              select @v_Case=9
              if @inRenewalEnd <= @inPayPeriod_End
                begin
                  select @v_Case=811
                  select @v_Multiplier=(datediff(day,@inContractorStart,@inRenewalEnd)+1)/@v_Perioddiff
                end
              else -- inRenewalEnd > inPayPeriod_End
                begin
                  select @v_Case=91
                  select @v_Multiplier=(datediff(day,@inContractorStart,@inContractorEnd)+1)/@v_Perioddiff
                end
            end
        end
    end
  else   -- inRenewalStart > inPayPeriod_Start
    begin
      select @v_Case=10
      if @inContractorStart <= @inPayPeriod_Start
        begin
          select @v_Case=11
          if @inContractorEnd is null or @inContractorEnd >= @inPayPeriod_End
            begin
              select @v_Case=12
              if @inRenewalEnd is null or @inRenewalEnd >= @inPayPeriod_End
                begin
                  select @v_Case=121
                  select @v_Multiplier=(datediff(day,@inRenewalStart,@inPayPeriod_End)+1)/@v_Perioddiff
                  select @v_Multiplier2=(@v_Perioddiff-(datediff(day,@inRenewalStart,@inPayPeriod_End)+1))/@v_Perioddiff
                end
              else  -- inRenewalEnd < inPayPeriod_End
                begin
                  select @v_Case=122
                  select @v_Multiplier=(datediff(day,@inRenewalStart,@inRenewalEnd)+1)/@v_Perioddiff
                end
            end
          else -- inContractorEnd < inPayPeriod_End
            begin
              select @v_Case=13
              if @inRenewalEnd is null or @inRenewalEnd >= @inContractorEnd
                begin
                  --Transfer pair with case 162
                  select @v_Case=131
                  -- 
                  select @v_Multiplier=(datediff(day,@inPayPeriod_Start,@inContractorEnd)+1)/@v_Perioddiff
                  select @v_Multiplier2=0
                end
              else   -- inRenewalEnd < inContractorEnd
                begin
                  select @v_Case=132
                  select @v_Multiplier=(datediff(day,@inRenewalStart,@inRenewalEnd)+1)/@v_Perioddiff
                end
            end
        end
      else
        begin
          select @v_Case=14
          if @inContractorStart <= @inRenewalStart
            begin
              select @v_Case=15
              if @inContractorEnd is null or @inContractorEnd >= @inPayPeriod_End
                begin
                  select @v_Case=16
                  if @inRenewalEnd is null or @inRenewalEnd <= @inPayPeriod_End
                    begin
                      select @v_Case=161
                      --Transfer pair with case 131
                      select @v_Multiplier=(datediff(day,@inRenewalStart,@inPayPeriod_End)+1)/@v_Perioddiff
                    end
                  else  -- inRenewalEnd > inPayPeriod_End
                    begin
                      select @v_Case=162
                      select @v_Multiplier=(datediff(day,@inContractorStart,@inContractorEnd)+1)/@v_Perioddiff
                    end
                end
              else  -- inContractorEnd < inPayPeriod_End
                begin
                  select @v_Case=17
                  if @inRenewalEnd is null or @inRenewalEnd <= @inPayPeriod_End
                    begin
                      select @v_Case=171
                      select @v_Multiplier=(datediff(day,@inContractorStart,@inPayPeriod_End)+1)/@v_Perioddiff
                    end
                  else  -- inRenewalEnd > inPayPeriod_End
                    begin
                      select @v_Case=172
                      --Changed from v_Multiplier=(days(inContractorStart,inRenewalEnd)+1)/v_Perioddiff to
                      --13/08/1999
                      select @v_Multiplier=(datediff(day,@inContractorStart,@inContractorEnd)+1)/@v_Perioddiff
                    end
                end
            end
          else -- inContractorStart > inRenewalStart
            begin
              select @v_Case=18
              if @inContractorEnd is null or @inContractorEnd >= @inPayPeriod_End
                begin
                  select @v_Case=19
                  if @inRenewalEnd is null or @inRenewalEnd <= @inPayPeriod_End
                    begin
                      select @v_Case=191
                      select @v_Multiplier=(datediff(day,@inContractorStart,@inPayPeriod_End)+1)/@v_Perioddiff
                    end
                  else  -- inRenewalEnd > inPayPeriod_End
                    begin
                      select @v_Case=192
                      --Changed from v_Multiplier=(days(inContractorStart,inRenewalEnd)+1)/v_Perioddiff to
                      --13/08/1999
                      select @v_Multiplier=(datediff(day,@inContractorStart,@inContractorEnd)+1)/@v_Perioddiff
                    end
                end
              else   -- inContractorEnd < inPayPeriod_End
                begin
                  select @v_Case=20
                  if @inRenewalEnd is null or @inRenewalEnd >= @inContractorEnd
                    begin
                      select @v_Case=201
                      select @v_Multiplier=(datediff(day,@inContractorStart,@inContractorEnd)+1)/@v_Perioddiff
                    end
                  else  -- inRenewalEnd < inContractorEnd
                    begin
                      select @v_Case=202
                      select @v_Multiplier=(datediff(day,@inContractorStart,@inRenewalEnd)+1)/@v_Perioddiff
                    end
                end
            end
        end
    end
  --
  --
  if @v_Multiplier <= 0 or @v_Multiplier is null
    begin
      select @v_Case=@v_Case*-1
      select @v_Multiplier=0
    end
  --.Do not pay
  --*****************CREATE A PAYMENT RECORD*****************--
  insert into t_payment(contractor_supplier_no,
    contract_no,
    contract_seq_number,
    /*invoice_id, */  --Cannot insert explicit value for identity column
    pr_id, 
    invoice_date,
    witholding_tax_rate_applied,
    case_no) values(
    @inContractor_no,
    @inContract_No,
    @inSequence_no,
    /*@v_invoicenumber,*/
    @run_id,
    @inPayPeriod_End,
    @v_Tax_Rate,
    @v_Case)
  if @@ERROR <> 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000140)
    end
  --**************CONTRACT PAYMENT VALUE******************--
  --
  if @v_UseOldRenewalValueOnly = 'N'
    begin
      --use current
      select @v_Payment_value = sum((contract_renewals.con_renewal_payment_value*@v_multiplier)/12.0)  
        from rd.contract_renewals where
        (contract_renewals.contract_no = @incontract_no) and
        (contract_renewals.contract_seq_number = @inSequence_no)
      if @v_UseBothRenewals = 'Y' --also use previous
        select @v_Payment_value_old = sum((contract_renewals.con_renewal_payment_value*@v_multiplier2)/12.0) 
          from rd.contract_renewals where
          (contract_renewals.contract_no = @incontract_no) and
          (contract_renewals.contract_seq_number = @inSequence_no-1)
    end
  else
    --use previous only
    select @v_Payment_value = sum((contract_renewals.con_renewal_payment_value*@v_multiplier)/12.0)
      from rd.contract_renewals where
      (contract_renewals.contract_no = @incontract_no) and
      (contract_renewals.contract_seq_number = @inSequence_no-1)
  if @@ERROR < 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000165)
    end
  if @v_Payment_value is null
    select @v_Payment_value=0
  if @v_Payment_value_old is null
    select @v_Payment_value_old=0
  select @v_Payment_value=@v_Payment_value+@v_Payment_value_old
  --**************FREQUENCY ADJUSTMENTS*******************--
  -- this is  an annualised amount                        --
  -- all 'fd_adjustment_amount' was replaced with 'fd_amount_to_pay'
  -- ie. Benchmark increase has been replaced with amount payable
  -- refer to observation id - 12 
  -- Changed by Jayas on 19/12/97 
  --
  if @v_UseOldRenewalValueOnly = 'N'
    begin
      select @v_pcfaker = count(*) from odps.t_payment_component
      insert into odps.t_payment_component                                 --#1
(/*pc_id,*/ pct_id,invoice_id,pc_amount,comments,misc_date,misc_string)
		select /*checksum(*)+@v_pcfaker,*/
			/*!isnull(pct_id,(select nat_freqadj_defaultcomptype from "national" where nat_id = (select odps.od_blf_getwhichnational(@inContractorEnd) ))),
			@v_InvoiceNumber,
			(sum(isnull(fd_amount_to_pay,0))*  */
         isnull(pct_id,(select nat_freqadj_defaultcomptype from odps."national" where nat_id = (select odps.OD_BLF_getwhichnational(@inContractorEnd)))),
        @v_InvoiceNumber,
        -- TJB 15-July-2004 SR4625: New calculation
        -- If there''s an adjustment during the pay period and there is also a change in contractor, 
        -- prorate the amount between them according to the portion of the period it applies to each.
        -- Otherwise the adjustment applies to the whole period and the previously-calculated 
        -- scaling factor can be used.
        -- Note: A contractor will be selected only if his/her end date is within the pay period.
        --       The adjustment date may then either be before the contractor starts, or after 
        --       he/she starts and before he/she ends (though the test for the end is redundant).
        -- (Also changed the prorata displayed value in the comment field)
        (sum(isnull(fd_amount_to_pay,0))*
				(case when fd_effective_date between @inPayPeriod_Start and @inPayPeriod_End then
					case when fd_effective_date between @inContractorStart and @inContractorEnd then
						(datediff(day,fd_effective_date,@inContractorEnd)+1)/@v_perioddiff
					else
						(datediff(day,@inContractorStart,@inContractorEnd)+1)/@v_perioddiff
					end
				else
					@v_multiplier
				end))/12.0,
			(case when fd_effective_date between @inPayPeriod_Start and @inPayPeriod_End then 'Arrears:' else '' end)+
				'Freq Adjust:For the period, current renewal'+', Effective: '+ 
				convert(varchar,fd_effective_date)+', Annual amount: '+ 
				convert(varchar,isnull(fd_amount_to_pay,0))+', Prorata: '+
				convert(varchar,case when fd_effective_date between @inPayPeriod_Start and @inPayPeriod_End then
									case when fd_effective_date between @inContractorStart and @inContractorEnd then
										(datediff(day,fd_effective_date,@inContractorEnd)+1)/@v_perioddiff
									else
										(datediff(day,@inContractorStart,@inContractorEnd)+1)/@v_perioddiff
									end
								else
									@v_multiplier
								end),
			fd_effective_date,
			ext=(select top 1  fd.fd_change_reason from rd.frequency_distances as fd where
					fd.fd_effective_date = rd.frequency_adjustments.fd_effective_date and
					fd.contract_no = rd.frequency_adjustments.contract_no) 
		from rd.frequency_adjustments 
		where (contract_no = @inContract_no) and
			(contract_seq_number = @inSequence_no) and
			(fd_confirmed = 'Y') and
			(fd_effective_date <= @inContractorEnd) 
            and ((select nat_freqadj_defaultcomptype from odps."national" where
          nat_id = (select odps.OD_BLF_getwhichnational(@inContractorEnd)))is not null)--add
		group by pct_id,fd_effective_date,fd_amount_to_pay,CONTRACT_NO,contract_seq_number,fd_confirmed,fd_unique_seq_number,fd_adjustment_amount,fd_paid_to_date,fd_bm_after_extn,sf_key,rf_delivery_days         

--group by pct_id,fd_effective_date,fd_amount_to_pay,fd_effective_date,fd_effective_date,CONTRACT_NO
        if @@ERROR <> 0
        begin
          rollback transaction
          set implicit_transactions off
          return(-100000170)
        end
      select @v_pcfaker = count(*) from odps.t_payment_component
      insert into odps.t_payment_component(/*pc_id,*/                            --#2
        pct_id,
        invoice_id,
        pc_amount,
        comments,
        misc_date,
        misc_string)
        select /*checksum(*)+@v_pcfaker,*/
            isnull(pct_id,(select nat_freqadj_defaultcomptype from odps."national" where
            nat_id = (select odps.od_blf_getwhichnational(@inContractorEnd) ))),
          @v_InvoiceNumber,
          (sum(isnull(fd_amount_to_pay,0))*datediff(day,fd_effective_date,@inContractorStart))/365.0,'Arrears:Frequency Adjustment, current renewal'+', Effective:'+
          convert(varchar,fd_effective_date)+', Days overdue:'+
          convert(varchar,datediff(day,fd_effective_date,@inContractorStart))+', Annual amount: '+
          convert(varchar,isnull(fd_amount_to_pay,0)),
          fd_effective_date,'Extension Arrears' from
          rd.frequency_adjustments where
          (contract_no = @inContract_no) and
          (contract_seq_number = @inSequence_no) and
          (fd_paid_to_date is null) and
          (fd_confirmed = 'Y') and
          (fd_effective_date >= @v_contractor_contract_start) and
          (fd_effective_date < @inContractorStart) and
          (fd_effective_date <= @inContractorEnd) and -- TJB  Dec 2005 SR4677
          (fd_effective_date < @inPayPeriod_Start)
          group by pct_id,fd_effective_date,fd_amount_to_pay,contract_no,contract_seq_number,fd_unique_seq_number,fd_adjustment_amount,fd_paid_to_date,fd_bm_after_extn,fd_confirmed,sf_key,rf_delivery_days
--!           group by pct_id,fd_effective_date,fd_amount_to_pay,fd_effective_date
        if @@ERROR <> 0
        begin
          rollback transaction
          return(-100000171)
        end
    end

  if @v_UseOldRenewalValueOnly = 'Y' or @v_UseBothRenewals = 'Y'
  begin
    if @v_UseOldRenewalValueOnly = 'Y' 
      set @v_multiplier_old=@v_multiplier
    else
      set @v_multiplier_old=@v_multiplier2

      select @v_pcfaker = count(*) from t_payment_component
      insert into t_payment_component( /*pc_id,*/                                --#3
        pct_id,
        invoice_id,
        pc_amount,
        comments,
        misc_date,
        misc_string)
        select /*checksum(*)+@v_pcfaker,*/
          isnull(pct_id,(select nat_freqadj_defaultcomptype from odps."national" where
            nat_id = (select odps.od_blf_getwhichnational(@inContractorEnd) ))),
          @v_InvoiceNumber,
          (sum(isnull(fd_amount_to_pay,0))*
          (case when fd_effective_date between @inPayPeriod_Start and @inPayPeriod_End then
            (case when fd_effective_date between @inPayPeriod_Start and @inRenewalStart then
              (datediff(day,fd_effective_date,@inRenewalStart)/@v_perioddiff)
            else
              ((datediff(day,fd_effective_date,@inPayPeriod_End)+1)/@v_perioddiff)
            end)
          else
            --@v_multiplier2
          @v_multiplier_old
          end))/12.0,
          (case when fd_effective_date between @inPayPeriod_Start and @inPayPeriod_End then 'Arrears:' else '' end)+'Frequency Adjustment, previous renewal'+' / Effective:'+
          convert(varchar,fd_effective_date)+' / Annual amount: '+
          --!convert(varchar,isnull(fd_amount_to_pay,0))+' '+
          convert(varchar,isnull(fd_amount_to_pay,0))+', Prorata: '+
          convert(varchar,(case when fd_effective_date between @inPayPeriod_Start and @inPayPeriod_End then
            ((datediff(day,fd_effective_date,@inPayPeriod_End)+1)/@v_perioddiff)
          else
            --@v_multiplier
			@v_multiplier_old
          end)),
          fd_effective_date,
          -- PBY 04/06/2002 SR#4397 Retrieve extension reason from frequency_distances.fd_change_reason
          --'Extension ' || 
          -- (if fd_effective_date between inPayPeriod_Start and inPayPeriod_End then 
          --    string(fd_effective_date) || ' to ' || string(inPayPeriod_End) 
          -- else 
          --    '' 
          -- endif)         
          -- PBY 07-08-2002 SR#4443 Added ",CONTRACT_NO" to the group_by clause
          ext=(select top 1 fd.fd_change_reason from
            rd.frequency_distances as fd where
            fd.fd_effective_date = rd.frequency_adjustments.fd_effective_date and
            fd.contract_no = rd.frequency_adjustments.contract_no) from
          rd.frequency_adjustments where
          (contract_no = @inContract_no) and
          (contract_seq_number = @inSequence_no-1) and
          (fd_confirmed = 'Y') and
          (fd_effective_date <= @inContractorEnd)
          group by pct_id,fd_effective_date,fd_amount_to_pay,CONTRACT_NO,contract_seq_number,fd_unique_seq_number,fd_adjustment_amount,fd_paid_to_date,fd_bm_after_extn,fd_confirmed,sf_key,rf_delivery_days
		--!group by pct_id,fd_effective_date,fd_amount_to_pay,fd_effective_date,fd_effective_date,CONTRACT_NO;
      select @v_pcfaker = count(*) from odps.t_payment_component
      insert into odps.t_payment_component(/*pc_id,*/				--#4
        pct_id,
        invoice_id,
        pc_amount,
        comments,
        misc_date,
        misc_string)
        select /*checksum(*)+@v_pcfaker,*/
          isnull(pct_id,(select nat_freqadj_defaultcomptype from odps."national" where
            nat_id = (select odps.od_blf_getwhichnational(@inContractorEnd) ))),
          @v_InvoiceNumber,
          (sum(isnull(fd_amount_to_pay,0))*datediff(day,fd_effective_date,@inContractorStart))/365.0,'Arrears:Frequency Adjustment, previous renewal'+' *** Effective:'+
          --!convert(varchar,fd_effective_date)+
          convert(varchar,fd_effective_date)+' *** Days overdue:'+
          convert(varchar,datediff(day,fd_effective_date,@inContractorStart))+' *** Annual amount: '+
          convert(varchar,isnull(fd_amount_to_pay,0)),
          fd_effective_date,'Extension Arrears' from
          rd.frequency_adjustments where
          (contract_no = @inContract_no) and
          (contract_seq_number = @inSequence_no-1) and
          (fd_paid_to_date is null) and
          (fd_confirmed = 'Y') and
          (fd_effective_date < @inContractorStart) and
          (fd_effective_date >= @v_contractor_contract_start)
         group by pct_id,fd_effective_date,fd_amount_to_pay,contract_no,contract_seq_number,fd_unique_seq_number,fd_adjustment_amount,fd_paid_to_date,fd_bm_after_extn,fd_confirmed,sf_key,rf_delivery_days
        --!group by pct_id,fd_effective_date,fd_amount_to_pay,fd_effective_date;
        if @@ERROR <> 0
        begin
          rollback transaction
          set implicit_transactions off
          return(-100000175)
        end
   end
--
  --**************CONTRACT ADJUSTMENTS*******************--
--
  select @v_pcfaker = count(*) from odps.t_payment_component
  insert into odps.t_payment_component(/*pc_id,*/			--#5
    pct_id,
    invoice_id,
    pc_amount,
    comments,
    misc_date,
    misc_string)
    select /*checksum(*)+@v_pcfaker,*/
      isnull(pct_id,(select nat_ContAdj_DefaultCompType from "national" where
        nat_id = (select odps.od_blf_getwhichnational(@inContractorEnd) ))),
      @v_InvoiceNumber,
      sum(isnull(ca_amount,0)),'Contract Adj:Current renewal *** Occurred '+
      convert(varchar,ca_date_occured)+' *** Amount:'+
      convert(varchar,isnull(ca_amount,0)),
      ca_date_occured,
      isnull(ca_reason,'Contract Adjustment') from
      rd.contract_adjustments where
      (contract_no = @inCOntract_no) and
      (ca_confirmed = 'Y') and
      (ca_date_occured between @v_contractor_contract_start and @inContractorEnd) and
      (ca_date_paid is null)
      group by pct_id,ca_date_occured,ca_amount,ca_reason,ca_key,contract_no,contract_seq_number,ca_date_paid,ca_confirmed
	--!group by pct_id,ca_date_occured,ca_amount,ca_date_occured,ca_reason
    if @@ERROR <> 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000180)
    end
--
  --**************CONTRACT ALLOWANCES*******************--
--
  select @v_pcfaker = count(*) from odps.t_payment_component
  if @v_UseBothRenewals = 'Y'
    insert into t_payment_component(/*pc_id,*/
      pct_id,
      invoice_id,
      pc_amount,
      comments,
      misc_date,
      misc_string)
      select /*checksum(*)+@v_pcfaker,*/
        isnull(pct_id,(select nat_ContAllow_DefaultComptype from "national" where
          nat_id = (select odps.od_blf_getwhichnational(@inContractorEnd)))),
        @v_InvoiceNumber,
        sum(isnull(contract_allowance.ca_annual_amount,0))*
        (case when ca_effective_date between @inPayPeriod_Start and @inPayPeriod_End then
          ((datediff(day,@inRenewalStart,@inContractorEnd)+1)/@v_perioddiff)
        else
          (@v_multiplier+@v_multiplier2)
        end)/12.0,'Contract allowance: For the period'+' *** Effective '+
        convert(varchar,ca_effective_date)+' *** Annual amount: '+
        convert(varchar,isnull(ca_annual_amount,0))+', Prorata: '+
        convert(varchar,(case when ca_effective_date between @inPayPeriod_Start and @inPayPeriod_End then
          ((datediff(day,ca_effective_date,@inPayPeriod_End)+1)/@v_perioddiff)
        else
          @v_multiplier
        end)),
		ca_effective_date,
        isnull(ca_notes,'Contract Allowance') from
        rd.contract_allowance where
        (contract_allowance.contract_no = @inContract_no) and
        (contract_allowance.ca_effective_date <= @inContractorEnd) 
        and ((select nat_freqadj_defaultcomptype from odps."national" where
          nat_id = (select odps.OD_BLF_getwhichnational(@inContractorEnd))) is not null) --add
        group by pct_id,ca_effective_date,ca_annual_amount,ca_effective_date,ca_notes,alt_key,contract_no,ca_paid_to_date

        --! group by pct_id,ca_effective_date,ca_annual_amount,ca_effective_date,ca_notes
  else
    insert into odps.t_payment_component(/*pc_id,*/
      pct_id,
      invoice_id,
      pc_amount,
      comments,
      misc_date,
      misc_string)
      select /*checksum(*)+@v_pcfaker,*/
        isnull(pct_id,(select nat_ContAllow_DefaultComptype from odps."national" where
          nat_id = (select odps.od_blf_getwhichnational(@inContractorEnd) ))),
        @v_InvoiceNumber,
        sum(isnull(contract_allowance.ca_annual_amount,0))*
        (case when ca_effective_date between @inPayPeriod_Start and @inPayPeriod_End then
          ((datediff(day,ca_effective_date,@inPayPeriod_End)+1)/@v_perioddiff)
        else
          @v_multiplier
        end)/12.0,'Contract allowance: For the period'+' *** Effective '+
        convert(varchar,ca_effective_date)+' *** Annual amount: '+
        convert(varchar,isnull(ca_annual_amount,0))+', Prorata: '+
        convert(varchar,(case when ca_effective_date between @inPayPeriod_Start and @inPayPeriod_End then
          ((datediff(day,ca_effective_date,@inPayPeriod_End)+1)/@v_perioddiff)
        else
          @v_multiplier
        end)),
		ca_effective_date,
        isnull(ca_notes,'Contract Allowance') from
        rd.contract_allowance where
        (contract_allowance.contract_no = @inContract_no) and
        (contract_allowance.ca_effective_date <= @inContractorEnd) 
        and ((select nat_freqadj_defaultcomptype from odps."national" where
          nat_id = (select odps.OD_BLF_getwhichnational(@inContractorEnd))) is not null) --add
        group by pct_id,ca_effective_date,ca_annual_amount,ca_effective_date,ca_notes,alt_key,contract_no,ca_paid_to_date
		
		--!group by pct_id,ca_effective_date,ca_annual_amount,ca_effective_date,ca_notes
    if @@ERROR < 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000190)
    end
  select @v_pcfaker = count(*) from t_payment_component
  insert into t_payment_component(/*pc_id,*/
    pct_id,
    invoice_id,
    pc_amount,
    comments,
    misc_date,
    misc_string)
    select /*checksum(*)+@v_pcfaker,*/
       isnull(pct_id,(select nat_ContAllow_DefaultComptype from odps."national" where
        nat_id = (select odps.od_blf_getwhichnational(@inContractorEnd)))),
      @v_InvoiceNumber,
      sum(isnull(contract_allowance.ca_annual_amount,0))*(datediff(day,ca_effective_date,@inContractorStart)/365.0),'Arrears:Contract Allowance,'+' Effect '+
      convert(varchar,ca_effective_date)+' *** Days overdue:'+
      convert(varchar,datediff(day,ca_effective_date,@inContractorStart))+' *** Annual amount: '+
      convert(varchar,isnull(ca_annual_amount,0)),
      ca_effective_date,
      isnull(ca_notes,'Contract Allowance Arrears') from
      rd.contract_allowance where
      (contract_allowance.contract_no = @inContract_no) and
      (contract_allowance.ca_effective_date <= @inContractorEnd) and
      (contract_allowance.ca_effective_date < @inPayPeriod_Start) and
      (ca_paid_to_date is null)
      group by pct_id,ca_effective_date,ca_annual_amount,ca_effective_date,ca_notes,alt_key,contract_no,ca_paid_to_date
	  --!group by pct_id,ca_effective_date,ca_annual_amount,ca_effective_date,ca_notes
    if @@ERROR <> 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000194)
    end
  select @v_PiecerateStartDate = odps.OD_MiscF_GetFirstDayofMonth(@inContractorEnd)
  if @@ERROR <> 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000200)
    end
  select @v_PiecerateEndDate = odps.OD_MiscF_getlastdayofmonth(@inContractorEnd) 
--select '07 002', * from t_payment_component --add
  if @@ERROR <> 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000210)
    end
  --
  --***********************Piece Rates*************************--
  --
  -- PBY 07/08/2002 SR#4443 Passed in PayPeriodStart & Ends instead of the contractor
  -- start & end dates
  declare @inSequence_no_1 int
  set @inSequence_no_1=@inSequence_no - 1

  if @v_UseOldRenewalValueOnly = 'N'
    -- PBY 18/08/2002 SR#4446 added contractor_end date to the query
    execute @v_adpost = odps.OD_BLF_Mainrun_Grosspay_Piecerates 
      @incontract_no,
      @inSequence_no,
      @inPayPeriod_Start,
      @inPayPeriod_End,
      @v_InvoiceNumber,'A',
      @v_contractor_contract_start,
      @inContractorEnd,
      @inContractor_no 
  else
    execute @v_adpost = odps.OD_BLF_Mainrun_Grosspay_Piecerates @incontract_no, 
      @inSequence_no_1 ,  --@inSequence_no - 1 ,
      @inPayPeriod_Start,
      @inPayPeriod_End,
      @v_InvoiceNumber,'A',
      @v_contractor_contract_start,
      @inContractorEnd,
      @inContractor_no       
  if @@ERROR <> 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000211)
    end
  if @v_adpost < 0
	begin
	rollback transaction --!
    set implicit_transactions off
    return(@v_adpost)
	end
  if @v_adpost is null
    select @v_adpost=0
  if @v_UseOldRenewalValueOnly = 'N'
    execute  @v_courierpost = odps.OD_BLF_Mainrun_Grosspay_Piecerates @incontract_no,
      @inSequence_no,
      @inPayPeriod_Start,
      @inPayPeriod_End,
      @v_InvoiceNumber,'C',
      @v_contractor_contract_start,
      @inContractorEnd,
      @inContractor_no
  else
    execute @v_courierpost = odps.OD_BLF_Mainrun_Grosspay_Piecerates @incontract_no,
      @inSequence_no_1, --@inSequence_no-1,
      @inPayPeriod_Start,
      @InPayPeriod_End,
      @v_InvoiceNumber,'C',
      @v_contractor_contract_start,
      @inContractorEnd,
      @inContractor_no    
  if @v_courierpost < 0
	begin
		rollback transaction --!
        set implicit_transactions off
		return(-100000230)
	end
  if @v_courierpost is null
    select @v_courierpost=0
  if @v_UseOldRenewalValueOnly = 'N'
    execute @v_XP = odps.OD_BLF_Mainrun_Grosspay_Piecerates @incontract_no,
      @inSequence_no,
      @inPayPeriod_Start,
      @inPayPeriod_End,
      @v_InvoiceNumber,'X',
      @v_contractor_contract_start,
      @inContractorEnd,
      @inContractor_no     
  else
    execute @v_XP = odps.OD_BLF_Mainrun_Grosspay_Piecerates @incontract_no,
      @inSequence_no_1, --@inSequence_no-1,
      @inPayPeriod_Start,
      @inPayPeriod_End,
      @v_InvoiceNumber,'X',
      @v_contractor_contract_start,
      @inContractorEnd,
      @inContractor_no 
  if @v_XP < 0
	begin
		rollback transaction --!
        set implicit_transactions off
		return(-100000235)
	end
  if @v_XP is null
    select @v_XP=0
  if @v_UseOldRenewalValueOnly = 'N'
    execute @v_ParcelPost = odps.OD_BLF_Mainrun_Grosspay_Piecerates @incontract_no,
      @inSequence_no,
      @inPayPeriod_Start,
      @inPayPeriod_End,
      @v_InvoiceNumber,'P',
      @v_contractor_contract_start,
      @inContractorEnd,
      @inContractor_no 
     
  else
    execute @v_ParcelPost = odps.OD_BLF_Mainrun_Grosspay_Piecerates @incontract_no,
      @inSequence_no_1, --@inSequence_no-1,
      @inPayPeriod_Start,
      @inPayPeriod_End,
      @v_InvoiceNumber,'P',
      @v_contractor_contract_start,
      @inContractorEnd,
      @inContractor_no     
  if @v_ParcelPost < 0
	begin
	rollback transaction --!
    set implicit_transactions off
    return(-100000240)
	end
  if @v_ParcelPost is null
    select @v_ParcelPost=0
  if @v_Payment_value is null
    select @v_Payment_value=0 
  --
  --*****************Finished: Return results******************--
  -- in t_payment_component
  --
  select @v_pcfaker = count(*) from odps.t_payment_component
  insert into odps.t_payment_component(/*pc_id,*/
    pct_id,
    invoice_id,
    pc_amount,
    comments)
   select top 1
/*checksum(*)+@v_pcfaker,*/
      (select min(pct_id) from payment_component_type where pct_description like 'Contract payment value%'),
      @v_InvoiceNumber,
      @v_Payment_value,'Payment val '+'(prorata 1='+ 
      convert(varchar,@v_multiplier)+'='+
      convert(varchar,convert(int,round(@v_multiplier*@v_perioddiff,0)))+' days)'+' CCS='+
      convert(varchar,@v_contractor_contract_start)+' CS='+
      convert(varchar,@inContractorStart)+' CE='+
      convert(varchar,@inContractorEnd)+' RS='+
      convert(varchar,@inRenewalStart)+' RE='+
      convert(varchar,@inRenewalEnd)+' PS='+
      convert(varchar,@inPayPeriod_Start)+' PE='+
      convert(varchar,@inPayPeriod_End)+' Case='+
      convert(varchar,@v_Case)+' Prorata 2= '+
      convert(varchar,@v_multiplier2) 
  if @@ERROR <> 0
    begin
      rollback transaction
      set implicit_transactions off
      return(-100000270)
    end
  -- (this doesn''t appear to do anything useful)
  select @v_grosspay = sum(pc_amount) from odps.t_payment_component
  if @@ERROR < 0
    begin
	--
    --********************Exception Handling*********************--
    --
      rollback transaction
      set implicit_transactions off
      return(-100000280)
    end
  commit transaction
  return(1)
/* Watcom only
exception
  when others then
    rollback transaction
    resignal
    return(-200000000+sqlcode)
*/
  set implicit_transactions off
end

























GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE function [rd].[benchmarkCalcVeh2005](@inContract int,@inSequence int,@inVehicle int)
RETURNS real
AS
BEGIN
  declare @nNominalVehical numeric(10,2)
  -- declare nWageHourlyRate numeric(10,2);           -- TJB SR4661
  declare @nDeliveryWageRate numeric(10,2)-- TJB SR4661
  declare @nProcessingWageRate numeric(10,2)-- TJB SR4661
  declare @nRepairsMaint numeric(10,2)
  declare @nTyreTubes numeric(10,2)
  declare @nVehicalAllow numeric(10,2)
  declare @nVehicalInsure numeric(10,2)
  declare @nPublicLia numeric(10,2)
  declare @nCarrierRisk numeric(10,2)
  declare @nACCRate numeric(10,2)
  declare @nLicence numeric(10,2)
  declare @nRateOfReturn numeric(10,2)
  declare @nSalvageRatio numeric(10,2)
  declare @nItemsHour numeric(10,2)
  declare @nFuel numeric(10,2)
  declare @nConsumption numeric(10,2)
  declare @dStartDate datetime
  declare @dEndDate datetime
  declare @nNumRows int
  declare @nRouteDistance numeric(10,2)
  declare @nDeliveryHours numeric(10,3)
  declare @nProcessingHours numeric(10,2)
  declare @nVolume numeric(10,2)
  declare @nDeliveryDays numeric(10,2)
  declare @nMaxDeliveryDays numeric(10,2)
  declare @nRouteDistancePerDay real
  declare @nVehicleDepreciation real
  declare @nFuelCostPerAnnum real
  declare @nRepairsPerAnnum real
  declare @nTyresTubesPerAnnum real
  declare @nDeliveryCost real
  declare @nProcessingCost real
  declare @nReliefCost real-- Added:  TJB  SR4661
  declare @nReliefWeeks real                      -- added: TJB  SR4703
  declare @nPublicLiabilityCost real
  declare @nACCPerAnnum real
  declare @nBenchmark real
  declare @nVehicleInsurance real
  declare @nLicensing real
  declare @nCarrierRiskRate real
  declare @nRateReturn real
  declare @dEffectDate datetime
  declare @nTempint int
  declare @Tempdec numeric(10,2)
  declare @nRUC numeric(8,2)
  declare @nRUCRate numeric(8,2)
  declare @nAccounting numeric(8,2)
  declare @nTelephone numeric(8,2)
  declare @nSundries numeric(8,2)
  declare @nSundriesK numeric(8,2)
  declare @nRemainingEconomicLife int
  declare @nACCAmount numeric(12,2)
  declare @nInsurancePct numeric(12,2)
  declare @nLivery numeric(12,2)
  declare @nUniform numeric(12,2)
  declare @nLiveryPerAnnum numeric(12,2)
  declare @nUniformPerAnnum numeric(12,2)
  declare @nMaxdays int
  --  declare nACCAmount decimal(12,2);
  select top 1
    @nNominalVehical=isNull(vor.vor_nominal_vehicle_value,vr.vr_nominal_vehicle_value),
    @nRemainingEconomicLife=v.v_remaining_economic_life,
    --    isNull(nvor.nvor_wage_hourly_rate,nvr.nvr_wage_hourly_rate) as wage_rate,                  -- TJB SR4661
    @nDeliveryWageRate=isNull(nvor.nvor_delivery_wage_rate,nvr.nvr_delivery_wage_rate), -- TJB SR4661
    @nProcessingWageRate=isNull(nvor.nvor_processing_wage_rate,nvr.nvr_processing_wage_rate), -- TJB SR4661
    @nRepairsMaint=isNull(vor.vor_repairs_maintenance_rate,vr.vr_repairs_maintenance_rate),
    @nTyreTubes=isNull(vor.vor_tyre_tubes_rate,vr.vr_tyre_tubes_rate),
    @nVehicalAllow=isNull(vor.vor_vehical_allowance_rate,vr.vr_vehicle_allowance_rate),
    @nVehicalInsure=rd.f_GetInsurance(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date), --ins $
    @nPublicLia=isNull(nvor.nvor_public_liability_rate_2,nvr.nvr_public_liability_rate),
    @nCarrierRisk=isNull(nvor.nvor_carrier_risk_rate,nvr.nvr_carrier_risk_rate),
    @nACCRate=isNull(nvor.nvor_acc_rate,nvr.nvr_acc_rate),
    @nACCAmount=isNull(nvor.nvor_acc_rate_amount,nvr.nvr_acc_rate_amount),
    @nLicence=isNull(vor.vor_licence_rate,vr.vr_licence_rate),
    @nRateOfReturn=isNull(vor.vor_vehicle_rate_of_return_pct,vr.vr_vehicle_rate_of_return_pct),
    @nSalvageRatio=isNull(vor.vor_salvage_ratio,vr.vr_salvage_ratio),
    @nItemsHour=isNull(nvor.nvor_item_proc_rate_per_hour,nvr.nvr_item_proc_rate_per_hr),
    @nFuel=isNull(vor.vor_fuel_rate,rd.f_GetFuelRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)),
    @nConsumption=isNull(vor_consumption_rate,rd.f_GetConsumptionRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)),
    @nAccounting=isNull(nvor.nvor_accounting,nvr.nvr_accounting),
    @nTelephone=isNull(nvor.nvor_telephone,nvr.nvr_telephone),
    @nSundries=isNull(nvor.nvor_sundries,nvr.nvr_sundries),
    @nRucrate=isNull(vor.vor_ruc,vr.vr_ruc),
    @nSundriesK=isNull(vor.vor_sundries_k,vr.vr_sundries_k),
    @nInsurancePct=isNull(vr.vr_vehicle_value_insurance_pct,0),
    @nLivery=isNull(vor.vor_livery,vr.vr_livery),
    @nUniform=isNull(nvor_uniform,nvr_uniform),
    @nACCAmount=isNull(nvor.nvor_acc_rate_amount,nvr.nvr_acc_rate_amount)
from
--!     contract_renewals as cr left outer join non_vehicle_override_rate as nvor  on  cr.contract_no = nvor.contract_no and cr.contract_seq_number = nvor.contract_seq_number,
--!    contract_renewals as cr1 left outer join vehicle_override_rate as vor on cr1.contract_no = vor.contract_no and cr1.contract_seq_number = vor.contract_seq_number,
     contract_renewals as cr left outer join non_vehicle_override_rate as nvor  on  cr.contract_no = nvor.contract_no and cr.contract_seq_number = nvor.contract_seq_number
    left outer join vehicle_override_rate as vor on cr.contract_no = vor.contract_no and cr.contract_seq_number = vor.contract_seq_number,
    contract_vehical as cv,
    vehicle as v,
    contract as c,
    non_vehicle_rate as nvr,
    vehicle_type as vt,
    vehicle_rate as vr
    where

    vt.vt_key = vr.vt_key and
    cv.contract_no = cr.contract_no and
    cv.contract_seq_number = cr.contract_seq_number and
    v.vehicle_number = cv.vehicle_number and
    vt.vt_key = v.vt_key and
    c.contract_no = cr.contract_no and
    v.vehicle_number = rd.f_GetLatestVehicle(cr.contract_no,cr.contract_seq_number) and
    c.rg_code = nvr.rg_code and
    cr.contract_no = @inContract and
    cr.contract_seq_number = @inSequence and
    nvr.nvr_rates_effective_date = cr.con_rates_effective_date and
    vr.vr_rates_effective_date = cr.con_rates_effective_date order by
    vor.vor_effective_date desc
  if @@error <> 0 /* <> was < */
    /* Watcom only
    resignal
    */
return -1    
  select @dStartDate=con_start_date
       , @dEffectDate=con_rates_effective_date
    from contract_renewals
   where contract_renewals.contract_no = @inContract
     and contract_renewals.contract_seq_number = @inSequence

  select @dEndDate=con_start_date
    from contract_renewals
   where contract_renewals.contract_no = @inContract
     and contract_renewals.contract_seq_number = @inSequence+1

      -- Added TJB  SR4703  Sep 2007
  if @dEffectDate >= '2007 Oct 31'
    set @nReliefWeeks = 5
  else
    set @nReliefWeeks = 4
    
 select @nNumRows=count(*),
    @nDeliveryDays=rd.GetContractDelDays(contract_renewals.contract_no,contract_renewals.contract_seq_number,contract_renewals.con_rg_code_at_renewal,contract_renewals.con_rates_effective_date),
    @nRouteDistance=contract_renewals.con_distance_at_renewal+sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum),
    @nDeliveryHours=contract_renewals.con_del_hrs_week_at_renewal+sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
    @nProcessingHours=contract_renewals.con_processing_hours_per_week+sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
    @nVolume=contract_renewals.con_volume_at_renewal+sum(isnull(frequency_distances.fd_volume,0))
    from contract_renewals,
    route_frequency left outer join frequency_distances on
    route_frequency.contract_no = frequency_distances.contract_no and
    route_frequency.sf_key = frequency_distances.sf_key and
    route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days and
    frequency_distances.fd_effective_date >= @dStartDate and
    @dStartDate is not null and
    (@dEndDate is null or @dEndDate >= frequency_distances.fd_effective_date),
    rate_days where
    contract_renewals.contract_no = route_frequency.contract_no and
    route_frequency.sf_key = rate_days.sf_key and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
    group by contract_renewals.contract_no,
    contract_renewals.contract_seq_number,
    contract_renewals.con_rg_code_at_renewal,
    contract_renewals.con_rates_effective_date,
    contract_renewals.con_distance_at_renewal,
    contract_renewals.con_del_hrs_week_at_renewal,
    contract_renewals.con_processing_hours_per_week,
    contract_renewals.con_volume_at_renewal
  select @nMaxDeliveryDays=max(rate_days.rtd_days_per_annum)
    from contract_renewals join rate_days on
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  --If max days per week>4, assume deldays = maxdeldays
  select @nMaxdays=sum(standard_frequency.sf_days_week)
    from rate_days,
    standard_frequency,
    route_frequency,
    contract,contract_renewals where
    standard_frequency.sf_key = rate_days.sf_key and
    route_frequency.sf_key = standard_frequency.sf_key and
    rate_days.rg_code = contract.rg_code and
    contract.contract_no = route_frequency.contract_no and
    route_frequency.contract_no = @inContract and
    route_frequency.rf_active = 'Y' and
    contract_renewals.contract_no = contract.contract_no and
    contract_renewals.contract_seq_number = @inSequence and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date
  if @nMaxdays > 4
    select @nDeliveryDays=@nMaxDeliveryDays
  select @nRouteDistancePerDay=@nRouteDistance/@nDeliveryDays
  --select nRouteDistance*(nVehicalAllow/1000) into nVehicleDepreciation;
  if @nRemainingEconomicLife > 0
    -- PBY 26/06/2002 SR#4415 Added nRouteDistance/1000 to VehicleDepreciation
    -- calcuation if REL > 0
    select @nVehicleDepreciation=(@nRouteDistance/1000)*((1-(isNull(@nSalvageRatio,0)/100))*isNull(@nNominalVehical,0)*1000)/@nRemainingEconomicLife
  else
      select @nVehicleDepreciation=@nRouteDistance*(@nVehicalAllow/1000)
  select @nFuelCostPerAnnum=(@nConsumption/100)*@nRouteDistance*(@nFuel/100)
  select @nRepairsPerAnnum=@nRouteDistance*(@nRepairsMaint/1000)
  select @nTyresTubesPerAnnum=@nTyreTubes*(@nRouteDistance/1000)
  -- TJB SR4661: Changed nWageHourlyRate to nDeliveryWageRate and nProcessingWageRate
  select @nDeliveryCost=((round(@nDeliveryHours,2))*52)*@nDeliveryWageRate
  select @nProcessingCost=((((@nVolume/@nItemsHour)/365)*7)*52)*@nProcessingWageRate
  select @nReliefCost=(round(@nDeliveryHours,2)*4)*@nDeliveryWageRate+ -- Added:  TJB  SR4661
    ((((@nVolume/@nItemsHour)/365)*7)*4)*@nProcessingWageRate
  select @nPublicLiabilityCost=@nPublicLia*(@nDeliveryDays/@nMaxDeliveryDays)
  --Benchmark 2001
  select @nACCPerAnnum=(@nAccRate/100)*(@nDeliveryCost+@nProcessingCost+@nReliefCost)+isNull(@nACCAmount,0)
  --select nVehicalInsure*(nDeliveryDays/nMaxDeliveryDays) into nVehicleInsurance;
    --Benchmark 2001
  --set nVehicleInsurance=nVehicalInsure;
  select @nVehicleInsurance=@nVehicalInsure*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nLiveryPerAnnum=@nRouteDistance*(@nLivery/1000)
  select @nUniformPerAnnum=@nRouteDistance*(@nUniform/1000)
  select @nLicensing=@nLicence*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nCarrierRiskRate=@nCarrierRisk*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nRateReturn=rd.GetRateReturn(@nNominalVehical,@nRateOfReturn,@nSalvageRatio)
  select @nRateReturn=@nRateReturn*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nAccounting=@nAccounting*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nTelephone=@nTelephone*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nSundries=@nSundries*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nTempint=count(contractor_renewals.contract_no)
    from rd.contractor_renewals,
    rd.contract_vehical,
    rd.vehicle,
    rd.fuel_type where
    contractor_renewals.contract_no = @inContract and
    contractor_renewals.contract_seq_number = @inSequence and
    contractor_renewals.contract_no = contract_vehical.contract_no and
    contractor_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.vehicle_number = vehicle.vehicle_number and
    vehicle.ft_key = fuel_type.ft_key and
    fuel_type.ft_description like 'diesel%' and
    --and(contract_vehical.cv_vehical_status='A')
    --vehicle.vehicle_number = f_GetLatestVehicle(inContract,inSequence);
    vehicle.vehicle_number = @inVehicle
  if @@error <> 0 /* <> was < */
    /* Watcom only
    resignal
    */
return -1
  if @ntempint = 0
    select @nRUC=0.0
  else
    select @nRUC=@nRUCRate*(@nRouteDistance/1000)
select @nSundriesK=@nSundriesK*(@nRouteDistance/1000)
  select @nBenchmark=isnull(@nVehicleDepreciation,0)+
    isnull(@nFuelCostPerAnnum,0)+
    isnull(@nRepairsPerAnnum,0)+
    isnull(@nTyresTubesPerAnnum,0)+
    isnull(@nDeliveryCost,0)+
    isnull(@nProcessingCost,0)+
    isnull(@nReliefCost,0)+
    isnull(@nPublicLiabilityCost,0)+
    isnull(@nACCPerAnnum,0)+
    isnull(@nVehicleInsurance,0)+
    isnull(@nLicensing,0)+
    isnull(@nCarrierRiskRate,0)+
    isnull(@nRateReturn,0)+
    isnull(@nRUC,0)+
    isnull(@nTelephone,0)+
    isnull(@nSundries,0)+
    isnull(@nAccounting,0)+
    isnull(@nSundriesK,0)+
    isnull(@nLiveryPerAnnum,0)+
    isnull(@nUniformPerAnnum,0)
  select @nBenchmark=Round(@nBenchmark+.49,0)
  return(@nBenchmark)
END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure  [odps].[OD_RPS_WithholdingTax](@sdate datetime,@edate datetime,@fin_sdate datetime,@fin_edate datetime)
as
begin
  select  distinct [contract].contract_no,
    contractor.c_surname_company,
    contractor.c_first_names,
    contractor.c_initials ,
    pbu_code.pbu_code,
    ac_code=cast(odps.OD_MiscF_Get_ACID([contract].contract_no)as varchar(10)),
      amount=cast((select abs(sum(odps.OD_RPF_PCGetSum(payment.invoice_id,'TAX')) ) from
      payment where
      payment.invoice_date between @sdate and @edate and
      payment.contract_no = [contract].contract_no and
      payment.contractor_supplier_no = contractor.contractor_supplier_no) as decimal(30,6)),
    yearamount=cast(isnull( (select abs(sum(payment_component.pc_amount)) from
      payment,
      payment_component,
      payment_component_type,
      payment_component_group where
      payment.contract_no = [contract].contract_no and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.invoice_id = payment_component.invoice_id and
      payment_component.pct_id = payment_component_type.pct_id and
      payment_component_type.pcg_id = payment_component_group.pcg_id and
      payment_component_group.pcg_short_code = 'TAX' and
      payment.invoice_date between @fin_sdate and @fin_edate),0) as decimal(30,6)) from
    rd.contract_renewals,
    rd.contractor_renewals,
    rd.[contract],
    pbu_code,
    rd.contractor where
    (contractor_renewals.contract_no = contract_renewals.contract_no) and
    pbu_code.pbu_id = [contract].pbu_id and
    contractor_renewals.contractor_supplier_no = contractor.contractor_supplier_no and
    (contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number) and
    ([contract].contract_no = contract_renewals.contract_no) 
and
    --    and(contract.con_active_sequence=contract_renewals.contract_seq_number)
    exists(select invoice_id from
      payment where
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.contract_no = [contract].contract_no and
      payment.invoice_date between @fin_sdate and @fin_edate) and
    (select abs(sum(payment_component.pc_amount)) from
      payment,
      payment_component,
      payment_component_type,
      payment_component_group where
      payment.contract_no = [contract].contract_no and
      payment.contractor_supplier_no = contractor.contractor_supplier_no and
      payment.invoice_id = payment_component.invoice_id and
      payment_component.pct_id = payment_component_type.pct_id and
      payment_component_type.pcg_id = payment_component_group.pcg_id and
      payment_component_group.pcg_short_code = 'TAX' and
      payment.invoice_date between @fin_sdate and @fin_edate) <> 0 order by
    [contract].contract_no asc  
--  contractor_renewals.contract_seq_number asc,
--  contractor_renewals.cr_effective_date asc

end


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [rd].[sp_GetBenchmarkRpt2006](@inContract int,@inSequence int)
-- TJB  SR4661  May 2005 - Significant changes
-- Changed delivery and processing cose calculations
-- Added relief cost calculation and associated changes
-- Added relief cost to returned results
-- Split nWageHourlyRate into nDeliveryWageRate and nProcessingWageRate
-- TJB  SR4684  June 2006
-- Added estimation of Parcel Post value if no actual deliveries had been made
-- (see calls to f_estParcelPostValue)
-- TJB  SR4684  Fixups  July 2006
-- Change call to f_estParcelPostValue
--    nWageHourlyRate    numeric(10,2),        -- TJB SR4661
-- TJB SR4661
as -- Added:  TJB  SR4661
begin
  -- PBY Modified 28-Mar-2002
  -- Original:
  --    f_GetFuelRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)) as fuel,
  --    f_GetConsumptionRates(c.contract_no,cr.contract_seq_number,cr.con_rates_effective_date) as consumption,
  -- Modified to:
  --     isNull(vor.vor_fuel_rate,f_GetFuelRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)) as fuel,
  --     isNull(vor.vor_consumption_rate,f_GetConsumptionRates(c.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)) as consumption,
  declare cur_getsupplier cursor for select prs_key,prs_description from
      piece_rate_supplier
  declare @nNominalVehical numeric(10,2)
  --  declare nWageHourlyRate      numeric(10,2);            -- TJB SR4661
  declare @nDeliveryWageRate numeric(10,2) -- TJB SR4661
  declare @nProcessingWageRate numeric(10,2) -- TJB SR4661
  declare @nRepairsMaint numeric(10,2)
  declare @nTyreTubes numeric(10,2)
  declare @nVehicalAllow numeric(10,2)
  declare @nVehicalInsure numeric(10,2)
  declare @nPublicLia numeric(10,2)
  declare @nCarrierRisk numeric(10,2)
  declare @nACCRate numeric(10,2)
  declare @nLicence numeric(10,2)
  declare @nRateOfReturn numeric(10,2)
  declare @nSalvageRatio numeric(10,2)
  declare @nItemsHour numeric(10,2)
  declare @nFuel numeric(10,2)
  declare @nConsumption numeric(10,2)
  declare @dStartDate datetime
  declare @dEndDate datetime
  declare @dExpiryDate datetime;
  declare @sConTitle char(60)
  declare @iNumberCusts integer
  declare @sRDFile char(40)
  declare @sRCMFile char(40)
  declare @nCurrentPayment numeric(10,2)
  declare @nExtensions numeric(10,2)
  declare @nNumRows integer
  declare @nRouteDistance numeric(10,2)
  declare @nDeliveryHours numeric(10,3)
  declare @nProcessingHours numeric(10,2)
  declare @nContractVolume numeric(10,2)
  declare @nDeliveryDays numeric(10,2)
  declare @nDeliveryDaysForReport numeric(10,2)
  declare @nMaxDeliveryDays numeric(10,2)
  declare @nRouteDistancePerDay real
  declare @nVehicleDepreciation real
  declare @nFuelCostPerAnnum real
  declare @nRepairsPerAnnum real
  declare @nTyresTubesPerAnnum real
  declare @nDeliveryCost real
  declare @nProcessingCost real
  declare @nReliefCost real -- Added:  TJB  SR4661
   declare @nReliefWeeks real                            -- Added:  TJB  SR4703
  declare @dEffectDate datetime                             -- Added:  TJB  SR4703
  declare @nPublicLiabilityCost real
  declare @nACCPerAnnum real
  declare @nBenchmark real
  declare @nVehicleInsurance real
  declare @nLicensing real
  declare @nCarrierRiskRate real
  declare @nRateOfReturnCost real
  declare @nFinalBenchmark real
  declare @nRetainedAllowances numeric(10,2)
  declare @nPRSKey1 integer
  declare @nPRSKey2 integer
  declare @nPRSKey3 integer
  declare @nPRSKey4 integer
  declare @nPRSKey5 integer
  declare @sPieceRateSupplier1 char(50)
  declare @sPieceRateSupplier2 char(50)
  declare @sPieceRateSupplier3 char(50)
  declare @sPieceRateSupplier4 char(50)
  declare @sPieceRateSupplier5 char(50)
  declare @nPieceRate1 numeric(10,2)
  declare @nPieceRate2 numeric(10,2)
  declare @nPieceRate3 numeric(10,2)
  declare @nPieceRate4 numeric(10,2)
  declare @nPieceRate5 numeric(10,2)
  declare @nLoop integer
  declare @nRowCount integer
  declare @sRenewalGroup char(40)
  declare @nRenewalGroup integer
  declare @dRenewalDate datetime
  declare @nSumAdjustments numeric(10,2)
  declare @nRUC numeric(8,2)
  declare @nRUCRate numeric(8,2)
  declare @nAccounting numeric(8,2)
  declare @nTelephone numeric(8,2)
  declare @nSundries numeric(8,2)
  declare @nTempint integer
  declare @nSundriesK numeric(8,2)
  declare @PRStartDate datetime
  declare @PREndDate datetime
  --New 2001
  declare @nRemainingEconomicLife integer
  declare @nInsurancePct numeric(12,2)
  declare @nLivery numeric(12,2)
  declare @nUniform numeric(12,2)
  declare @nACCAmount numeric(12,2)
  declare @nLiveryPerAnnum numeric(12,2)
  declare @nUniformPerAnnum numeric(12,2)
  declare @nMaxDays integer
  select  @PRStartDate=rd.ymd(year(getdate())-1,month(getdate()),1)


  select @PREndDate=rd.getLastDayofMonth(dateadd(day,364,rd.ymd(year(getdate())-1,month(getdate()),1)))

  --///////////////////////////////// get rates //////////////////////////////////////////
  select top 1 @nNominalVehical=isNull(vor.vor_nominal_vehicle_value,vr.vr_nominal_vehicle_value),
    @nRemainingEconomicLife=v.v_remaining_economic_life,
    -- isNull(nvor.nvor_wage_hourly_rate,nvr.nvr_wage_hourly_rate) as wage_rate,                     -- TJB SR4661
    @nDeliveryWageRate=isNull(nvor.nvor_delivery_wage_rate,nvr.nvr_delivery_wage_rate), -- TJB SR4661
    @nProcessingWageRate=isNull(nvor.nvor_processing_wage_rate,nvr.nvr_processing_wage_rate), -- TJB SR4661
    @nRepairsMaint=isNull(vor.vor_repairs_maintenance_rate,vr.vr_repairs_maintenance_rate),
     @nTyreTubes=isNull(vor.vor_tyre_tubes_rate,vr.vr_tyre_tubes_rate),
    @nVehicalAllow=isNull(vor.vor_vehical_allowance_rate,vr.vr_vehicle_allowance_rate),
    @nVehicalInsure=rd.f_GetInsurance(c.contract_no,cr.contract_seq_number,cr.con_rates_effective_date), --ins $
    @nPublicLia=isNull(nvor.nvor_public_liability_rate_2,nvr.nvr_public_liability_rate),
    @nCarrierRisk=isNull(nvor.nvor_carrier_risk_rate,nvr.nvr_carrier_risk_rate),
    @nACCRate=isNull(nvor.nvor_acc_rate,nvr.nvr_acc_rate),
    @nLicence=isNull(vor.vor_licence_rate,vr.vr_licence_rate),
    @nRateOfReturn=isNull(vor.vor_vehicle_rate_of_return_pct,vr.vr_vehicle_rate_of_return_pct),
    @nSalvageRatio=isNull(vor.vor_salvage_ratio,vr.vr_salvage_ratio),
    @nItemsHour=isNull(nvor.nvor_item_proc_rate_per_hour,nvr.nvr_item_proc_rate_per_hr),
    @nFuel=isNull(vor.vor_fuel_rate,
    rd.f_GetFuelRates(c.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)),
    @nConsumption=isNull(vor.vor_consumption_rate,
    rd.f_GetConsumptionRates(c.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)),
    @sRenewalGroup=rg_description,
    @nRenewalGroup=rg.rg_code,
    @dRenewalDate=cr.con_rates_effective_date,
    @nAccounting=isNull(nvor.nvor_accounting,nvr.nvr_accounting),
    @nTelephone=isNull(nvor.nvor_telephone,nvr.nvr_telephone),
    @nSundries=isNull(nvor.nvor_sundries,nvr.nvr_sundries),
    @nRucrate=isNull(vor.vor_ruc,vr.vr_ruc),
    @nSundriesK=isNull(vor.vor_sundries_k,vr.vr_sundries_k),
    @nInsurancePct=isNull(vr.vr_vehicle_value_insurance_pct,0),
    @nLivery=isNull(vor.vor_livery,vr.vr_livery),
    @nUniform=isNull(nvor_uniform,nvr_uniform),
    @nACCAmount=isNull(nvor.nvor_acc_rate_amount,nvr.nvr_acc_rate_amount)  
from
    contract_renewals as cr
    left outer join non_vehicle_override_rate as nvor on
	cr.contract_no = nvor.contract_no --!and cr.contract_seq_number = nvor.contract_seq_number
	left outer join vehicle_override_rate as vor on
	cr.contract_no = vor.contract_no and cr.contract_seq_number = vor.contract_seq_number,
--    non_vehicle_override_rate as nvor,
    contract_vehical as cv,
    vehicle as v,
    contract as c,
    non_vehicle_rate as nvr,
    vehicle_type as vt,
    vehicle_rate as vr,
--    vehicle_override_rate as vor,
    renewal_group as rg

 where
    rg.rg_code = c.rg_code and 
    vt.vt_key = vr.vt_key and
    cv.contract_no = cr.contract_no and
    cv.contract_seq_number = cr.contract_seq_number and
    v.vehicle_number = cv.vehicle_number and
    vt.vt_key = v.vt_key and
    c.contract_no = cr.contract_no and
    v.vehicle_number =rd.f_GetLatestVehicle(c.contract_no,cr.contract_seq_number) and
    c.rg_code = nvr.rg_code and
    cr.contract_no = @inContract and
    cr.contract_seq_number = @inSequence and
    nvr.nvr_rates_effective_date = cr.con_rates_effective_date and
    vr.vr_rates_effective_date = cr.con_rates_effective_date 
	order by vor.vor_effective_date desc
  --/////////////////////////////////////////////////////////////////////////////////////////
  if @@error <> 0 /* <> was < */
    /* Watcom only
    resignal
    */
	RAISERROR('',10,1)
  --con start and end
  select @dStartDate=con_start_date
       , @dEffectDate=con_rates_effective_date
    from rd.contract_renewals
   where contract_renewals.contract_no = @inContract
     and contract_renewals.contract_seq_number = @inSequence;

  select @dEndDate=con_start_date,
        @dExpiryDate=con_expiry_date
    from contract_renewals
   where contract_renewals.contract_no = @inContract
     and contract_renewals.contract_seq_number = @inSequence+1;

      -- Added TJB  SR4703  Sep 2007
  if @dEffectDate >= '2007 Oct 31' 
    set @nReliefWeeks = 5
  else
    set @nReliefWeeks = 4
  --frequency rates
  select @nNumRows=count(*),
    @nDeliveryDays=rd.GetContractDelDays(contract_renewals.contract_no,
    contract_renewals.contract_seq_number,
    contract_renewals.con_rg_code_at_renewal,
    contract_renewals.con_rates_effective_date),
    @nRouteDistance=contract_renewals.con_distance_at_renewal+
    sum(isnull(frequency_distances.fd_distance,0)*
    rate_days.rtd_days_per_annum),
    @nDeliveryHours=contract_renewals.con_del_hrs_week_at_renewal+
    sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
    @nProcessingHours=contract_renewals.con_processing_hours_per_week+
    sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
    @nContractVolume=contract_renewals.con_volume_at_renewal+
    sum(isnull(frequency_distances.fd_volume, 0)),
    @iNumberCusts=isnull(contract_renewals.con_no_customers_at_renewal,0)+
    isnull(contract_renewals.con_no_cmb_custs_at_renewal,0)+
    sum(isnull(frequency_distances.fd_no_of_boxes,0))+
    sum(isnull(frequency_distances.fd_no_cmb_customers,0))
     from
    contract_renewals,
    route_frequency left outer join frequency_distances on
    route_frequency.contract_no = frequency_distances.contract_no and
    route_frequency.sf_key = frequency_distances.sf_key and
    route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days and
    frequency_distances.fd_effective_date >= @dStartDate and
    @dStartDate is not null and
    (@dEndDate is null or @dEndDate >= frequency_distances.fd_effective_date),
    rate_days where
    contract_renewals.contract_no = route_frequency.contract_no and
    route_frequency.sf_key = rate_days.sf_key and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
    group by contract_renewals.contract_no,
    contract_renewals.contract_seq_number,
    contract_renewals.con_rg_code_at_renewal,
    contract_renewals.con_rates_effective_date,
    contract_renewals.con_distance_at_renewal,
    contract_renewals.con_del_hrs_week_at_renewal,
    contract_renewals.con_processing_hours_per_week,
    contract_renewals.con_volume_at_renewal,
    contract_renewals.con_no_customers_at_renewal,
    contract_renewals.con_no_cmb_custs_at_renewal
  --pay value
  select @nCurrentPayment=contract_renewals.con_renewal_payment_value,
	@nExtensions=
    (select sum(distinct frequency_adjustments.fd_amount_to_pay) from
      frequency_adjustments where
      contract_renewals.contract_no = frequency_adjustments.contract_no and
      contract_renewals.contract_seq_number = frequency_adjustments.contract_seq_number and
      frequency_adjustments.fd_paid_to_date is not null) 
     from contract_renewals where
    contract_no = @inContract and
    contract_seq_number = @inSequence
  select @nCurrentPayment=@nCurrentPayment+isnull(@nExtensions,0)
  --days per annum
  select @nMaxDeliveryDays=max(rate_days.rtd_days_per_annum)
    from contract_renewals join rate_days on
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  --If max days per week>4, assume deldays = maxdeldays
  select @nMaxdays=sum(standard_frequency.sf_days_week)
    from rate_days,
    standard_frequency,
    route_frequency,
    contract,
    contract_renewals where
    standard_frequency.sf_key = rate_days.sf_key and
    route_frequency.sf_key = standard_frequency.sf_key and
    rate_days.rg_code = contract.rg_code and
    contract.contract_no = route_frequency.contract_no and
    route_frequency.contract_no = @inContract and
    route_frequency.rf_active = 'Y' and
    contract_renewals.contract_no = contract.contract_no and
    contract_renewals.contract_seq_number = @inSequence and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date
  --to prevent the deliverydays from being changed if the nMaxDays are >4
  --in order to show correct deliverydays on the report.
  select @nDeliveryDaysForReport=@nDeliveryDays
  if @nMaxdays > 4
    select @nDeliveryDays=@nMaxDeliveryDays
  select @nSumAdjustments=sum(fd_amount_to_pay)
    from frequency_adjustments where
    contract_no = @inContract and
    contract_seq_number = @inSequence and
    fd_paid_to_date is not null
  select @nRouteDistancePerDay=round(@nRouteDistance/@nDeliveryDays,2)
  --New depreciation computation 2001
  -- PBY 26/06/2002 SR#4415 Added nRouteDistance/1000 to VehicleDepreciation
  -- calcuation if REL > 0  
  if @nRemainingEconomicLife > 0
    select @nVehicleDepreciation=(@nRouteDistance/1000)*
      ((1-(isNull(@nSalvageRatio,0)/100))*isNull(@nNominalVehical,0)*1000)/
      @nRemainingEconomicLife
  else
    select @nVehicleDepreciation=@nRouteDistance*(@nVehicalAllow/1000)
  select @nFuelCostPerAnnum=round((@nConsumption/100)*@nRouteDistance*(@nFuel/100),2)
  select @nRepairsPerAnnum=round(@nRouteDistance*(@nRepairsMaint/1000),2)
  select @nTyresTubesPerAnnum=round(@nTyreTubes*(@nRouteDistance/1000),2)
  -- TJB SR4661: Replaced nWageHourlyRate with nDeliveryWageRate and nProcessingWageRate
  select @nDeliveryCost=(round(@nDeliveryHours,2)*52)*@nDeliveryWageRate
  select @nReliefCost=(round(@nDeliveryHours,2)*@nReliefWeeks)*@nDeliveryWageRate+ -- Added:  TJB  SR4661
    round(((((@nContractVolume/@nItemsHour)/365)*7)*@nReliefWeeks)*@nProcessingWageRate,2)
  select @nProcessingCost=round(((((@nContractVolume/@nItemsHour)/365)*7)*52)*@nProcessingWageRate,2)
  select @nPublicLiabilityCost=round(@nPublicLia*(@nDeliveryDays/@nMaxDeliveryDays),2)
  --Benchmark 2001
  select @nACCPerAnnum=round((@nAccRate/100)*(@nDeliveryCost+@nProcessingCost+@nReliefCost),2)+
    isNull(@nACCAmount,0)
  --old
  -- set nVehicleInsurance=nVehicalInsure*(nDeliveryDays/nMaxDeliveryDays);
  --Benchmark 2001
  select @nVehicleInsurance=@nVehicalInsure*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nLiveryPerAnnum=@nRouteDistance*(@nLivery/1000)
  select @nUniformPerAnnum=@nRouteDistance*(@nUniform/1000)
  select @nLicensing=@nLicence*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nCarrierRiskRate=@nCarrierRisk*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nRateofReturnCost=rd.GetRateReturn(@nNominalVehical,@nRateOfReturn,@nSalvageRatio)*
    (@nDeliveryDays/@nMaxDeliveryDays)
  select @nAccounting=round(@nAccounting*(@nDeliveryDays/@nMaxDeliveryDays),2)
  select @nTelephone=round(@nTelephone*(@nDeliveryDays/@nMaxDeliveryDays),2)
  select @nSundries=round(@nSundries*(@nDeliveryDays/@nMaxDeliveryDays),2)
  select @nSundriesK=round(@nSundriesK*(@nRouteDistance/1000),2)
  --det if diesel
  select @nTempint=count(contractor_renewals.contract_no)
    from rd.contractor_renewals,
    rd.contract_vehical,
    rd.vehicle,
    rd.fuel_type where
    contractor_renewals.contract_no = @inContract and
    contractor_renewals.contract_seq_number = @inSequence and
    contractor_renewals.contract_no = contract_vehical.contract_no and
    contractor_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.vehicle_number = vehicle.vehicle_number and
    vehicle.ft_key = fuel_type.ft_key and
    fuel_type.ft_description like 'diesel%' and
    vehicle.vehicle_number = rd.f_GetLatestVehicle(@inContract,@inSequence)
  --and(contract_vehical.cv_vehical_status='A')
  if @@error <> 0 /* <> was < */
    /* Watcom only
    resignal
    */
	RAISERROR('',10,1)
  if @ntempint = 0
    select @nRUC=0.0
  else
    select @nRUC=round(@nRucRate*(@nRouteDistance/1000),2)
  select @nBenchmark=isnull(@nVehicleDepreciation,0)+
    isnull(@nFuelCostPerAnnum,0)+
    isnull(@nRUC,0)+
    isnull(@nAccounting,0)+
    isnull(@nSundries,0)+
    isnull(@nTelephone,0)+
    isnull(@nRepairsPerAnnum,0)+
    isnull(@nTyresTubesPerAnnum,0)+
    isnull(@nDeliveryCost,0)+
    isnull(@nProcessingCost,0)+
    isnull(@nReliefCost,0)+ -- Added:  TJB  SR4661
    isnull(@nPublicLiabilityCost,0)+
    isnull(@nACCPerAnnum,0)+
    isnull(@nVehicleInsurance,0)+
    isnull(@nLicensing,0)+
    isnull(@nCarrierRiskRate,0)+
    isnull(@nSundriesK,0)+
    isnull(@nLiveryPerAnnum,0)+
    isnull(@nUniformPerAnnum,0)
  select @nFinalBenchmark=Round(@nBenchmark+@nRateOfReturnCost,2)
  select @sConTitle=con_title,
    @sRDFile=con_rd_paper_file_text,
    @sRCMFile=con_rcm_paper_file_text
     from contract where
    contract_no = @inContract
  select @nRetainedAllowances=sum(ca_annual_amount)
    from contract_allowance where
    contract_no = @inContract
  select @nRowCount=count(*)
    from piece_rate_supplier
  if @nRowCount > 0
    begin
      open cur_getsupplier
      if @nRowCount >= 1
        begin
          fetch next from cur_getsupplier into @nPRSKey1,
            @sPieceRateSupplier1
          select @nPieceRate1=sum(prd_cost) 
            from piece_rate_delivery join piece_rate_type on piece_rate_delivery.prt_key=piece_rate_type.prt_key where
            contract_no = @inContract and
            prs_key = @nPRSKey1 and
            prd_date between @PRStartDate and @PREndDate
          if @nPieceRate1 is null and @sPieceRateSupplier1 = 'ParcelPost'
            begin
              select @nPieceRate1=rd.f_estParcelPostValue(@inContract,@inSequence,@nRenewalGroup,
                @PRStartDate,@PREndDate,@dStartDate,@dEndDate)
              select @sPieceRateSupplier1='Estimated '+@sPieceRateSupplier1
            end
        end
      if @nRowCount >= 2
        begin
          fetch next from cur_getsupplier into @nPRSKey2,
            @sPieceRateSupplier2
          select @nPieceRate2=sum(prd_cost)  
            from piece_rate_delivery join piece_rate_type on piece_rate_delivery.prt_key=piece_rate_type.prt_key where
            contract_no = @inContract and
            prs_key = @nPRSKey2 and
            prd_date between @PRStartDate and @PREndDate

          if @nPieceRate2 is null and @sPieceRateSupplier2 = 'ParcelPost'
            begin
				print '@nPieceRate2 is null and @sPieceRateSupplier2'                --Jason
              select @nPieceRate2=rd.f_estParcelPostValue(@inContract,@inSequence,@nRenewalGroup,
                @PRStartDate,@PREndDate,@dStartDate,@dEndDate)
              select @sPieceRateSupplier2='Estimated '+@sPieceRateSupplier2
            end
        end
      if @nRowCount >= 3
        begin
          fetch next from cur_getsupplier into @nPRSKey3,
            @sPieceRateSupplier3
          select @nPieceRate3=sum(prd_cost) 
            from piece_rate_delivery join piece_rate_type on piece_rate_delivery.prt_key=piece_rate_type.prt_key where
            contract_no = @inContract and
            prs_key = @nPRSKey3 and
            prd_date between @PRStartDate and @PREndDate
          if @nPieceRate3 is null and @sPieceRateSupplier3 = 'ParcelPost'
            begin
              select @nPieceRate3=rd.f_estParcelPostValue(@inContract,@inSequence,@nRenewalGroup,
                @PRStartDate,@PREndDate,@dStartDate,@dEndDate)
              select @sPieceRateSupplier3='Estimated '+@sPieceRateSupplier3
            end
        end
      if @nRowCount >= 4
        begin
          fetch next from cur_getsupplier into @nPRSKey4,
            @sPieceRateSupplier4
          select @nPieceRate4=sum(prd_cost)
            from piece_rate_delivery join piece_rate_type on piece_rate_delivery.prt_key=piece_rate_type.prt_key where 
            contract_no = @inContract and
            prs_key = @nPRSKey4 and
            prd_date between @PRStartDate and @PREndDate
          if @nPieceRate4 is null and @sPieceRateSupplier4 = 'ParcelPost'
            begin
              select @nPieceRate4=rd.f_estParcelPostValue(@inContract,@inSequence,@nRenewalGroup,
                @PRStartDate,@PREndDate,@dStartDate,@dEndDate)
              select @sPieceRateSupplier4='Estimated '+@sPieceRateSupplier4
            end
        end
      if @nRowCount >= 5
        begin
          fetch next from cur_getsupplier into @nPRSKey5,
            @sPieceRateSupplier5
          select @nPieceRate5=sum(prd_cost)
            from piece_rate_delivery join piece_rate_type on piece_rate_delivery.prt_key=piece_rate_type.prt_key where
            contract_no = @inContract and
            prs_key = @nPRSKey5 and
            prd_date between @PRStartDate and @PREndDate
          if @nPieceRate5 is null and @sPieceRateSupplier5 = 'ParcelPost'
            begin
              select @nPieceRate5=rd.f_estParcelPostValue(@inContract,@inSequence,@nRenewalGroup,
                @PRStartDate,@PREndDate,@dStartDate,@dEndDate)
              select @sPieceRateSupplier5='Estimated '+@sPieceRateSupplier5
            end
        end
      close cur_getsupplier
    end
  select    @inContract	as	 inContract,
    @inSequence	as	    inSequence,
    @sConTitle	as	    sConTitle,
    @sRDFile	as	    sRDFile,
    @sRCMFile	as	    sRCMFile,
    @nNominalVehical	as	    nNominalVehical,
    -- nWageHourlyRate                  -- TJB SR4661		
    @nDeliveryWageRate 	as	    nDeliveryWageRate, -- TJB SR4661
    @nRepairsMaint	as	    nRepairsMaint,
    @nTyreTubes	as	    nTyreTubes,
    @nVehicalAllow	as	    nVehicalAllow,
    @nVehicalInsure	as	    nVehicalInsure,
    @nPublicLia	as	    nPublicLia,
    @nCarrierRisk	as	    nCarrierRisk,
    @nACCRate	as	    nACCRate,
    @nLicence	as	    nLicence,
    @nRateOfReturn	as	    nRateOfReturn,
    @nSalvageRatio	as	    nSalvageRatio,
    @nItemsHour	as	    nItemsHour,
    @nFuel	as	    nFuel,
    @nConsumption	as	    nConsumption,
    @nRouteDistance	as	    nRouteDistance,
    @nDeliveryHours	as	    nDeliveryHours,
    @nProcessingHours	as	    nProcessingHours,
    @nContractVolume	as	    nContractVolume,
    @nDeliveryDays	as	    nDeliveryDays,
    @nMaxDeliveryDays	as	    nMaxDeliveryDays,
    @iNumberCusts	as	    iNumberCusts,
    @nRouteDistancePerDay	as	    nRouteDistancePerDay,
    @nVehicleDepreciation	as	    nVehicleDepreciation,
    @nFuelCostPerAnnum	as	    nFuelCostPerAnnum,
    @nRepairsPerAnnum	as	    nRepairsPerAnnum,
    @nTyresTubesPerAnnum	as	    nTyresTubesPerAnnum,
    @nDeliveryCost	as	    nDeliveryCost,
    @nProcessingCost	as	    nProcessingCost,
    @nPublicLiabilityCost	as	    nPublicLiabilityCost,
    @nACCPerAnnum	as	    nACCPerAnnum,
    @nVehicleInsurance	as	    nVehicleInsurance,
    @nLicensing	as	    nLicensing,
    @nCarrierRiskRate	as	    nCarrierRiskRate,
    @nBenchmark	as	    nBenchmark,
    @nRateOfReturnCost	as	    nRateOfReturnCost,
    @nFinalBenchmark	as	    nFinalBenchmark,
    @nRetainedAllowances	as	    nRetainedAllowances,
    @nCurrentPayment	as	    nCurrentPayment,
    @sPieceRateSupplier1	as	    sPieceRateSupplier1,
    @nPieceRate1	as	    nPieceRate1,
    @sPieceRateSupplier2	as	    sPieceRateSupplier2,
    @nPieceRate2	as	    nPieceRate2,
    @sPieceRateSupplier3	as	    sPieceRateSupplier3,
    @nPieceRate3	as	    nPieceRate3,
    @sPieceRateSupplier4	as	    sPieceRateSupplier4,
    @nPieceRate4	as	    nPieceRate4,
    @sPieceRateSupplier5	as	    sPieceRateSupplier5,
    @nPieceRate5	as	    nPieceRate5,
    @sRenewalGroup	as	    sRenewalGroup,
    @dRenewalDate	as	    dRenewalDate,
    @nAccounting	as	    nAccounting,
    @nTelephone	as	    nTelephone,
    @nSundries	as	    nSundries,
    @nRuc	as	    nRuc,
    @nSundriesK	as	    nSundriesK,
    @nLiveryPerAnnum	as	    nLiveryPerAnnum,
    @nUniformPerAnnum	as	    nUniformPerAnnum,
    @nDeliveryDaysForReport	as	    nDeliveryDaysForReport,
    @nReliefCost 	as	    nReliefCost, -- Added:  TJB  SR4661
    @dStartDate	as	    dStartDate,
    @dEndDate	as	    dEndDate,
    @PRStartDate	as	    PRStartDate,
    @PREndDate	as	    PREndDate,
    @dExpiryDate as   dExpiryDate
end






GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE function [rd].[BenchmarkCalc2005](@inContract int,@inSequence int)
returns real
begin
  -- TJB  SR4703  Sept 2007
  --    Change relief component calculation to 5 weeks (from 4).
  -- TJB  SR4661  May 2005  -  Significant changes
  -- Change delivery and processing cost calculations
  -- Add relief cost calculation and related changes
  -- Split wage rates into separate delivery and processing rates
  -- PBY Modified 28-Feb-2002
  -- Original:
  --    f_GetFuelRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)) as fuel,
  -- Modified to:
  --     isNull(vor.vor_fuel_rate,f_GetFuelRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)) as fuel,
  declare @nNominalVehical numeric(10,2)
  -- declare nWageHourlyRate numeric(10,2);           -- TJB SR4661
  declare @nDeliveryWageRate numeric(10,2)-- TJB SR4661
  declare @nProcessingWageRate numeric(10,2)-- TJB SR4661
  declare @nRepairsMaint numeric(10,2)
  declare @nTyreTubes numeric(10,2)
  declare @nVehicalAllow numeric(10,2)
  declare @nVehicalInsure numeric(10,2)
  declare @nPublicLia numeric(10,2)
  declare @nCarrierRisk numeric(10,2)
  declare @nACCRate numeric(10,2)
  declare @nLicence numeric(10,2)
  declare @nRateOfReturn numeric(10,2)
  declare @nSalvageRatio numeric(10,2)
  declare @nItemsHour numeric(10,2)
  declare @nFuel numeric(10,2)
  declare @nConsumption numeric(10,2)
  declare @dStartDate datetime
  declare @dEndDate datetime
  declare @nNumRows int
  declare @nRouteDistance numeric(10,2)
  declare @nDeliveryHours numeric(10,3)
  declare @nProcessingHours numeric(10,2)
  declare @nVolume numeric(10,2)
  declare @nDeliveryDays numeric(10,2)
  declare @nMaxDeliveryDays numeric(10,2)
  declare @nRouteDistancePerDay real
  declare @nVehicleDepreciation real
  declare @nFuelCostPerAnnum real
  declare @nRepairsPerAnnum real
  declare @nTyresTubesPerAnnum real
  declare @nDeliveryCost real
  declare @nProcessingCost real
  declare @nReliefCost real-- Added:  TJB  SR4661
  declare @nReliefWeeks real                          -- Added:  TJB  SR4703
  declare @nPublicLiabilityCost real
  declare @nACCPerAnnum real
  declare @nBenchmark real
  declare @nVehicleInsurance real
  declare @nLicensing real
  declare @nCarrierRiskRate real
  declare @nRateReturn real
  declare @dEffectDate datetime
  declare @nTempint int
  declare @Tempdec numeric(10,2)
  declare @nRUC numeric(8,2)
  declare @nRUCRate numeric(8,2)
  declare @nAccounting numeric(8,2)
  declare @nTelephone numeric(8,2)
  declare @nSundries numeric(8,2)
  declare @nSundriesK numeric(8,2)
  declare @nRemainingEconomicLife int
  declare @nACCAmount numeric(12,2)
  declare @nInsurancePct numeric(12,2)
  declare @nLivery numeric(12,2)
  declare @nUniform numeric(12,2)
  declare @nLiveryPerAnnum numeric(12,2)
  declare @nUniformPerAnnum numeric(12,2)
  declare @nMaxdays int
  --  declare nACCAmount decimal(12,2);
  select top 1
    @nNominalVehical=isNull(vor.vor_nominal_vehicle_value,vr.vr_nominal_vehicle_value),
    @nRemainingEconomicLife=v.v_remaining_economic_life,
    --    isNull(nvor.nvor_wage_hourly_rate,nvr.nvr_wage_hourly_rate) as wage_rate,                  -- TJB SR4661
    @nDeliveryWageRate=isNull(nvor.nvor_delivery_wage_rate,nvr.nvr_delivery_wage_rate), -- TJB SR4661
    @nProcessingWageRate=isNull(nvor.nvor_processing_wage_rate,nvr.nvr_processing_wage_rate), -- TJB SR4661
    @nRepairsMaint=isNull(vor.vor_repairs_maintenance_rate,vr.vr_repairs_maintenance_rate),
    @nTyreTubes=isNull(vor.vor_tyre_tubes_rate,vr.vr_tyre_tubes_rate),
    @nVehicalAllow=isNull(vor.vor_vehical_allowance_rate,vr.vr_vehicle_allowance_rate),
    @nVehicalInsure=rd.f_GetInsurance(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date), --ins $
    @nPublicLia=isNull(nvor.nvor_public_liability_rate_2,nvr.nvr_public_liability_rate),
    @nCarrierRisk=isNull(nvor.nvor_carrier_risk_rate,nvr.nvr_carrier_risk_rate),
    @nACCRate=isNull(nvor.nvor_acc_rate,nvr.nvr_acc_rate),
    @nACCAmount=isNull(nvor.nvor_acc_rate_amount,nvr.nvr_acc_rate_amount),
    @nLicence=isNull(vor.vor_licence_rate,vr.vr_licence_rate),
    @nRateOfReturn=isNull(vor.vor_vehicle_rate_of_return_pct,vr.vr_vehicle_rate_of_return_pct),
    @nSalvageRatio=isNull(vor.vor_salvage_ratio,vr.vr_salvage_ratio),
    @nItemsHour=isNull(nvor.nvor_item_proc_rate_per_hour,nvr.nvr_item_proc_rate_per_hr),
    @nFuel=isNull(vor.vor_fuel_rate,rd.f_GetFuelRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)),
    @nConsumption=isNull(vor_consumption_rate,rd.f_GetConsumptionRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)),
    @nAccounting=isNull(nvor.nvor_accounting,nvr.nvr_accounting),
    @nTelephone=isNull(nvor.nvor_telephone,nvr.nvr_telephone),
    @nSundries=isNull(nvor.nvor_sundries,nvr.nvr_sundries),
    @nRucrate=isNull(vor.vor_ruc,vr.vr_ruc),
    @nSundriesK=isNull(vor.vor_sundries_k,vr.vr_sundries_k),
    @nInsurancePct=isNull(vr.vr_vehicle_value_insurance_pct,0),
    @nLivery=isNull(vor.vor_livery,vr.vr_livery),
    @nUniform=isNull(nvor_uniform,nvr_uniform),
    @nACCAmount=isNull(nvor.nvor_acc_rate_amount,nvr.nvr_acc_rate_amount)
    from
--!    contract_renewals as cr left outer join non_vehicle_override_rate as nvor  on  cr.contract_no = nvor.contract_no and cr.contract_seq_number = nvor.contract_seq_number,
--!    contract_renewals as cr1 left outer join vehicle_override_rate as vor on cr1.contract_no = vor.contract_no and cr1.contract_seq_number = vor.contract_seq_number,
    contract_renewals as cr left outer join non_vehicle_override_rate as nvor  on  cr.contract_no = nvor.contract_no and cr.contract_seq_number = nvor.contract_seq_number
    left outer join vehicle_override_rate as vor on cr.contract_no = vor.contract_no and cr.contract_seq_number = vor.contract_seq_number,
    contract_vehical as cv,
    vehicle as v,
    contract as c,
    non_vehicle_rate as nvr,
    vehicle_type as vt,
    vehicle_rate as vr
    where

    vt.vt_key = vr.vt_key and
    cv.contract_no = cr.contract_no and
    cv.contract_seq_number = cr.contract_seq_number and
    v.vehicle_number = cv.vehicle_number and
    vt.vt_key = v.vt_key and
    c.contract_no = cr.contract_no and
    v.vehicle_number = rd.f_GetLatestVehicle(cr.contract_no,cr.contract_seq_number) and
    c.rg_code = nvr.rg_code and
    cr.contract_no = @inContract and
    cr.contract_seq_number = @inSequence and
    nvr.nvr_rates_effective_date = cr.con_rates_effective_date and
    vr.vr_rates_effective_date = cr.con_rates_effective_date order by
    vor.vor_effective_date desc
  if @@error <> 0 /* <> was < */
    /* Watcom only
    resignal
    */
return -1
  select @dStartDate=con_start_date
       , @dEffectDate=con_rates_effective_date
    from contract_renewals
   where contract_renewals.contract_no = @inContract and
         contract_renewals.contract_seq_number = @inSequence

  select @dEndDate=con_start_date
    from contract_renewals
   where contract_renewals.contract_no = @inContract and
         contract_renewals.contract_seq_number = @inSequence+1

      -- Added TJB  SR4703  Sep 2007
  if @dEffectDate >= '2007 Oct 31'
    set @nReliefWeeks = 5
  else
    set @nReliefWeeks = 4
    
  select @nNumRows=count(*),
    @nDeliveryDays=rd.GetContractDelDays(contract_renewals.contract_no,contract_renewals.contract_seq_number,contract_renewals.con_rg_code_at_renewal,contract_renewals.con_rates_effective_date),
    @nRouteDistance=contract_renewals.con_distance_at_renewal+sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum),
    @nDeliveryHours=contract_renewals.con_del_hrs_week_at_renewal+sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
    @nProcessingHours=contract_renewals.con_processing_hours_per_week+sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
    @nVolume=contract_renewals.con_volume_at_renewal+sum(isnull(frequency_distances.fd_volume,0))

    from contract_renewals,
    route_frequency left outer join frequency_distances on
    route_frequency.contract_no = frequency_distances.contract_no and
    route_frequency.sf_key = frequency_distances.sf_key and
    route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days and
    frequency_distances.fd_effective_date >= @dStartDate and
    @dStartDate is not null and
    (@dEndDate is null or @dEndDate >= frequency_distances.fd_effective_date),
    rate_days where
    (contract_renewals.contract_no = route_frequency.contract_no) and
    (route_frequency.sf_key = rate_days.sf_key) and
    (contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date) and
    (contract_renewals.con_rg_code_at_renewal = rate_days.rg_code) and
    (contract_renewals.contract_no = @inCOntract) and
    (contract_renewals.contract_seq_number = @inSequence)
    group by contract_renewals.contract_no,
    contract_renewals.contract_seq_number,
    contract_renewals.con_rg_code_at_renewal,
    contract_renewals.con_rates_effective_date,
    contract_renewals.con_distance_at_renewal,
    contract_renewals.con_del_hrs_week_at_renewal,
    contract_renewals.con_processing_hours_per_week,
    contract_renewals.con_volume_at_renewal
  select @nMaxDeliveryDays=max(rate_days.rtd_days_per_annum)
    from contract_renewals join rate_days on
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  --If max days per week>4, assume deldays = maxdeldays
  select @nMaxdays=sum(standard_frequency.sf_days_week)
    from rate_days,
    standard_frequency,
    route_frequency,
    contract,
    contract_renewals where
    standard_frequency.sf_key = rate_days.sf_key and
    route_frequency.sf_key = standard_frequency.sf_key and
    rate_days.rg_code = contract.rg_code and
    contract.contract_no = route_frequency.contract_no and
    route_frequency.contract_no = @inContract and
    route_frequency.rf_active = 'Y' and
    contract_renewals.contract_no = contract.contract_no and
    contract_renewals.contract_seq_number = @inSequence and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date
  if @nMaxdays > 4
    select @nDeliveryDays=@nMaxDeliveryDays
  select @nRouteDistancePerDay=@nRouteDistance/@nDeliveryDays
  --select nRouteDistance*(nVehicalAllow/1000) into nVehicleDepreciation;
  if @nRemainingEconomicLife > 0
    -- PBY 26/06/2002 SR#4415 Added nRouteDistance/1000 to VehicleDepreciation
    -- calcuation if REL > 0
    select @nVehicleDepreciation=(@nRouteDistance/1000)*((1-(isNull(@nSalvageRatio,0)/100))*isNull(@nNominalVehical,0)*1000)/@nRemainingEconomicLife
  else
    select @nVehicleDepreciation=@nRouteDistance*(@nVehicalAllow/1000)
  select @nFuelCostPerAnnum=(@nConsumption/100)*@nRouteDistance*(@nFuel/100)
  select @nRepairsPerAnnum=@nRouteDistance*(@nRepairsMaint/1000)
  select @nTyresTubesPerAnnum=@nTyreTubes*(@nRouteDistance/1000)
  -- TJB SR4661: Changed nWageHourlyRate to nDeliveryWageRate and nProcessingWageRate
  select @nDeliveryCost=((round(@nDeliveryHours,2))*52)*@nDeliveryWageRate
  select @nProcessingCost=((((@nVolume/@nItemsHour)/365)*7)*52)*@nProcessingWageRate
  select @nReliefCost=((round(@nDeliveryHours,2))*@nReliefWeeks)*@nDeliveryWageRate+ -- Added: TJB SR4661
    ((((@nVolume/@nItemsHour)/365)*7)*@nReliefWeeks)*@nProcessingWageRate
  select @nPublicLiabilityCost=@nPublicLia*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nACCPerAnnum=(@nAccRate/100)*(@nDeliveryCost+@nProcessingCost+@nReliefCost)+isNull(@nACCAmount,0)
  --select nVehicalInsure*(nDeliveryDays/nMaxDeliveryDays) into nVehicleInsurance;
  --Benchmark 2001
  --set nVehicleInsurance=nVehicalInsure;
  select @nVehicleInsurance=@nVehicalInsure*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nLiveryPerAnnum=@nRouteDistance*(@nLivery/1000)
  select @nUniformPerAnnum=@nRouteDistance*(@nUniform/1000)
  select @nLicensing=@nLicence*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nCarrierRiskRate=@nCarrierRisk*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nRateReturn=rd.GetRateReturn(@nNominalVehical,@nRateOfReturn,@nSalvageRatio)
  select @nRateReturn=@nRateReturn*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nAccounting=@nAccounting*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nTelephone=@nTelephone*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nSundries=@nSundries*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nTempint=count(contractor_renewals.contract_no)
  from rd.contractor_renewals,
    rd.contract_vehical,
    rd.vehicle,
    rd.fuel_type where
    (contractor_renewals.contract_no = @inContract) and
    (contractor_renewals.contract_seq_number = @inSequence) and
    (contractor_renewals.contract_no = contract_vehical.contract_no) and
    (contractor_renewals.contract_seq_number = contract_vehical.contract_seq_number) and
    (contract_vehical.vehicle_number = vehicle.vehicle_number) and
    (vehicle.ft_key = fuel_type.ft_key) and
    (fuel_type.ft_description like 'diesel%') and
    --and(contract_vehical.cv_vehical_status='A')
    (vehicle.vehicle_number = rd.f_GetLatestVehicle(@inContract,@inSequence))
  if @@error <> 0 /* <> was < */
    /* Watcom only
    resignal
    */
return -1
  if @ntempint = 0
    select @nRUC=0.0
  else
    select @nRUC=@nRUCRate*(@nRouteDistance/1000)
  select @nSundriesK=@nSundriesK*(@nRouteDistance/1000)
  select @nBenchmark=isnull(@nVehicleDepreciation,0)+
         isnull(@nFuelCostPerAnnum,0)+
         isnull(@nRUC,0)+
         isnull(@nAccounting,0)+
         isnull(@nSundries,0)+
         isnull(@nTelephone,0)+
         isnull(@nRepairsPerAnnum,0)+
         isnull(@nTyresTubesPerAnnum,0)+
         isnull(@nDeliveryCost,0)+
         isnull(@nProcessingCost,0)+
         isnull(@nReliefCost,0)+
         isnull(@nPublicLiabilityCost,0)+
         isnull(@nACCPerAnnum,0)+
         isnull(@nVehicleInsurance,0)+
         isnull(@nLicensing,0)+
         isnull(@nCarrierRiskRate,0)+ 
         isnull(@nSundriesK,0)+
         isnull(@nLiveryPerAnnum,0)+
         isnull(@nUniformPerAnnum,0)+ 
         isnull(@nRateReturn,0) 
  select @nBenchmark=Round(@nBenchmark+.49,0)
  return(@nBenchmark)
end


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE function [rd].[BenchmarkCalc2001](@inContract int ,@inSequence int)
RETURNS real
AS
BEGIN
  -- PBY Modified 28-Feb-2002
  -- Original:
  --    f_GetFuelRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)) as fuel,
  -- Modified to:
  --     isNull(vor.vor_fuel_rate,f_GetFuelRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)) as fuel,
  declare @nNominalVehical numeric(10,2)
  declare @nWageHourlyRate numeric(10,2)
  declare @nRepairsMaint numeric(10,2)
  declare @nTyreTubes numeric(10,2)
  declare @nVehicalAllow numeric(10,2)
  declare @nVehicalInsure numeric(10,2)
  declare @nPublicLia numeric(10,2)
  declare @nCarrierRisk numeric(10,2)
  declare @nACCRate numeric(10,2)
  declare @nLicence numeric(10,2)
  declare @nRateOfReturn numeric(10,2)
  declare @nSalvageRatio numeric(10,2)
  declare @nItemsHour numeric(10,2)
  declare @nFuel numeric(10,2)
  declare @nConsumption numeric(10,2)
  declare @dStartDate datetime
  declare @dEndDate datetime
  declare @nNumRows int
  declare @nRouteDistance numeric(10,2)
  declare @nDeliveryHours numeric(10,3)
  declare @nProcessingHours numeric(10,2)
  declare @nVolume numeric(10,2)
  declare @nDeliveryDays numeric(10,2)
  declare @nMaxDeliveryDays numeric(10,2)
  declare @nRouteDistancePerDay real
  declare @nVehicleDepreciation real
  declare @nFuelCostPerAnnum real
  declare @nRepairsPerAnnum real
  declare @nTyresTubesPerAnnum real
  declare @nDeliveryCost real
  declare @nProcessingCost real
  declare @nPublicLiabilityCost real
  declare @nACCPerAnnum real
  declare @nBenchmark real
  declare @nVehicleInsurance real
  declare @nLicensing real
  declare @nCarrierRiskRate real
  declare @nRateReturn real
  declare @nRGCode int
  declare @dEffectDate datetime
  declare @nTempint int
  declare @Tempdec numeric(10,2)
  declare @nRUC numeric(8,2)
  declare @nRUCRate numeric(8,2)
  declare @nAccounting numeric(8,2)
  declare @nTelephone numeric(8,2)
  declare @nSundries numeric(8,2)
  declare @nSundriesK numeric(8,2)
  declare @nRemainingEconomicLife int
  declare @nACCAmount numeric(12,2)
  declare @nInsurancePct numeric(12,2)
  declare @nLivery numeric(12,2)
  declare @nUniform numeric(12,2)
  declare @nLiveryPerAnnum numeric(12,2)
  declare @nUniformPerAnnum numeric(12,2)
  declare @nMaxdays int
  --  declare nACCAmount decimal(12,2);
  select top 1 
    @nNominalVehical=isNull(vor.vor_nominal_vehicle_value,vr.vr_nominal_vehicle_value),
    @nRemainingEconomicLife=v.v_remaining_economic_life,
    @nWageHourlyRate=isNull(nvor.nvor_wage_hourly_rate,nvr.nvr_wage_hourly_rate),
    @nRepairsMaint=isNull(vor.vor_repairs_maintenance_rate,vr.vr_repairs_maintenance_rate),
    @nTyreTubes=isNull(vor.vor_tyre_tubes_rate,vr.vr_tyre_tubes_rate),
    @nVehicalAllow=isNull(vor.vor_vehical_allowance_rate,vr.vr_vehicle_allowance_rate),
    @nVehicalInsure=rd.f_GetInsurance(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date), --ins $
    @nPublicLia=isNull(nvor.nvor_public_liability_rate_2,nvr.nvr_public_liability_rate),
    @nCarrierRisk=isNull(nvor.nvor_carrier_risk_rate,nvr.nvr_carrier_risk_rate),
    @nACCRate=isNull(nvor.nvor_acc_rate,nvr.nvr_acc_rate),
    @nACCAmount=isNull(nvor.nvor_acc_rate_amount,nvr.nvr_acc_rate_amount),
    @nLicence=isNull(vor.vor_licence_rate,vr.vr_licence_rate),
    @nRateOfReturn=isNull(vor.vor_vehicle_rate_of_return_pct,vr.vr_vehicle_rate_of_return_pct),
    @nSalvageRatio=isNull(vor.vor_salvage_ratio,vr.vr_salvage_ratio),
    @nItemsHour=isNull(nvor.nvor_item_proc_rate_per_hour,nvr.nvr_item_proc_rate_per_hr),
    @nFuel=isNull(vor.vor_fuel_rate,rd.f_GetFuelRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)),
    @nConsumption=isNull(vor_consumption_rate,rd.f_GetConsumptionRates(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date)),
    @nAccounting=isNull(nvor.nvor_accounting,nvr.nvr_accounting),
    @nTelephone=isNull(nvor.nvor_telephone,nvr.nvr_telephone),
    @nSundries=isNull(nvor.nvor_sundries,nvr.nvr_sundries),
    @nRucrate=isNull(vor.vor_ruc,vr.vr_ruc),
    @nSundriesK=isNull(vor.vor_sundries_k,vr.vr_sundries_k),
    @nInsurancePct=isNull(vr.vr_vehicle_value_insurance_pct,0),
    @nLivery=isNull(vor.vor_livery,vr.vr_livery),
    @nUniform=isNull(nvor_uniform,nvr_uniform),
    @nACCAmount=isNull(nvor.nvor_acc_rate_amount,nvr.nvr_acc_rate_amount)
    from
--!    contract_renewals as cr left outer join non_vehicle_override_rate as nvor  on  cr.contract_no = nvor.contract_no and cr.contract_seq_number = nvor.contract_seq_number,
--!    contract_renewals as cr1 left outer join vehicle_override_rate as vor on cr1.contract_no = vor.contract_no and cr1.contract_seq_number = vor.contract_seq_number,
    contract_renewals as cr left outer join non_vehicle_override_rate as nvor  on  cr.contract_no = nvor.contract_no and cr.contract_seq_number = nvor.contract_seq_number
    left outer join vehicle_override_rate as vor on cr.contract_no = vor.contract_no and cr.contract_seq_number = vor.contract_seq_number,
    contract_vehical as cv,
    vehicle as v,
    contract as c,
    non_vehicle_rate as nvr,
    vehicle_type as vt,
    vehicle_rate as vr
    where

    vt.vt_key = vr.vt_key and
    cv.contract_no = cr.contract_no and
    cv.contract_seq_number = cr.contract_seq_number and
    v.vehicle_number = cv.vehicle_number and
    vt.vt_key = v.vt_key and
    c.contract_no = cr.contract_no and
    v.vehicle_number = rd.f_GetLatestVehicle(cr.contract_no,cr.contract_seq_number) and
    c.rg_code = nvr.rg_code and
    cr.contract_no = @inContract and
    cr.contract_seq_number = @inSequence and
    nvr.nvr_rates_effective_date = cr.con_rates_effective_date and
    vr.vr_rates_effective_date = cr.con_rates_effective_date order by
    vor.vor_effective_date desc
  if @@error <> 0 /* <> was < */
    /* Watcom only
    resignal
    */
	return -1
  select @dStartDate=con_start_date 
    from contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  select @dEndDate=con_start_date,
    @nRGCode=con_rg_code_at_renewal,
    @dEffectDate=con_rates_effective_date
    from contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence+1
  select @nNumRows=count(*),
    @nDeliveryDays=rd.GetContractDelDays(contract_renewals.contract_no,contract_renewals.contract_seq_number,contract_renewals.con_rg_code_at_renewal,contract_renewals.con_rates_effective_date),
    @nRouteDistance=contract_renewals.con_distance_at_renewal+sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum),
    @nDeliveryHours=contract_renewals.con_del_hrs_week_at_renewal+sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
    @nProcessingHours=contract_renewals.con_processing_hours_per_week+sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
    @nVolume=contract_renewals.con_volume_at_renewal+sum(isnull(frequency_distances.fd_volume,0))
  from contract_renewals,
    route_frequency left outer join
    frequency_distances on
    route_frequency.contract_no = frequency_distances.contract_no and
    route_frequency.sf_key = frequency_distances.sf_key and
    route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days and
    frequency_distances.fd_effective_date >= @dStartDate and
    @dStartDate is not null and
    (@dEndDate is null or
    @dEndDate >= frequency_distances.fd_effective_date),
    rate_days where
    (contract_renewals.contract_no = route_frequency.contract_no) and
    (route_frequency.sf_key = rate_days.sf_key) and
    (contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date) and
    (contract_renewals.con_rg_code_at_renewal = rate_days.rg_code) and
    (contract_renewals.contract_no = @inCOntract) and
    (contract_renewals.contract_seq_number = @inSequence)
    group by contract_renewals.contract_no,
    contract_renewals.contract_seq_number,
    contract_renewals.con_rg_code_at_renewal,
    contract_renewals.con_rates_effective_date,
    contract_renewals.con_distance_at_renewal,
    contract_renewals.con_del_hrs_week_at_renewal,
    contract_renewals.con_processing_hours_per_week,
    contract_renewals.con_volume_at_renewal
  select @nMaxDeliveryDays=max(rate_days.rtd_days_per_annum) 
    from contract_renewals join
    rate_days on
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  --If max days per week>4, assume deldays = maxdeldays
  select @nMaxdays=sum(standard_frequency.sf_days_week)
    from rate_days,
    standard_frequency,
    route_frequency,
    contract,contract_renewals where
    standard_frequency.sf_key = rate_days.sf_key and
    route_frequency.sf_key = standard_frequency.sf_key and
    rate_days.rg_code = contract.rg_code and
    contract.contract_no = route_frequency.contract_no and
    route_frequency.contract_no = @inContract and
    route_frequency.rf_active = 'Y' and
    contract_renewals.contract_no = contract.contract_no and
    contract_renewals.contract_seq_number = @inSequence and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date
  if @nMaxdays > 4
    select @nDeliveryDays=@nMaxDeliveryDays
  select  @nRouteDistancePerDay=@nRouteDistance/@nDeliveryDays 
  --select nRouteDistance*(nVehicalAllow/1000) into nVehicleDepreciation;
  if @nRemainingEconomicLife > 0
    -- PBY 26/06/2002 SR#4415 Added nRouteDistance/1000 to VehicleDepreciation
    -- calcuation if REL > 0
    select @nVehicleDepreciation=(@nRouteDistance/1000)*((1-(isNull(@nSalvageRatio,0)/100))*isNull(@nNominalVehical,0)*1000)/@nRemainingEconomicLife
  else
    select @nVehicleDepreciation=@nRouteDistance*(@nVehicalAllow/1000)
  select @nFuelCostPerAnnum=(@nConsumption/100)*@nRouteDistance*(@nFuel/100)
  select @nRepairsPerAnnum=@nRouteDistance*(@nRepairsMaint/1000) 
  select @nTyresTubesPerAnnum=@nTyreTubes*(@nRouteDistance/1000) 
  select @nDeliveryCost=((round(@nDeliveryHours,2))*56)*@nWageHourlyRate 
  select @nProcessingCost=((((@nVolume/@nItemsHour)/365)*7)*56)*@nWageHourlyRate 
  select @nPublicLiabilityCost=@nPublicLia*(@nDeliveryDays/@nMaxDeliveryDays)
  --select(nAccRate/100)*(nDeliveryCost+nProcessingCost) into nACCPerAnnum;
  --Benchmark 2001
  select @nACCPerAnnum=(@nAccRate/100)*(@nDeliveryCost+@nProcessingCost)+isNull(@nACCAmount,0)
  --select nVehicalInsure*(nDeliveryDays/nMaxDeliveryDays) into nVehicleInsurance;
  --Benchmark 2001
  --set nVehicleInsurance=nVehicalInsure;
  select @nVehicleInsurance=@nVehicalInsure*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nLiveryPerAnnum=@nRouteDistance*(@nLivery/1000)
  select @nUniformPerAnnum=@nRouteDistance*(@nUniform/1000)
  select @nLicensing=@nLicence*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nCarrierRiskRate=@nCarrierRisk*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nRateReturn=rd.GetRateReturn(@nNominalVehical,@nRateOfReturn,@nSalvageRatio) 
  select @nRateReturn=@nRateReturn*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nAccounting=@nAccounting*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nTelephone=@nTelephone*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nSundries=@nSundries*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nTempint=count(contractor_renewals.contract_no) 
    from rd.contractor_renewals,
    rd.contract_vehical,
    rd.vehicle,
    rd.fuel_type where
    (contractor_renewals.contract_no = @inContract) and
    (contractor_renewals.contract_seq_number = @inSequence) and
    (contractor_renewals.contract_no = contract_vehical.contract_no) and
    (contractor_renewals.contract_seq_number = contract_vehical.contract_seq_number) and
    (contract_vehical.vehicle_number = vehicle.vehicle_number) and
    (vehicle.ft_key = fuel_type.ft_key) and
    (fuel_type.ft_description like 'diesel%') and
    --and(contract_vehical.cv_vehical_status='A')
    (vehicle.vehicle_number = rd.f_GetLatestVehicle(@inContract,@inSequence))
  if @@error <> 0 /* <> was < */
    /* Watcom only
    resignal
    */
	return -1
  if @ntempint = 0
    select @nRUC=0.0
  else
    select @nRUC=@nRUCRate*(@nRouteDistance/1000)
  select @nSundriesK=@nSundriesK*(@nRouteDistance/1000)
  select @nBenchmark=isnull(@nVehicleDepreciation,0)+
    isnull(@nFuelCostPerAnnum,0)+
    isnull(@nRepairsPerAnnum,0)+
    isnull(@nTyresTubesPerAnnum,0)+
    isnull(@nDeliveryCost,0)+
    isnull(@nProcessingCost,0)+
    isnull(@nPublicLiabilityCost,0)+
    isnull(@nACCPerAnnum,0)+
    isnull(@nVehicleInsurance,0)+
    isnull(@nLicensing,0)+
    isnull(@nCarrierRiskRate,0)+
    isnull(@nRateReturn,0)+
    isnull(@nRUC,0)+
    isnull(@nTelephone,0)+
    isnull(@nSundries,0)+
    isnull(@nAccounting,0)+
    isnull(@nSundriesK,0)+
    isnull(@nLiveryPerAnnum,0)+
    isnull(@nUniformPerAnnum,0) 
  select @nBenchmark=Round(@nBenchmark+.49,0)
  /*select Round(nBenchmark+.5,0) into nBenchmark;
  insert into t_benchmark(vehicledepreciation,
  fuelcostperannum,repairsperannum,
  tyrestubesperannum,deliverycost,processingcost,
  publicliabilitycost,accperannum,vehicalinsurecost,
  licensingcost,carrierriskamount,rateofreturncost,
  ruccost,telephonecost,sundriescost,accountingcost,
  sundrieskcost,liveryrate,
  uniformrate,benchmark) values(
  ifnull(nVehicleDepreciation,0,nVehicleDepreciation),
  ifnull(nFuelCostPerAnnum,0,nFuelCostPerAnnum),
  ifnull(nRepairsPerAnnum,0,nRepairsPerAnnum),
  ifnull(nTyresTubesPerAnnum,0,nTyresTubesPerAnnum),
  ifnull(nDeliveryCost,0,nDeliveryCost),
  ifnull(nProcessingCost,0,nProcessingCost),
  ifnull(nPublicLiabilityCost,0,nPublicLiabilityCost),
  ifnull(nACCPerAnnum,0,nACCPerAnnum),
  ifnull(nVehicleInsurance,0,nVehicleInsurance),
  ifnull(nLicensing,0,nLicensing),
  ifnull(nCarrierRiskRate,0,nCarrierRiskRate),
  ifnull(nRateReturn,0,nRateReturn),
  ifnull(nRUC,0,nRUC),
  ifnull(nTelephone,0,nTelephone),
  ifnull(nSundries,0,nSundries),
  ifnull(nAccounting,0,nAccounting),
  ifnull(nSundriesK,0,nSundriesK),
  ifnull(nLiveryPerAnnum,0,nLiveryPerAnnum),
  ifnull(nUniformPerAnnum,0,nUniformPerAnnum),
  nbenchmark);*/
  return(@nBenchmark)
--  return(nFuelCostPerAnnum)

END









GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE function [rd].[benchmarkCalcVeh](@inContract int,@inSequence int,@inVehicle int)
RETURNS real
AS
BEGIN
  declare @nNominalVehical numeric(10,2)
  declare @nWageHourlyRate numeric(10,2)
  declare @nRepairsMaint numeric(10,2)
  declare @nTyreTubes numeric(10,2)
  declare @nVehicalAllow numeric(10,2)
  declare @nVehicalInsure numeric(10,2)
  declare @nPublicLia numeric(10,2)
  declare @nCarrierRisk numeric(10,2)
  declare @nACCRate numeric(10,2)
  declare @nLicence numeric(10,2)
  declare @nRateOfReturn numeric(10,2)
  declare @nSalvageRatio numeric(10,2)
  declare @nItemsHour numeric(10,2)
  declare @nFuel numeric(10,2)
  declare @nConsumption numeric(10,2)
  declare @dStartDate datetime
  declare @dEndDate datetime
  declare @nNumRows int
  declare @nRouteDistance numeric(10,2)
  declare @nDeliveryHours numeric(10,3)
  declare @nProcessingHours numeric(10,2)
  declare @nVolume numeric(10,2)
  declare @nDeliveryDays numeric(10,2)
  declare @nMaxDeliveryDays numeric(10,2)
  declare @nRouteDistancePerDay real
  declare @nVehicleDepreciation real
  declare @nFuelCostPerAnnum real
  declare @nRepairsPerAnnum real
  declare @nTyresTubesPerAnnum real
  declare @nDeliveryCost real
  declare @nProcessingCost real
  declare @nPublicLiabilityCost real
  declare @nACCPerAnnum real
  declare @nBenchmark real
  declare @nVehicleInsurance real
  declare @nLicensing real
  declare @nCarrierRiskRate real
  declare @nRateReturn real
  declare @nRGCode int
  declare @dEffectDate datetime
  declare @nTempint int
  declare @Tempdec numeric(10,2)
  declare @nRUC numeric(8,2)
  declare @nRUCRate numeric(8,2)
  declare @nAccounting numeric(8,2)
  declare @nTelephone numeric(8,2)
  declare @nSundries numeric(8,2)
  declare @nSundriesK numeric(8,2)
  declare @nRemainingEconomicLife int
  declare @nACCAmount numeric(12,2)
  declare @nInsurancePct numeric(12,2)
  declare @nLivery numeric(12,2)
  declare @nUniform numeric(12,2)
  declare @nLiveryPerAnnum numeric(12,2)
  declare @nUniformPerAnnum numeric(12,2)
  declare @nMaxdays int
  --  declare nACCAmount decimal(12,2);
  select top 1
    @nNominalVehical=isNull(vor.vor_nominal_vehicle_value,vr.vr_nominal_vehicle_value),
    @nRemainingEconomicLife=v.v_remaining_economic_life,
    @nWageHourlyRate=isNull(nvor.nvor_wage_hourly_rate,nvr.nvr_wage_hourly_rate),
    @nRepairsMaint=isNull(vor.vor_repairs_maintenance_rate,vr.vr_repairs_maintenance_rate),
    @nTyreTubes=isNull(vor.vor_tyre_tubes_rate,vr.vr_tyre_tubes_rate),
    @nVehicalAllow=isNull(vor.vor_vehical_allowance_rate,vr.vr_vehicle_allowance_rate),
    @nVehicalInsure=rd.f_GetInsurance(cr.contract_no,cr.contract_seq_number,cr.con_rates_effective_date), --ins $
    @nPublicLia=isNull(nvor.nvor_public_liability_rate_2,nvr.nvr_public_liability_rate),
    @nCarrierRisk=isNull(nvor.nvor_carrier_risk_rate,nvr.nvr_carrier_risk_rate),
    @nACCRate=isNull(nvor.nvor_acc_rate,nvr.nvr_acc_rate),
    @nACCAmount=isNull(nvor.nvor_acc_rate_amount,nvr.nvr_acc_rate_amount),
    @nLicence=isNull(vor.vor_licence_rate,vr.vr_licence_rate),
    @nRateOfReturn=isNull(vor.vor_vehicle_rate_of_return_pct,vr.vr_vehicle_rate_of_return_pct),
    @nSalvageRatio=isNull(vor.vor_salvage_ratio,vr.vr_salvage_ratio),
    @nItemsHour=isNull(nvor.nvor_item_proc_rate_per_hour,nvr.nvr_item_proc_rate_per_hr),
    @nFuel=isNull(vor.vor_fuel_rate,rd.f_GetConVehFuelRate(@inContract,@inSequence,@inVehicle)),
    @nConsumption=isNull(vor_consumption_rate,rd.f_GetConVehConsumptionRate(@inContract,@inSequence,@inVehicle)),
    @nAccounting=isNull(nvor.nvor_accounting,nvr.nvr_accounting),
    @nTelephone=isNull(nvor.nvor_telephone,nvr.nvr_telephone),
    @nSundries=isNull(nvor.nvor_sundries,nvr.nvr_sundries),
    @nRucrate=isNull(vor.vor_ruc,vr.vr_ruc),
    @nSundriesK=isNull(vor.vor_sundries_k,vr.vr_sundries_k),
    @nInsurancePct=isNull(vr.vr_vehicle_value_insurance_pct,0),
    @nLivery=isNull(vor.vor_livery,vr.vr_livery),
    @nUniform=isNull(nvor_uniform,nvr_uniform),
    @nACCAmount=isNull(nvor.nvor_acc_rate_amount,nvr.nvr_acc_rate_amount) 
    from
--!    contract_renewals as cr left outer join non_vehicle_override_rate as nvor  on  cr.contract_no = nvor.contract_no and cr.contract_seq_number = nvor.contract_seq_number,
--!    contract_renewals as cr1 left outer join vehicle_override_rate as vor on cr1.contract_no = vor.contract_no and cr1.contract_seq_number = vor.contract_seq_number,
    contract_renewals as cr left outer join non_vehicle_override_rate as nvor  on  cr.contract_no = nvor.contract_no and cr.contract_seq_number = nvor.contract_seq_number
    left outer join vehicle_override_rate as vor on cr.contract_no = vor.contract_no and cr.contract_seq_number = vor.contract_seq_number,
    contract_vehical as cv,
    vehicle as v,
    contract as c,
    non_vehicle_rate as nvr,
    vehicle_type as vt,
    vehicle_rate as vr
    where

    vt.vt_key = vr.vt_key and
    cv.contract_no = cr.contract_no and
    cv.contract_seq_number = cr.contract_seq_number and
    v.vehicle_number = cv.vehicle_number and
    vt.vt_key = v.vt_key and
    c.contract_no = cr.contract_no and
    v.vehicle_number = rd.f_GetLatestVehicle(cr.contract_no,cr.contract_seq_number) and
    c.rg_code = nvr.rg_code and
    cr.contract_no = @inContract and
    cr.contract_seq_number = @inSequence and
    nvr.nvr_rates_effective_date = cr.con_rates_effective_date and
    vr.vr_rates_effective_date = cr.con_rates_effective_date order by
    vor.vor_effective_date desc
  if @@error <> 0 /* <> was < */
    /* Watcom only
    resignal
    */
	return -1
  select @dStartDate=con_start_date 
    from contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  select @dEndDate=con_start_date,
    @nRGCode=con_rg_code_at_renewal,
    @dEffectDate=con_rates_effective_date
  from contract_renewals where
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence+1
  select @nNumRows=count(*),
    @nDeliveryDays=rd.GetContractDelDays(contract_renewals.contract_no,contract_renewals.contract_seq_number,contract_renewals.con_rg_code_at_renewal,contract_renewals.con_rates_effective_date),
    @nRouteDistance=contract_renewals.con_distance_at_renewal+sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum),
    @nDeliveryHours=contract_renewals.con_del_hrs_week_at_renewal+sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
    @nProcessingHours=contract_renewals.con_processing_hours_per_week+sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
    @nVolume=contract_renewals.con_volume_at_renewal+sum(isnull(frequency_distances.fd_volume,0))
  from contract_renewals,
    route_frequency left outer join frequency_distances on
    route_frequency.contract_no = frequency_distances.contract_no and
    route_frequency.sf_key = frequency_distances.sf_key and
    route_frequency.rf_delivery_days = frequency_distances.rf_delivery_days and
    frequency_distances.fd_effective_date >= @dStartDate and
    @dStartDate is not null and
    (@dEndDate is null or @dEndDate >= frequency_distances.fd_effective_date),
    rate_days where
    contract_renewals.contract_no = route_frequency.contract_no and
    route_frequency.sf_key = rate_days.sf_key and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
    group by contract_renewals.contract_no,
    contract_renewals.contract_seq_number,
    contract_renewals.con_rg_code_at_renewal,
    contract_renewals.con_rates_effective_date,
    contract_renewals.con_distance_at_renewal,
    contract_renewals.con_del_hrs_week_at_renewal,
    contract_renewals.con_processing_hours_per_week,
    contract_renewals.con_volume_at_renewal
  select @nMaxDeliveryDays=max(rate_days.rtd_days_per_annum) 
    from contract_renewals join rate_days on
    contract_renewals.con_rg_code_at_renewal = rate_days.rg_code and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date and
    contract_renewals.contract_no = @inContract and
    contract_renewals.contract_seq_number = @inSequence
  --If max days per week>4, assume deldays = maxdeldays
  select @nMaxdays=sum(standard_frequency.sf_days_week) 
    from rate_days,
    standard_frequency,
    route_frequency,
    contract,contract_renewals where
    standard_frequency.sf_key = rate_days.sf_key and
    route_frequency.sf_key = standard_frequency.sf_key and
    rate_days.rg_code = contract.rg_code and
    contract.contract_no = route_frequency.contract_no and
    route_frequency.contract_no = @inContract and
    route_frequency.rf_active = 'Y' and
    contract_renewals.contract_no = contract.contract_no and
    contract_renewals.contract_seq_number = @inSequence and
    contract_renewals.con_rates_effective_date = rate_days.rr_rates_effective_date
  if @nMaxdays > 4
    select @nDeliveryDays=@nMaxDeliveryDays
  select @nRouteDistancePerDay=@nRouteDistance/@nDeliveryDays 
  --select nRouteDistance*(nVehicalAllow/1000) into nVehicleDepreciation;
  if @nRemainingEconomicLife > 0
    -- PBY 26/06/2002 SR#4415 Added nRouteDistance/1000 to VehicleDepreciation
    -- calcuation if REL > 0
    select @nVehicleDepreciation=(@nRouteDistance/1000)*((1-(isNull(@nSalvageRatio,0)/100))*isNull(@nNominalVehical,0)*1000)/@nRemainingEconomicLife
  else
    select @nVehicleDepreciation=@nRouteDistance*(@nVehicalAllow/1000)
  select @nFuelCostPerAnnum=(@nConsumption/100)*@nRouteDistance*(@nFuel/100)
  select @nRepairsPerAnnum=@nRouteDistance*(@nRepairsMaint/1000) 
  select @nTyresTubesPerAnnum=@nTyreTubes*(@nRouteDistance/1000) 
  select @nDeliveryCost=((round(@nDeliveryHours,2))*56)*@nWageHourlyRate 
  select @nProcessingCost=((((@nVolume/@nItemsHour)/365)*7)*56)*@nWageHourlyRate 
  select @nPublicLiabilityCost=@nPublicLia*(@nDeliveryDays/@nMaxDeliveryDays) 
  --select(nAccRate/100)*(nDeliveryCost+nProcessingCost) into nACCPerAnnum;
   --Benchmark 2001
  select @nACCPerAnnum=(@nAccRate/100)*(@nDeliveryCost+@nProcessingCost)+isNull(@nACCAmount,0)
  --select nVehicalInsure*(nDeliveryDays/nMaxDeliveryDays) into nVehicleInsurance;
  --Benchmark 2001
  --set nVehicleInsurance=nVehicalInsure;
  select @nVehicleInsurance=@nVehicalInsure*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nLiveryPerAnnum=@nRouteDistance*(@nLivery/1000)
  select @nUniformPerAnnum=@nRouteDistance*(@nUniform/1000)
  select @nLicensing=@nLicence*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nCarrierRiskRate=@nCarrierRisk*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nRateReturn=rd.GetRateReturn(@nNominalVehical,@nRateOfReturn,@nSalvageRatio) 
  select @nRateReturn=@nRateReturn*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nAccounting=@nAccounting*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nTelephone=@nTelephone*(@nDeliveryDays/@nMaxDeliveryDays)
  select @nSundries=@nSundries*(@nDeliveryDays/@nMaxDeliveryDays) 
  select @nTempint=count(contractor_renewals.contract_no) 
    from rd.contractor_renewals,
    rd.contract_vehical,
    rd.vehicle,
    rd.fuel_type where
    contractor_renewals.contract_no = @inContract and
    contractor_renewals.contract_seq_number = @inSequence and
    contractor_renewals.contract_no = contract_vehical.contract_no and
    contractor_renewals.contract_seq_number = contract_vehical.contract_seq_number and
    contract_vehical.vehicle_number = vehicle.vehicle_number and
    vehicle.ft_key = fuel_type.ft_key and
    fuel_type.ft_description like 'diesel%' and
    --and(contract_vehical.cv_vehical_status='A')
    --vehicle.vehicle_number = f_GetLatestVehicle(inContract,inSequence);
    vehicle.vehicle_number = @inVehicle
  if @@error <> 0 /* <> was < */
    /* Watcom only
    resignal
    */
	return -1
  if @ntempint = 0
    select @nRUC=0.0
  else
    select @nRUC=@nRUCRate*(@nRouteDistance/1000)
 select @nSundriesK=@nSundriesK*(@nRouteDistance/1000)
  select @nBenchmark=isnull(@nVehicleDepreciation,0)+
    isnull(@nFuelCostPerAnnum,0)+
    isnull(@nRepairsPerAnnum,0)+
    isnull(@nTyresTubesPerAnnum,0)+
    isnull(@nDeliveryCost,0)+
    isnull(@nProcessingCost,0)+
    isnull(@nPublicLiabilityCost,0)+
    isnull(@nACCPerAnnum,0)+
    isnull(@nVehicleInsurance,0)+
    isnull(@nLicensing,0)+
    isnull(@nCarrierRiskRate,0)+
    isnull(@nRateReturn,0)+
    isnull(@nRUC,0)+
    isnull(@nTelephone,0)+
    isnull(@nSundries,0)+
    isnull(@nAccounting,0)+
    isnull(@nSundriesK,0)+
    isnull(@nLiveryPerAnnum,0)+
    isnull(@nUniformPerAnnum,0) 
  select @nBenchmark=Round(@nBenchmark+.49,0)
  return(@nBenchmark)

END







GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE procedure [rd].[sp_GetExtnData2005](@in_contract int)
--    hourly_wage numeric(10,2),            -- TJB SR4661 May 2005
-- Name changed
as -- TJB SR4661 May 2005: added
begin
  declare @nRemainingEconomicLife int
  --  declare nWageHourlyRate numeric(10,2);              -- TJB SR4661 May 2005
  declare @nDeliveryWageRate numeric(10,2) -- New name
  declare @nProcessingWageRate numeric(10,2) -- Added
  declare @nRepairsMaint numeric(10,2)
  declare @nTyreTubes numeric(10,2)
  declare @nVehicalAllow numeric(10,2)
  declare @nACCRate numeric(10,2)
  declare @nACCRate2 numeric(10,2)
  declare @nItemsHour numeric(10,2)
  declare @nRUC numeric(8,2)
  declare @nFuel numeric(10,2)
  declare @nConsumption numeric(10,2)
  declare @dStartDate datetime
  declare @nSequenceNo int
  declare @nCounter int
  declare @nDepreciation2 numeric(10,2)
  declare @nNominalVehical numeric(10,2)
  declare @nSalvageRatio numeric(10,2)
  --new 2001
  declare @nInsurancePct numeric(10,2)
  declare @nACCAmount numeric(10,2)
  declare @nLivery numeric(10,2)
  declare @nUniform numeric(10,2)
  -- TWC - 08/08/2003 new for call 4546
  declare @nUse_rucs int
  declare @nVehicle int
  declare @nFt_key int
  --Get contract start and end
  select @dStartDate=con_start_date,@nSequenceNo=contract_seq_number 
  from contract_renewals
  where contract_renewals.contract_no = @in_Contract and
    contract_renewals.contract_seq_number = 
    (select max(contract_seq_number) from
      contract_renewals where
      contract_no = @in_Contract)

  -- TWC 08/08/2003 - get the vehicle fuel type if is deisel - set nUse_rucs to 1
  select @nFt_key=ft_key   from vehicle where
    vehicle_number = rd.f_GetLatestVehicle(@in_Contract,@nSequenceNo)
  -- 4 is the key for diesel
  select @nUse_rucs=0
  if @nFt_key = 4
    select @nUse_rucs=1
  --Get basic rates
  --    non_vehicle_rate.nvr_wage_hourly_rate as wage_rate,               -- TJB  SR4661  May 2005
  select @nDeliveryWageRate=non_vehicle_rate.nvr_delivery_wage_rate, -- Changed from single value 
    @nProcessingWageRate=non_vehicle_rate.nvr_processing_wage_rate, -- to two
    @nRepairsMaint=vehicle_rate.vr_repairs_maintenance_rate,
    @nTyreTubes=vehicle_rate.vr_tyre_tubes_rate,
    @nVehicalAllow=vehicle_rate.vr_vehicle_allowance_rate,
    @nACCRate2=non_vehicle_rate.nvr_acc_rate,
    @nItemsHour=non_vehicle_rate.nvr_item_proc_rate_per_hr,
    @nFuel=rd.f_GetFuelRates(contract_vehical.contract_no,contract_renewals.contract_seq_number,contract_renewals.con_rates_effective_date),
    @nConsumption=rd.f_GetConsumptionRates(contract_vehical.contract_no,contract_renewals.contract_seq_number,contract_renewals.con_rates_effective_date),
    @nRuc=vehicle_rate.vr_ruc,
    @nInsurancePct=vehicle_rate.vr_vehicle_value_insurance_pct,
    @nLivery=vehicle_rate.vr_livery,
    @nUniform=non_vehicle_rate.nvr_uniform,
    @nACCAmount=non_vehicle_rate.nvr_acc_rate_amount,
    @nRemainingEconomicLife=vehicle.v_remaining_economic_life,
    @nNominalVehical=vehicle_rate.vr_nominal_vehicle_value,
    @nSalvageRatio=vehicle_rate.vr_salvage_ratio 
  from contract,
    contract_renewals,
    contract_vehical,
    vehicle_type,
    vehicle,
    vehicle_rate,
    non_vehicle_rate 
  where
    contract_vehical.contract_no = contract_renewals.contract_no and
    contract_vehical.contract_seq_number = contract_renewals.contract_seq_number and
    contract_renewals.contract_no = contract.contract_no and
    vehicle.vt_key = vehicle_type.vt_key and
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    vehicle_rate.vt_key = vehicle_type.vt_key and
    contract.rg_code = non_vehicle_rate.rg_code and
    non_vehicle_rate.nvr_rates_effective_date = contract_renewals.con_rates_effective_date and
    vehicle_rate.vr_rates_effective_date = contract_renewals.con_rates_effective_date and
    contract_vehical.vehicle_number =rd.f_GetLatestVehicle(contract.contract_no,contract_renewals.contract_seq_number) and
    contract.contract_no = @in_contract and
    contract_renewals.contract_seq_number = @nSequenceNo
  --get override rates
  
  select top 1
    --    isNull(non_vehicle_override_rate.nvor_wage_hourly_rate,nWageHourlyRate) as wage_rate,     -- TJB  SR4661  May 2001: split wage rate into two
    @nDeliveryWageRate=isNull(non_vehicle_override_rate.nvor_delivery_wage_rate,@nDeliveryWageRate),
    @nProcessingWageRate=isNull(non_vehicle_override_rate.nvor_processing_wage_rate,@nProcessingWageRate),
    @nRepairsMaint=isNull(vehicle_override_rate.vor_repairs_maintenance_rate,@nRepairsMaint),
    @nTyreTubes=isNull(vehicle_override_rate.vor_tyre_tubes_rate,@nTyreTubes),
    @nVehicalAllow=isNull(vehicle_override_rate.vor_vehical_allowance_rate,@nVehicalAllow),
    @nACCRate=isNull(non_vehicle_override_rate.nvor_acc_rate,@nACCRate2),
    @nItemsHour=isNull(non_vehicle_override_rate.nvor_item_proc_rate_per_hour,@nItemsHour),
    @nFuel=isNull(vehicle_override_rate.vor_fuel_rate,@nFuel),
    @nConsumption=isNull(vehicle_override_rate.vor_consumption_rate,@nConsumption),
    @nRuc=isNull(vehicle_override_rate.vor_ruc,@nRuc),
    @nInsurancePct=@nInsurancePct,
    @nLivery=isNull(vehicle_override_rate.vor_livery,@nLivery),
    @nUniform=isNull(non_vehicle_override_rate.nvor_uniform,@nUniform),
    @nACCAmount=isNull(non_vehicle_override_rate.nvor_acc_rate_amount,@nACCAmount),
    @nNominalVehical=isNull(vehicle_override_rate.vor_nominal_vehicle_value,@nNominalVehical),
    @nSalvageRatio=isNull(vehicle_override_rate.vor_salvage_ratio,@nSalvageRatio)
   from contract_renewals 
    left outer join vehicle_override_rate on
    contract_renewals.contract_no = vehicle_override_rate.contract_no and
    contract_renewals.contract_seq_number = vehicle_override_rate.contract_seq_number
   left outer join non_vehicle_override_rate on
    contract_renewals.contract_no = non_vehicle_override_rate.contract_no and
    contract_renewals.contract_seq_number = non_vehicle_override_rate.contract_seq_number 
    join  contract on contract_renewals.contract_no=contract.contract_no
  where
    contract_renewals.contract_no = contract.contract_no and
    contract.contract_no = @in_contract
     and contract_renewals.contract_seq_number = @nSequenceNo
    order by
    vor_effective_date desc

  --compute depreciation2 (only if there is remaining economic life)
  --Depreciation
  if @nRemainingEconomicLife > 0
    select @nDepreciation2=((1-(isNull(@nSalvageRatio,0)/100))*isNull(@nNominalVehical,0)*1000)/@nRemainingEconomicLife
  else
    select @nDepreciation2=0
  --////////////
  select @nCounter=count(*)  
    from frequency_distances where
    contract_no = @in_contract and
    frequency_distances.fd_effective_date >= @dStartDate and
    @dStartDate is not null
  --FD stuff
  
  
  if @nCounter > 0
    select top 1 contract.contract_no,
      contract.con_title,
      num_rows=count(*),
      distance=(sum(isnull(contract_renewals.con_distance_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum),
      boxes=(sum(isnull(contract_renewals.con_no_customers_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_of_boxes,0)),
      rural_bags=(sum(isnull(contract_renewals.con_no_rural_private_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_rural_bags,0)),
      other_bags=(sum(isnull(contract_renewals.con_no_other_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_other_bags,0)),
      private_bags=(sum(isnull(contract_renewals.con_no_private_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_private_bags,0)),
      post_offices=(sum(isnull(contract_renewals.con_no_post_offices_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_post_offices,0)),
      no_cmbs=(sum(isnull(contract_renewals.con_no_cmbs_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_cmbs,0)),
      no_cmb_customers=(sum(isnull(contract_renewals.con_no_cmb_custs_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_cmb_customers,0)),
      del_hrs=(sum(isnull(contract_renewals.con_del_hrs_week_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
      proc_hrs=(sum(isnull(contract_renewals.con_processing_hours_per_week,0))/count(*))+
      sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
      mail_volume=(sum(isnull(contract_renewals.con_volume_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_volume,0)),
      extn_effective_date=rd.today(),
      extn_distance=0,
      extn_boxes=0,
      extn_rural_bags=0,
      extn_other_bags=0,
      extn_private_bags=0,
      extn_post_offices=0,
      extn_no_cmbs=0,
      extn_no_cmb_customers=0,
      extn_del_hrs=0,
      extn_proc_hrs=0,
      extn_mail_volume=0,
      extn_reason=space(250),
      no_del_days_year=0,
      --      isNull(nWageHourlyRate,0),      -- TJB  SR4661  May 2005
      isNull(@nDeliveryWageRate,0), -- Return Delivery rate in this position (processing rate below)
      repairsmaint=isNull(@nRepairsMaint,0),
      typestube=isNull(@nTyreTubes,0),
      vehicalallow=isNull(@nVehicalAllow,0),
      accrate=isNull(@nACCRate,0),
      rr_item_proc_rate_per_hr=isNull(@nItemsHour,0),
      nFuel=isNull(@nFuel,0),
      consumptionrate=isNull(@nConsumption,0),
      extnamount=0,
      @nRUC,
      --new 2001
      nInsurancePct=isNull(@nInsurancePct,0),
      nLivery=isNull(@nLivery,0),
      nUniform=isNull(@nUniform,0),
      nACCAmount=isNull(@nACCAmount,0),
      @nDepreciation2,
      use_rucs=@nUse_rucs,
      isNull(@nProcessingWageRate,0)
    from -- TJB  SR4661  May 2005: add processing wage rate 
      contract 
      join contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number 
      join frequency_distances on
      (contract_renewals.contract_no = frequency_distances.contract_no and
      frequency_distances.fd_effective_date >= @dStartDate and
      @dStartDate is not null)--,0), 
      join standard_frequency on
      frequency_distances.sf_key = standard_frequency.sf_key
      join  rate_days on
      standard_frequency.sf_key = rate_days.sf_key 
    where
      contract.contract_no = @in_contract and
      rate_days.rg_code = contract_renewals.con_rg_code_at_renewal and
      rate_days.rr_rates_effective_date = contract_renewals.con_rates_effective_date
      group by contract.contract_no,contract.con_title--,rr_item_proc_rate_per_hr 
  else
    select top 1
      contract.contract_no,
      contract.con_title,
      1,
      isnull(contract_renewals.con_distance_at_renewal,0),
      isnull(contract_renewals.con_no_customers_at_renewal,0),
      isnull(contract_renewals.con_no_rural_private_bags_at_renewal,0),
      isnull(contract_renewals.con_no_other_bags_at_renewal,0),
      isnull(contract_renewals.con_no_private_bags_at_renewal,0),
      isnull(contract_renewals.con_no_post_offices_at_renewal,0),
      isnull(contract_renewals.con_no_cmbs_at_renewal,0),
      isnull(contract_renewals.con_no_cmb_custs_at_renewal,0),
      isnull(contract_renewals.con_del_hrs_week_at_renewal,0),
      isnull(contract_renewals.con_processing_hours_per_week,0),
      isnull(contract_renewals.con_volume_at_renewal,0),
      extn_effective_date=rd.today(),
      extn_distance=0,
      extn_boxes=0,
      extn_rural_bags=0,
      extn_other_bags=0,
      extn_private_bags=0,
      extn_post_offices=0,
      extn_no_cmbs=0,
      extn_no_cmb_customers=0,
      extn_del_hrs=0,
      extn_proc_hrs=0,
      extn_mail_volume=0,
      extn_reason=space(250),
      no_del_days_year=0,
      --      isNull(nWageHourlyRate,0),      -- TJB  SR4661  May 2005
      isNull(@nDeliveryWageRate,0), -- Return Delivery rate in this position (processing rate below)
      isNull(@nRepairsMaint,0),
      isNull(@nTyreTubes,0),
      isNull(@nVehicalAllow,0),
      isNull(@nACCRate,0),
      rr_item_proc_rate_per_hr=isNull(@nItemsHour,0),
      isNull(@nFuel,0),
      isNull(@nConsumption,0),
      0,
      nRUC=isNull(@nRUC,0),
      --New 2001
      nInsurancePct=isNull(@nInsurancePct,0),
      nLivery=isNull(@nLivery,0),
      nUniform=isNull(@nUniform,0),
      nACCAmount=isNull(@nACCAmount,0),
      @nDepreciation2,
      use_rucs=@nUse_rucs,
      isNull(@nProcessingWageRate,0) from -- TJB  SR4661  May 2005: add processing wage rate 
      contract join
      contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number where
      contract.contract_no = @in_contract
end



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

--
-- Definition for stored procedure sp_GetExtnData2001b : 
--

CREATE procedure [rd].[sp_GetExtnData2001b](@in_contract int)
as
begin
  declare @nRemainingEconomicLife int
  declare @nWageHourlyRate numeric(10,2)
  declare @nRepairsMaint numeric(10,2)
  declare @nTyreTubes numeric(10,2)
  declare @nVehicalAllow numeric(10,2)
  declare @nACCRate numeric(10,2)
  declare @nACCRate2 numeric(10,2)
  declare @nItemsHour numeric(10,2)
  declare @nRUC numeric(8,2)
  declare @nFuel numeric(10,2)
  declare @nConsumption numeric(10,2)
  declare @dStartDate datetime
  declare @nSequenceNo int
  declare @nCounter int
  declare @nDepreciation2 numeric(10,2)
  declare @nNominalVehical numeric(10,2)
  declare @nSalvageRatio numeric(10,2)
  --new 2001
  declare @nInsurancePct numeric(10,2)
  declare @nACCAmount numeric(10,2)
  declare @nLivery numeric(10,2)
  declare @nUniform numeric(10,2)
  -- TWC - 08/08/2003 new for call 4546
  declare @nUse_rucs int
  declare @nVehicle int
  declare @nFt_key int
  --Get contract start and end
  select @dStartDate=con_start_date,@nSequenceNo=contract_seq_number from contract_renewals where
    contract_renewals.contract_no = @in_Contract and
    contract_renewals.contract_seq_number = (select max(contract_seq_number) from
      contract_renewals where
      contract_no = @in_Contract)
  -- TWC 08/08/2003 - get the vehicle fuel type if is deisel - set nUse_rucs to 1
  select @nFt_key=ft_key  from vehicle 
  where vehicle_number = rd.f_GetLatestVehicle(@in_Contract,@nSequenceNo)
  -- 4 is the key for diesel
  select @nUse_rucs=0
  if @nFt_key = 4
    select @nUse_rucs=1
  --Get basic rates
  select @nWageHourlyRate=non_vehicle_rate.nvr_wage_hourly_rate,
    @nRepairsMaint=vehicle_rate.vr_repairs_maintenance_rate,
    @nTyreTubes=vehicle_rate.vr_tyre_tubes_rate,
    @nVehicalAllow=vehicle_rate.vr_vehicle_allowance_rate,
    @nACCRate2=non_vehicle_rate.nvr_acc_rate,
    @nItemsHour=non_vehicle_rate.nvr_item_proc_rate_per_hr,
    @nFuel=rd.f_GetFuelRates(contract_vehical.contract_no,contract_renewals.contract_seq_number,contract_renewals.con_rates_effective_date),
    @nConsumption=rd.f_GetConsumptionRates(contract_vehical.contract_no,contract_renewals.contract_seq_number,contract_renewals.con_rates_effective_date),
    @nRuc=vehicle_rate.vr_ruc,
    @nInsurancePct=vehicle_rate.vr_vehicle_value_insurance_pct,
    @nLivery=vehicle_rate.vr_livery,
    @nUniform=non_vehicle_rate.nvr_uniform,
    @nACCAmount=non_vehicle_rate.nvr_acc_rate_amount,
    @nRemainingEconomicLife=vehicle.v_remaining_economic_life,
    @nNominalVehical=vehicle_rate.vr_nominal_vehicle_value,
    @nSalvageRatio=vehicle_rate.vr_salvage_ratio
  from contract,
    contract_renewals,
    contract_vehical,
    vehicle_type,
    vehicle,
    vehicle_rate,
    non_vehicle_rate 
  where
    contract_vehical.contract_no = contract_renewals.contract_no and
    contract_vehical.contract_seq_number = contract_renewals.contract_seq_number and
    contract_renewals.contract_no = contract.contract_no and
    vehicle.vt_key = vehicle_type.vt_key and
    vehicle.vehicle_number = contract_vehical.vehicle_number and
    vehicle_rate.vt_key = vehicle_type.vt_key and
    contract.rg_code = non_vehicle_rate.rg_code and
    non_vehicle_rate.nvr_rates_effective_date = contract_renewals.con_rates_effective_date and
    vehicle_rate.vr_rates_effective_date = contract_renewals.con_rates_effective_date and
    contract_vehical.vehicle_number = rd.f_GetLatestVehicle(contract.contract_no,contract_renewals.contract_seq_number) and
    contract.contract_no = @in_contract and
    contract_renewals.contract_seq_number = @nSequenceNo
  --get override rates    
  select top 1 @nWageHourlyRate=isNull(non_vehicle_override_rate.nvor_wage_hourly_rate,@nWageHourlyRate),
    @nRepairsMaint=isNull(vehicle_override_rate.vor_repairs_maintenance_rate,@nRepairsMaint),
    @nTyreTubes=isNull(vehicle_override_rate.vor_tyre_tubes_rate,@nTyreTubes),
    @nVehicalAllow=isNull(vehicle_override_rate.vor_vehical_allowance_rate,@nVehicalAllow),
    @nACCRate=isNull(non_vehicle_override_rate.nvor_acc_rate,@nACCRate2),
    @nItemsHour=isNull(non_vehicle_override_rate.nvor_item_proc_rate_per_hour,@nItemsHour),
    @nFuel=isNull(vehicle_override_rate.vor_fuel_rate,@nFuel),
    @nConsumption=isNull(vehicle_override_rate.vor_consumption_rate,@nConsumption),
    @nRuc=isNull(vehicle_override_rate.vor_ruc,@nRuc),
    @nInsurancePct=@nInsurancePct,
    @nLivery=isNull(vehicle_override_rate.vor_livery,@nLivery),
    @nUniform=isNull(non_vehicle_override_rate.nvor_uniform,@nUniform),
    @nACCAmount=isNull(non_vehicle_override_rate.nvor_acc_rate_amount,@nACCAmount),
    @nNominalVehical=isNull(vehicle_override_rate.vor_nominal_vehicle_value,@nNominalVehical),
    @nSalvageRatio=isNull(vehicle_override_rate.vor_salvage_ratio,@nSalvageRatio)
from contract_renewals 
    left outer join vehicle_override_rate on
    contract_renewals.contract_no = vehicle_override_rate.contract_no and
    contract_renewals.contract_seq_number = vehicle_override_rate.contract_seq_number
    left outer join non_vehicle_override_rate on
    contract_renewals.contract_no = non_vehicle_override_rate.contract_no and
    contract_renewals.contract_seq_number = non_vehicle_override_rate.contract_seq_number
    join contract on contract_renewals.contract_no=contract.contract_no where
    contract_renewals.contract_no = contract.contract_no and
    contract.contract_no = @in_contract and
    contract_renewals.contract_seq_number = @nSequenceNo order by
    vor_effective_date desc
  --compute depreciation2 (only if there is remaining economic life)
  --Depreciation
  if @nRemainingEconomicLife > 0
    select @nDepreciation2=((1-(isNull(@nSalvageRatio,0)/100))*isNull(@nNominalVehical,0)*1000)/@nRemainingEconomicLife
  else
    select @nDepreciation2=0
  --//////////    
  --
  select @nCounter=count(*) from frequency_distances 
  where contract_no = @in_contract and
    frequency_distances.fd_effective_date >= @dStartDate and
    @dStartDate is not null
  --FD stuff
  if @nCounter > 0
    select top 1 contract.contract_no,
      contract.con_title,
      num_rows=count(*),
      distance=(sum(isnull(contract_renewals.con_distance_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum),
      boxes=(sum(isnull(contract_renewals.con_no_customers_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_of_boxes,0)),
      rural_bags=(sum(isnull(contract_renewals.con_no_rural_private_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_rural_bags,0)),
      other_bags=(sum(isnull(contract_renewals.con_no_other_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_other_bags,0)),
      private_bags=(sum(isnull(contract_renewals.con_no_private_bags_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_private_bags,0)),
      post_offices=(sum(isnull(contract_renewals.con_no_post_offices_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_post_offices,0)),
      no_cmbs=(sum(isnull(contract_renewals.con_no_cmbs_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_cmbs,0)),
      no_cmb_customers=(sum(isnull(contract_renewals.con_no_cmb_custs_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_no_cmb_customers,0)),
      del_hrs=(sum(isnull(contract_renewals.con_del_hrs_week_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0)),
      proc_hrs=(sum(isnull(contract_renewals.con_processing_hours_per_week,0))/count(*))+
      sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
      mail_volume=(sum(isnull(contract_renewals.con_volume_at_renewal,0))/count(*))+
      sum(isnull(frequency_distances.fd_volume,0)),
      extn_effective_date=rd.today(),
      extn_distance=0,
      extn_boxes=0,
      extn_rural_bags=0,
      extn_other_bags=0,
      extn_private_bags=0,
      extn_post_offices=0,
      extn_no_cmbs=0,
      extn_no_cmb_customers=0,
      extn_del_hrs=0,
      extn_proc_hrs=0,
      extn_mail_volume=0,
      extn_reason=space(250),
      no_del_days_year=0,
      hourly_wage=isNull(@nWageHourlyRate,0),
      repairsmaint=isNull(@nRepairsMaint,0),
      typestube=isNull(@nTyreTubes,0),
      vehicalallow=isNull(@nVehicalAllow,0),
      accrate=isNull(@nACCRate,0),
      rr_item_proc_rate_per_hr=isNull(@nItemsHour,0),
      nFuel=isNull(@nFuel,0),
      consumptionrate=isNull(@nConsumption,0),
      extnamount=0,
      @nRUC,
      --new 2001
      nInsurancePct=isNull(@nInsurancePct,0),
      nLivery=isNull(@nLivery,0),
      nUniform=isNull(@nUniform,0),
      nACCAmount=isNull(@nACCAmount,0),
      @nDepreciation2,
      use_rucs=@nUse_rucs from
      contract join
      contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number join
      frequency_distances on
      (contract_renewals.contract_no = frequency_distances.contract_no and
      frequency_distances.fd_effective_date >= @dStartDate and
      @dStartDate is not null)--,0),-- 1
      join standard_frequency on
      frequency_distances.sf_key = standard_frequency.sf_key
      join rate_days on
      standard_frequency.sf_key = rate_days.sf_key where
      contract.contract_no = @in_contract and
      rate_days.rg_code = contract_renewals.con_rg_code_at_renewal and
      rate_days.rr_rates_effective_date = contract_renewals.con_rates_effective_date
      group by contract.contract_no,contract.con_title--,rr_item_proc_rate_per_hr
  else
    select top 1 contract.contract_no,
      contract.con_title,
      1,
      isnull(contract_renewals.con_distance_at_renewal,0),
      isnull(contract_renewals.con_no_customers_at_renewal,0),
      isnull(contract_renewals.con_no_rural_private_bags_at_renewal,0),
      isnull(contract_renewals.con_no_other_bags_at_renewal,0),
      isnull(contract_renewals.con_no_private_bags_at_renewal,0),
      isnull(contract_renewals.con_no_post_offices_at_renewal,0),
      isnull(contract_renewals.con_no_cmbs_at_renewal,0),
      isnull(contract_renewals.con_no_cmb_custs_at_renewal,0),
      isnull(contract_renewals.con_del_hrs_week_at_renewal,0),
      isnull(contract_renewals.con_processing_hours_per_week,0),
      isnull(contract_renewals.con_volume_at_renewal,0),
      extn_effective_date=rd.today(),
      extn_distance=0,
      extn_boxes=0,
      extn_rural_bags=0,
      extn_other_bags=0,
      extn_private_bags=0,
      extn_post_offices=0,
      extn_no_cmbs=0,
      extn_no_cmb_customers=0,
      extn_del_hrs=0,
      extn_proc_hrs=0,
      extn_mail_volume=0,
      extn_reason=space(250),
      no_del_days_year=0,
      isNull(@nWageHourlyRate,0),
      isNull(@nRepairsMaint,0),
      isNull(@nTyreTubes,0),
      isNull(@nVehicalAllow,0),
      isNull(@nACCRate,0),
      rr_item_proc_rate_per_hr=isNull(@nItemsHour,0),
      isNull(@nFuel,0),
      isNull(@nConsumption,0),
      0,
      nRUC=isNull(@nRUC,0),
      --New 2001
      nInsurancePct=isNull(@nInsurancePct,0),
      nLivery=isNull(@nLivery,0),
      nUniform=isNull(@nUniform,0),
      nACCAmount=isNull(@nACCAmount,0),
      @nDepreciation2,
      use_rucs=@nUse_rucs from
      contract join
      contract_renewals on
      contract.contract_no = contract_renewals.contract_no and
      contract.con_active_sequence = contract_renewals.contract_seq_number where
      contract.contract_no = @in_contract
end










GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO







CREATE procedure [odps].[OD_BLF_Mainrun](@incontract_no int,@inContractor_No int,@inPayPeriod_Start datetime,@inPayPeriod_End datetime)
-- TJB  SR4649  Dec 2004
-- Changed return value to string to return error information from OD_BLF_Mainrun_PostTaxAdj
-- Caught and parsed by Powerbuilder Payrun code (w_payrun_search)
-- When there''s an error, the string is a comma-separated list of values:
--      <return code>, <contractor no>, <deduction ID>, <deduction description>
-- otherwise its just a single value (the return code).
as -- returns integer
begin
set implicit_transactions on
  declare @v_contract_no int,
  @v_sequence_no int,
  @v_contractor_no int,
  @v_contractor_start datetime,
  @v_contractor_contract_start datetime,
  @v_contractor_end datetime,
  @v_renewal_start datetime,
  @v_renewal_end datetime,
  @v_grossresult int,
  @v_run_number int,
  @v_numloops int,
  @v_tempdate datetime,
  @v_termdate datetime,
  @v_temp_int int,
  @v_temp_int1 int, -- tjb SR4649
  @v_temp_string char(254), -- tjb SR4649
  @errmsg char(254)
  -- TWC - 12/08/2003 call 4544
  -- and(contract.con_active_sequence=contract_renewals.contract_seq_number)
  -- TWC - 01/09/2003 call 4557 
  declare vc_contract_list cursor for select contract.contract_no,
      contractor_renewals.contract_seq_number,
      contractor_renewals.contractor_supplier_no,
      contractor_renewals.cr_effective_date,
      (select dateadd(day,-1,min(cr.cr_effective_date)) from
        rd.contractor_renewals as cr where
        cr.contract_no = contract_renewals.contract_no and
        cr.contract_seq_number = contract_renewals.contract_seq_number and
        cr.cr_effective_date > contractor_renewals.cr_effective_date),
      contract_renewals.con_start_date,
      contract_renewals.con_expiry_date,
      contract.con_date_terminated from
      rd.contract_renewals,
      rd.contractor_renewals,
      rd.contract where
      (contractor_renewals.contract_no = contract_renewals.contract_no) and
      (contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number) and
      (contract.contract_no = contract_renewals.contract_no) and
      (contract_renewals.contract_seq_number = rd.maxSeqContractor(contract.contract_no,contractor_renewals.contractor_supplier_no)) and
      (rd.getContractorEnd(contract.contract_no,contractor_renewals.contractor_supplier_no) >= dateadd(month,-2,@inPayPeriod_End)) and
      (contract_renewals.con_start_date <= @inPayPeriod_End) and
      (contract.con_date_terminated is null or
      contract.con_date_terminated > @inPayPeriod_End or
      datediff(day,@inPayPeriod_Start,contract.con_date_terminated) < 63 or
      contract.con_date_terminated between @inPayPeriod_Start and @inPayPeriod_End) order by
      contract.contract_no asc,
      contractor_renewals.contract_seq_number asc,
      contractor_renewals.cr_effective_date asc
  -- and(contract.con_active_sequence=contract_renewals.contract_seq_number)
  -- TWC - 12/08/2003 - call 4544
  -- TWC 01/09/2003 - call 4557
  declare vc_contract_list1 cursor for select  contract.contract_no,
      contractor_renewals.contract_seq_number,
      contractor_renewals.contractor_supplier_no,
      contractor_renewals.cr_effective_date,
      (select dateadd(day,-1,min(cr.cr_effective_date)) from
        rd.contractor_renewals as cr where
        cr.contract_no = contract_renewals.contract_no and
        cr.contract_seq_number = contract_renewals.contract_seq_number and
        cr.cr_effective_date > contractor_renewals.cr_effective_date),
      contract_renewals.con_start_date,
      contract_renewals.con_expiry_date,
      contract.con_date_terminated from
      rd.contract_renewals,
      rd.contractor_renewals,
      rd.contract where
      (contract_renewals.contract_no = @inContract_no) and
      (contractor_renewals.contractor_supplier_no = @inContractor_No) and
      (contractor_renewals.contract_no = contract_renewals.contract_no) and
      (contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number) and
      (contract.contract_no = contract_renewals.contract_no) and
      (contract_renewals.contract_seq_number = rd.maxSeqContractor(contract.contract_no,contractor_renewals.contractor_supplier_no)) and
      (rd.getContractorEnd(contract.contract_no,contractor_renewals.contractor_supplier_no) >= dateadd(month,-2,@inPayPeriod_Start)) and
      (contract_renewals.con_start_date <= @inPayPeriod_End) and
      (contract.con_date_terminated is null or
      contract.con_date_terminated > @inPayPeriod_End or
      datediff(day,@inPayPeriod_Start,contract.con_date_terminated) < 63 or
      contract.con_date_terminated between @inPayPeriod_Start and @inPayPeriod_End) order by
      contract.contract_no asc,
      contractor_renewals.contract_seq_number asc,
      contractor_renewals.cr_effective_date asc  
  select @v_numloops=0
  select @v_run_number = 1 

  if @v_run_number = -1 or @@error < 0
    begin
        rollback transaction
		select '-1'
		set implicit_transactions off
      return '-1'
    end
  --    return -1

  delete from t_payment_runs
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
		select convert(char(254),@@error)
		set implicit_transactions off
      return convert(char(254),@@error)
    end
  --    return sqlcode
  delete from t_piecerate_tracker
  if @@error <> 0 /* <> was < */
    begin
      rollback transaction
		select convert(char(254),@@error)
		set implicit_transactions off
	  return convert(char(254),@@error)
    end
  --    return sqlcode
  commit transaction
 
 /*jlwang:set identity start from 0*/
  DBCC CHECKIDENT ('odps.t_payment_runs', RESEED, 0)
  DBCC CHECKIDENT ('odps.t_payment', RESEED, 0)
  DBCC CHECKIDENT ('odps.t_payment_component',reseed,0)
 /*jlwang:end*/
  insert into t_payment_runs(/*pr_id,*/  --!Cannot insert explicit value for identity column
    pr_date,
    gl_posted,
    pr_ap_posted,
    pr_contract_no) values(
    /*@v_run_number,*/ 
    -- jlwang: convert(int,@inPayPeriod_End)
	(convert(varchar,YEAR(@inPayPeriod_End))
	+(case when len(month(@inPayPeriod_End))= 1 
	 then '0' 
	 else '' 
	 end)+convert(varchar,month(@inPayPeriod_End))
	+(case when len(month(@inPayPeriod_End))= 1 
	 then '0' 
	 else '' 
	 end)+convert(varchar,day(@inPayPeriod_End)))
    ,'N','N',
    @inContract_no)

  if @@error <> 0
    begin
      rollback transaction
		select '-2'
		set implicit_transactions off
      return '-2'
    end

  --    return -2
  if @incontract_no = 0
    begin
      open vc_contract_list
      if @@error <> 0
        begin
          rollback transaction
		select '-3'
			set implicit_transactions off
          return '-3'
        end
      --      return -3
      /* Watcom only
      MAINLOOP:
      */while 1=1 
        /* Watcom only
        MYLABEL1:
        */begin
          fetch next from vc_contract_list into @v_contract_no,
            @v_sequence_no,
            @v_contractor_no,
            @v_contractor_start,
            @v_contractor_end,
            @v_renewal_start,
            @v_renewal_end,
            @v_termdate
          if @@error <>0
            begin
              rollback transaction
		select '-4'
			set implicit_transactions off
              return '-4'
            end
          --          return -4
          if @@fetch_status <0
            break
            /* Watcom only
            MAINLOOP
            */
          select @v_contractor_contract_start=@v_contractor_start
          select @v_temp_int = count(payment.contractor_supplier_no)
            from payment where
            (payment.contractor_supplier_no = @v_contractor_no) and
            (payment.invoice_date between @inPayPeriod_Start and @inPayPeriod_End) and
            (payment.contract_no = @v_contract_no)
          if @@error <> 0 /* <> was < */
            begin
              rollback transaction
		select '-20'
			set implicit_transactions off
              return '-20'
            end
          --          return -20
        if @v_temp_int <= 0
            /* Watcom only
            MYLABEL1
            */
          -- TWC call 4557
          if(@v_contractor_end is null or @v_contractor_end >= @inPayPeriod_Start or datediff(day,@v_contractor_end,@inPayPeriod_Start) < 63) and @v_contractor_start <= @inPayPeriod_End
            begin
              if @v_contractor_start <= @inPayPeriod_Start
                select @v_contractor_start=@inPayPeriod_Start
              if @v_contractor_end is null or @v_contractor_end >= @inPayPeriod_End
                select @v_contractor_end=@inPayPeriod_End
              if @v_termdate < @v_contractor_end
                select @v_contractor_end=@v_termdate
                exec @v_grossresult = odps.od_blf_mainrun_grosspay @v_contract_no,@v_sequence_no,@v_contractor_no,@v_contractor_start,@v_contractor_end,@inPayPeriod_Start,@inPayPeriod_End,@v_run_number,@v_renewal_start,@v_renewal_end,@v_contractor_contract_start
              if @v_grossresult < -100000000
                begin
                
                  rollback transaction
					select convert(char(254),@v_grossresult)
					set implicit_transactions off
                  return convert(char(254),@v_grossresult)
                end
              --            return v_grossresult
              if @@error <> 0 /* <> was < */
                begin
                    rollback transaction
					select convert(char(254),@@error)
				    set implicit_transactions off
					return convert(char(254),@@error)
                end
              --            return sqlcode
              select @v_numloops=@v_numloops+1
            end
        end  --end of while 
      if @@error <> 0
        begin
          rollback transaction
		select '-6'
			set implicit_transactions off
          return '-6'
        end
    end
  else
    begin
      --      return -6
      open vc_contract_list1
      if @@error<>0
        begin
          rollback transaction
		select '-7'
			set implicit_transactions off
          return '-7'
        end
      --      return -7
      /* Watcom only
      MAINLOOP2:
      */while 1=1 
        /* Watcom only
        MYLABEL2:
        */begin
          fetch next from vc_contract_list1 into @v_contract_no,
            @v_sequence_no,
            @v_contractor_no,
            @v_contractor_start,
            @v_contractor_end,
            @v_renewal_start,
            @v_renewal_end,
            @v_termdate
          if @@fetch_status =-2
            begin
              rollback transaction
				select '-8'
				set implicit_transactions off
              return '-8'
            end
          --          return -8
          if @@fetch_status <0
            break
            /* Watcom only
            MAINLOOP2
            */
          select @v_contractor_contract_start=@v_contractor_start
          -- TWC - 01/09/2003 call 4557
          if(@v_contractor_end is null or @v_contractor_end >= @inPayPeriod_Start or datediff(day,@v_contractor_end,@inPayPeriod_Start) < 63) and @v_contractor_start <= @inPayPeriod_End
            begin
              if @v_contractor_start <= @inPayPeriod_Start
                select @v_contractor_start=@inPayPeriod_Start
              if @v_contractor_end is null or @v_contractor_end >= @inPayPeriod_End
                select @v_contractor_end=@inPayPeriod_End
              if @v_termdate < @v_contractor_end
                select @v_contractor_end=@v_termdate
                execute @v_grossresult = odps.od_blf_mainrun_grosspay @v_contract_no,@v_sequence_no,@v_contractor_no,@v_contractor_start,@v_contractor_end,@inPayPeriod_Start,@inPayPeriod_End,@v_run_number,@v_renewal_start,@v_renewal_end,@v_contractor_contract_start
             
        if @v_grossresult < -100000000
                begin
                  rollback transaction
		select convert(char(254),@v_grossresult)
					set implicit_transactions off
                  return convert(char(254),@v_grossresult)
                end
              --            return v_grossresult;
              if @@error <> 0 /* <> was < */
                begin
                  rollback transaction
		select convert(char(254),@@error)
				set implicit_transactions off
                  return convert(char(254),@@error)
                end
              --            return sqlcode;
              select @v_numloops=@v_numloops+1
            end
          else
            select @v_numloops=@v_numloops
        end
      if @@error <> 0
        begin
          rollback transaction
		select '-10'
		set implicit_transactions off
          return '-10'
        end
    end
  --      return -10
  execute @v_temp_int = odps.OD_BLF_Mainrun_WithHoldingTax 
  if @@error <> 0
    begin
      rollback transaction
		select '-13'
		set implicit_transactions off
      return '-13'
    end
  --    return -13;
  execute @v_temp_int = odps.OD_BLF_Mainrun_GST
  
  if @@error <> 0
    begin
      rollback transaction
		select '-12'
		set implicit_transactions off
      return '-12'
    end
  --    return -12;
  -- tjb  sr4649   Changed to trap error info from PostTaxAdj and pass it on
  --  select OD_BLF_Mainrun_PostTaxAdj( inPayPeriod_Start, inPayPeriod_End) 
  --    into v_temp_int 
  --    from sys.dummy;
  --  if sqlcode<>0 or (v_temp_int<0 and v_temp_int>-500) then
  --    rollback work;
  --    return '-12';
  -- --    return -12
  --  end if;

--   execute @v_temp_string = odps.OD_BLF_Mainrun_PostTaxAdj @inPayPeriod_Start,@inPayPeriod_End

  -- Extract the numeric return code from the string
  select @v_temp_int1=charindex(',',@v_temp_string)
  if @v_temp_int1 > 0
    select @v_temp_int=convert(int,left(@v_temp_string,@v_temp_int1-1))
  else
    select @v_temp_int=convert(int,@v_temp_string)
  if @@error <> 0 or(@v_temp_int < -1 and @v_temp_int > -500)
    begin
      rollback transaction
		select '-12'
		set implicit_transactions off
      return '-12'
    end
  else
  if @v_temp_int = -1
	begin
		rollback transaction
		select '-12'
		set implicit_transactions off
		return @v_temp_string
    end
commit transaction
  if @@error <> 0 /* <> was < */
    begin
		select '-15'
		set implicit_transactions off
      return '-15'
    end
  --    return -15

select convert(char(254),@v_numloops)
/* Watcom only
exception
  when others then --  return v_numloops;
    rollback transaction
    resignal
    return '-1'
*/
--    return -1;
set implicit_transactions off
end





ALTER TRIGGER [rd].[trig_rdscust_delete] ON [rd].[rds_customer]
WITH EXECUTE AS CALLER
FOR DELETE
AS
begin
  declare @lcno int
  declare @tempid varchar
  declare @Tim varchar
  select @lcno = address.contract_no
    from address,
    customer_address_moves where
    customer_address_moves.adr_id = address.adr_id and
    customer_address_moves.cust_id = (select cust_id from deleted) and
    customer_address_moves.move_out_date is null
    
    select @tempid = convert(varchar,(select cust_id from deleted))
    select @Tim = convert(varchar,(select contractor_renewals.contractor_supplier_no from
      contract,
      contract_renewals,
      contractor_renewals where
      (contract_renewals.contract_no = @lcno) and
      (contract_renewals.contract_no = contract.contract_no) and
      (contract.con_active_sequence = contract_renewals.contract_seq_number) and
      (contractor_renewals.contract_no = contract_renewals.contract_no) and
      (contractor_renewals.contract_seq_number = contract_renewals.contract_seq_number) and
      (contract_renewals.con_date_last_assigned = contractor_renewals.cr_effective_date)))
  
insert into rds_audit(
    a_datetime,
    a_userid,
    a_contract,
    a_contractor,
    a_comment,
    a_oldvalue,
    a_newvalue) values(
    
    getdate(),'DB Trigger',
    @lcno,
    @Tim,
    'Customer delete audit by trigger','Customer id: ' + 
    @tempid,
    null)
end

set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON
go

ALTER TRIGGER [t_pta_i] ON [odps].[post_tax_deductions]
WITH EXECUTE AS CALLER
FOR INSERT
AS
begin
  update post_tax_deductions set ded_end_balance= ded_start_balance --(select ded_start_balance from inserted) 
  where ded_id=(select max(ded_id) from odps.post_tax_deductions)
end


set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON
go

ALTER TRIGGER [t_pta_u] ON [odps].[post_tax_deductions]
WITH EXECUTE AS CALLER
FOR UPDATE
AS
begin
	declare @old_ded_end_balance decimal(12,2),@new_ded_id int,@new_ded_start_balance decimal(12,2)
	select @old_ded_end_balance = ded_end_balance from deleted
    select @new_ded_start_balance=ded_start_balance from inserted
    select @new_ded_id = ded_id from inserted

    if @new_ded_start_balance <> @old_ded_end_balance
    update post_tax_deductions set
      ded_end_balance = ded_start_balance+
      isnull((select sum(pcd_amount) from post_tax_deductions_applied where post_tax_deductions_applied.ded_id = post_tax_deductions.ded_id),0) 
    where
      post_tax_deductions.ded_id = @new_ded_id
end

ALTER TRIGGER [t_ptad] ON [odps].[post_tax_deductions_applied]
WITH EXECUTE AS CALLER
FOR INSERT
AS
begin
  update post_tax_deductions set
    ded_end_balance = ded_start_balance-
    isnull((select sum(pcd_amount)*-1 
            from post_tax_deductions_applied 
            where post_tax_deductions_applied.ded_id = post_tax_deductions.ded_id),0) 
  where
    post_tax_deductions.ded_id =(select ded_id from inserted) and ded_start_balance <> 0
end


ALTER TRIGGER [trig_NewRenewal2001] ON [rd].[contract_renewals]
WITH EXECUTE AS CALLER
FOR INSERT
AS
begin
  declare @dStartDate datetime,
  @nNumRows int,
  @nDistance real,
  @nCustomers real,
  @nRuralBags real,
  @nOtherBags real,
  @nPrivateBags real,
  @nPostOffices real,
  @dRenewalARateDate datetime,
  @nCMBs real,
  @nCMBCusts real,
  @nDelHrs real,
  @nProcHrs real,
  @nVolume real,
  @nRGCode int,
  @nFreqs int,
  @dRenewalRateDate datetime,
  @dDate datetime,
  @nCount int,
  @nPaymentPrice numeric(10,2),
  @nFDAmount numeric(10,2),
  @dConStartDate datetime,
  @dConEndDate datetime
	declare @new_contract_no int,
		@new_contract_seq_number int,
		@new_con_rg_code_at_renewal int,
		@new_con_rates_effective_date datetime
	select @new_contract_no = contract_no ,
			@new_contract_seq_number = contract_seq_number ,
			@new_con_rates_effective_date = con_rates_effective_date,
			@new_con_rg_code_at_renewal = con_rg_code_at_renewal from inserted
  if @new_contract_seq_number > 1
    begin
      if @new_con_rg_code_at_renewal is null
        select @nRGCode = rg_code
          from contract where
          contract_no = @new_contract_no
      else
        select @nRGCode=@new_con_rg_code_at_renewal
      if @new_con_rates_effective_date is null
        select @dRenewalRateDate = max(nvr_rates_effective_date)
          from non_vehicle_rate where
          rg_code = @nRGCode
      else
        select @dRenewalARateDate=@new_con_rates_effective_date
      select @dConStartDate = non_vehicle_rate.nvr_contract_start,
        @dConEndDate = non_vehicle_rate.nvr_contract_end
         from non_vehicle_rate where
        non_vehicle_rate.rg_code = @nRGCode and
        non_vehicle_rate.nvr_rates_effective_date = @dRenewalRateDate
      select @dStartDate = con_start_date
        from contract_renewals where
        contract_renewals.contract_no = @new_contract_no and
        contract_renewals.contract_seq_number = (@new_contract_seq_number-1)
      select @nFreqs = count(*)
        from route_frequency where
        route_frequency.contract_no = @new_contract_no and
        route_frequency.rf_active = 'Y'
      --set nFreqs=1
      select @nNumRows = count(*),
        @nDistance=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_distance_at_renewal,0))/ count(*)) else 0 end)+
        sum(isnull(frequency_distances.fd_distance,0)*rate_days.rtd_days_per_annum),
        @nCustomers=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_no_customers_at_renewal,0))/ count(*)) else 0 end)+
        sum(isnull(frequency_distances.fd_no_of_boxes,0)),
        @nRuralBags=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_no_rural_private_bags_at_renewal,0))/ count(*)) else 0 end)+
        sum(isnull(frequency_distances.fd_no_rural_bags,0)),
        @nOtherBags=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_no_other_bags_at_renewal,0))/ count(*)) else 0 end)+
        sum(isnull(frequency_distances.fd_no_other_bags,0)),
        @nPrivateBags=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_no_private_bags_at_renewal,0))/ count(*)) else 0 end)+
        sum(isnull(frequency_distances.fd_no_private_bags,0)),
        @nPostOffices=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_no_post_offices_at_renewal,0))/ count(*)) else 0 end)+
        sum(isnull(frequency_distances.fd_no_post_offices,0)),
        @nCMBs=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_no_cmbs_at_renewal,0))/ count(*)) else 0 end)+
        sum(isnull(frequency_distances.fd_no_cmbs,0)),
        @nCMBCusts=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_no_cmb_custs_at_renewal,0))/ count(*)) else 0 end)+
        sum(isnull(frequency_distances.fd_no_cmb_customers,0)),
        @nDelHrs=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_del_hrs_week_at_renewal,0))/ count(*)) else 0 end)+
        (case when @nFreqs > 0 then sum(isnull(frequency_distances.fd_delivery_hrs_per_week,0))/@nFreqs else 0 end),
        @nProcHrs=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_processing_hours_per_week,0))/ count(*)) else 0 end)+
        sum(isnull(frequency_distances.fd_processing_hrs_week,0)),
        @nVolume=(case when  count(*) > 0 then(sum(isnull(contract_renewals.con_volume_at_renewal,0))/ count(*)) else 0 end)+
        sum(isnull(frequency_distances.fd_volume,0)),
        @nPaymentprice = contract_renewals.con_renewal_payment_value
         from contract join
        contract_renewals on
        contract.contract_no = contract_renewals.contract_no and
        contract.con_active_sequence = contract_renewals.contract_seq_number join
        route_frequency as rou on
        contract.contract_no = rou.contract_no
        left outer join
        frequency_distances on
        (rou.contract_no = frequency_distances.contract_no and
        frequency_distances.fd_effective_date >= @dStartDate and
        @dStartDate is not null) join
        standard_frequency as sta on rou.sf_key = sta.sf_key,
        standard_frequency join
        rate_days on
        standard_frequency.sf_key = rate_days.sf_key where
        contract.contract_no = @new_contract_no and
        rate_days.rg_code = contract_renewals.con_rg_code_at_renewal and
        rate_days.rr_rates_effective_date = contract_renewals.con_rates_effective_date and
        rou.rf_active = 'Y'
        group by contract.contract_no,contract.con_title,contract_renewals.con_renewal_payment_value
      -- PBY 25/06/2002 SR#4412
      -- The payment value for the pending contract should
      -- be calculated as payment_value from last period + any
      -- confirmed frequency adjustments
      select @nFDAmount = sum(fd_amount_to_pay)
        from frequency_adjustments where
        contract_no = @new_contract_no and
        contract_seq_number = @new_contract_seq_number-1 and
        fd_confirmed = 'Y'
      select @nPaymentprice=isNull(@nPaymentPrice,0)+isNull(@nFDAmount,0)
      /*select count(customer.cust_id) into nCustomers
      from customer where
      customer.contract_no = @new_contract_no;*/
      select @nCustomers = count(customer_address_moves.cust_id)
        from address,
        customer_address_moves,
        rds_customer where
        (customer_address_moves.adr_id = address.adr_id) and
        (rds_customer.cust_id = customer_address_moves.cust_id) and
        ((customer_address_moves.move_out_date is null) and
        (address.contract_no = @new_contract_no) and
        (rds_customer.master_cust_id is null))
      --!if @@error < 0
        /* Watcom only
        resignal
        */
      -- PBY 13/06/2002 SR#4398
      -- Added con_acceptance_flag, defaulted to 'N'
      update contract_renewals set
        con_acceptance_flag = 'N',
        con_no_customers_at_renewal = @nCustomers,
        con_no_rural_private_bags_at_renewal = @nRuralBags,
        con_no_other_bags_at_renewal = @nOtherBags,
        con_no_private_bags_at_renewal = @nPrivateBags,
        con_no_post_offices_at_renewal = @nPostOffices,
        con_no_cmbs_at_renewal = @nCMBs,
        con_no_cmb_custs_at_renewal = @nCMBCusts,
        con_del_hrs_week_at_renewal = @nDelHrs,
        con_processing_hours_per_week = @nProcHrs,
        con_volume_at_renewal = @nVolume,
        con_rg_code_at_renewal = @nRgCode,
        con_rates_effective_date = @dRenewalRateDate,
        con_start_date = @dConStartDate,
        con_expiry_date = @dConEndDate,
        con_renewal_payment_value = @nPaymentPrice where
        contract_renewals.contract_no = @new_contract_no and
        contract_renewals.contract_seq_number = @new_contract_seq_number
      update contract_renewals set
        con_distance_at_renewal = rd.GetContractDistance(contract_no,contract_seq_number) where
        contract_no = @new_contract_no and
        contract_seq_number = @new_contract_seq_number
      -- PBY 12/06/2002 SR#4401
      -- Code below is commented out
      --    select count(*) into nCount
      --    from contract_vehical where
      --    contract_no = @new_contract_no and
      --    contract_seq_number = (@new_contract_seq_number-1) and
      --    cv_vehical_status = 'N';
      --
      --    if nCount > 0 then
      --      insert into contract_vehical(vehicle_number,
      --        contract_no,
      --        contract_seq_number,
      --        start_kms,
      --        vehicle_allowance_paid_to_date,
      --        cv_vehical_status)
      --        select vehicle_number,
      --          contract_no,
      --          @new_contract_seq_number,
      --          start_kms,
      --          vehicle_allowance_paid_to_date,'A' from
      --          contract_vehical where
      --          contract_no = @new_contract_no and
      --          contract_seq_number = @new_contract_seq_number-1 and
      --          cv_vehical_status = 'N'
      --  else
      --      insert into contract_vehical(vehicle_number,
      --        contract_no,
      --        contract_seq_number,
      --        start_kms,
      --        vehicle_allowance_paid_to_date,
      --        cv_vehical_status)
      --       select vehicle_number,
      --          contract_no,
      --          @new_contract_seq_number,
      --          start_kms,
      --          vehicle_allowance_paid_to_date,'A' from
      --          contract_vehical where
      --          contract_no = @new_contract_no and
      --          contract_seq_number = @new_contract_seq_number-1 and
      --          cv_vehical_status = 'A'
      --    end if;
      --
      -- PBY 12/06/2002 SR#4401
      -- Code below added.
      -- Grabs the latest vehicle from the last period and bring it into
      -- this new renewal period
      insert into contract_vehical(vehicle_number,
        contract_no,
        contract_seq_number,
        start_kms,
        vehicle_allowance_paid_to_date,
        cv_vehical_status)
        select vehicle_number,
          contract_no,
          @new_contract_seq_number,
          start_kms,
          vehicle_allowance_paid_to_date,'A' from
          contract_vehical where
          contract_no = @new_contract_no and
          contract_seq_number = @new_contract_seq_number-1 and
          vehicle_number = rd.f_GetLatestVehicle(@new_contract_no,@new_contract_seq_number-1)
      insert into contractor_renewals(contractor_supplier_no,
        contract_no,
        contract_seq_number,
        cr_effective_date)
        select contractor_supplier_no,
          contract_no,
          @new_contract_seq_number,
          cr_effective_date from
          contractor_renewals where
          contract_no = @new_contract_no and
          contract_seq_number = @new_contract_seq_number-1 and
          cr_effective_date = (select max(cr_effective_date) from contractor_renewals where contract_no = @new_contract_no and contract_seq_number = @new_contract_seq_number-1)
      -- PBY 11/06/2002 SR#4001
      -- Bring forward any manually created override rates
      -- PBY 24/06/2002 SR#4410
      -- Made sure the rates from the latest effective date is used.
      insert into vehicle_override_rate(contract_no,
        contract_seq_number,
        vor_nominal_vehicle_value,
        vor_repairs_maintenance_rate,
        vor_tyre_tubes_rate,
        vor_vehical_allowance_rate,
        vor_licence_rate,
        vor_vehicle_rate_of_return_pct,
        vor_salvage_ratio,
        vor_ruc,
        vor_sundries_k,
        vor_vehicle_insurance_premium,
        vor_fuel_rate,
        vor_consumption_rate,
        vor_livery,
        vor_effective_date)
        select @new_contract_no,
          @new_contract_seq_number,
          vor_nominal_vehicle_value,
          vor_repairs_maintenance_rate,
          vor_tyre_tubes_rate,
          vor_vehical_allowance_rate,
          vor_licence_rate,
          vor_vehicle_rate_of_return_pct,
          vor_salvage_ratio,
          vor_ruc,
          vor_sundries_k,
          vor_vehicle_insurance_premium,
          vor_fuel_rate,
          vor_consumption_rate,
          vor_livery,
          @dRenewalRateDate from
          vehicle_override_rate where
          contract_no = @new_contract_no and
          contract_seq_number = @new_contract_seq_number-1 order by
          vor_effective_date desc
      insert into non_vehicle_override_rate(contract_no,
        contract_seq_number,
        nvor_wage_hourly_rate,
        nvor_public_liability_rate_2,
        nvor_carrier_risk_rate,
        nvor_acc_rate,
        nvor_item_proc_rate_per_hour,
        nvor_frozen,
        nvor_accounting,
        nvor_telephone,
        nvor_sundries,
        nvor_acc_rate_amount,
        nvor_uniform)
        select @new_contract_no,
          @new_contract_seq_number,
          nvor_wage_hourly_rate,
          nvor_public_liability_rate_2,
          nvor_carrier_risk_rate,
          nvor_acc_rate,
          nvor_item_proc_rate_per_hour,
          nvor_frozen,
          nvor_accounting,
          nvor_telephone,
          nvor_sundries,
          nvor_acc_rate_amount,
          nvor_uniform from
          non_vehicle_override_rate where
          contract_no = @new_contract_no and
          contract_seq_number = @new_contract_seq_number-1
    end
end
